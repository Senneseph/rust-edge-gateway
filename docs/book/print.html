<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Edge Gateway</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for writing handlers and using the Rust Edge Gateway SDK">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Edge Gateway</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Senneseph/Rust-Edge-Gateway" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-edge-gateway"><a class="header" href="#rust-edge-gateway">Rust Edge Gateway</a></h1>
<p><strong>Rust Edge Gateway</strong> is a high-performance API gateway that lets you write request handlers in Rust. Your handlers are compiled to native binaries and run as isolated worker processes, providing:</p>
<ul>
<li>ğŸš€ <strong>Native Performance</strong> - Handlers compile to optimized native code</li>
<li>ğŸ”’ <strong>Isolation</strong> - Each handler runs in its own process</li>
<li>ğŸ”„ <strong>Hot Reload</strong> - Update handlers without restarting the gateway</li>
<li>ğŸ› ï¸ <strong>Simple SDK</strong> - Easy-to-use Request/Response API</li>
<li>ğŸ“¦ <strong>Service Integration</strong> - Connect to databases, Redis, and more</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚â”€â”€â”€â”€â–¶â”‚  Edge Gateway    â”‚â”€â”€â”€â”€â–¶â”‚  Your Handler   â”‚
â”‚  (Browser,  â”‚     â”‚  (Routes &amp;       â”‚     â”‚  (Compiled      â”‚
â”‚   API, etc) â”‚â—€â”€â”€â”€â”€â”‚   Manages)       â”‚â—€â”€â”€â”€â”€â”‚   Rust Binary)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Services    â”‚
                    â”‚  (DB, Redis,  â”‚
                    â”‚   MinIO, etc) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<ol>
<li><strong>Gateway receives request</strong> - The gateway matches the incoming request to an endpoint</li>
<li><strong>Handler is invoked</strong> - The compiled handler binary receives the request via IPC</li>
<li><strong>Handler processes</strong> - Your code runs, optionally using injected services</li>
<li><strong>Response returned</strong> - The handler sends the response back through the gateway</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>The fastest way to get started is to:</p>
<ol>
<li>Access the Admin UI at <code>/admin/</code></li>
<li>Create a new endpoint</li>
<li>Write your handler code</li>
<li>Compile and test</li>
</ol>
<p>See the <a href="./getting-started/quick-start.html">Quick Start</a> guide for detailed instructions.</p>
<h2 id="sdk-overview"><a class="header" href="#sdk-overview">SDK Overview</a></h2>
<p>Your handler code uses the <code>rust-edge-gateway-sdk</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello, World!",
        "path": req.path,
        "method": req.method,
    }))
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<p>The SDK provides:</p>
<ul>
<li><strong><a href="./sdk/request.html">Request</a></strong> - Access HTTP method, path, headers, body, query params</li>
<li><strong><a href="./sdk/response.html">Response</a></strong> - Build HTTP responses with JSON, text, or custom content</li>
<li><strong><a href="./sdk/errors.html">HandlerError</a></strong> - Structured error handling with HTTP status codes</li>
<li><strong><a href="./sdk/services.html">Services</a></strong> - Database, Redis, and other service integrations</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>Rust Edge Gateway uses a worker process model:</p>
<ul>
<li><strong>Main Gateway</strong> - Axum-based HTTP server handling routing</li>
<li><strong>Worker Processes</strong> - Your compiled handlers as standalone binaries</li>
<li><strong>IPC Protocol</strong> - Length-prefixed JSON over stdin/stdout</li>
<li><strong>Service Connectors</strong> - Pooled connections to backends (DB, Redis, etc.)</li>
</ul>
<p>This architecture provides:</p>
<ul>
<li><strong>Security</strong> - Handlers can't directly access the gateway's memory</li>
<li><strong>Stability</strong> - A crashed handler doesn't bring down the gateway</li>
<li><strong>Scalability</strong> - Multiple worker instances can handle concurrent requests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>This guide will help you create your first Rust Edge Gateway endpoint in under 5 minutes.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Rust Edge Gateway running (either locally via Docker or deployed)</li>
<li>Access to the Admin UI</li>
</ul>
<h2 id="step-1-access-the-admin-ui"><a class="header" href="#step-1-access-the-admin-ui">Step 1: Access the Admin UI</a></h2>
<p>Navigate to your gateway's admin interface:</p>
<ul>
<li><strong>Local Development</strong>: <code>http://localhost:9081/admin/</code></li>
<li><strong>Production</strong>: <code>https://rust-edge-gateway.yourdomain.com/admin/</code></li>
</ul>
<h2 id="step-2-create-an-endpoint"><a class="header" href="#step-2-create-an-endpoint">Step 2: Create an Endpoint</a></h2>
<ol>
<li>Click <strong>"Create Endpoint"</strong> or the <strong>+</strong> button</li>
<li>Fill in the endpoint details:</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Example Value</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td><code>hello-world</code></td><td>Unique identifier for your endpoint</td></tr>
<tr><td><strong>Path</strong></td><td><code>/hello</code></td><td>The URL path to match</td></tr>
<tr><td><strong>Method</strong></td><td><code>GET</code></td><td>HTTP method (GET, POST, PUT, DELETE, etc.)</td></tr>
<tr><td><strong>Domain</strong></td><td><code>*</code></td><td>Domain to match (or <code>*</code> for all)</td></tr>
</tbody></table>
</div>
<ol start="3">
<li>Click <strong>Save</strong></li>
</ol>
<h2 id="step-3-write-handler-code"><a class="header" href="#step-3-write-handler-code">Step 3: Write Handler Code</a></h2>
<p>In the code editor, replace the default code with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello from Rust Edge Gateway!",
        "path": req.path,
        "method": req.method,
        "timestamp": chrono::Utc::now().to_rfc3339(),
    }))
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="step-4-compile"><a class="header" href="#step-4-compile">Step 4: Compile</a></h2>
<p>Click the <strong>"Compile"</strong> button. The gateway will:</p>
<ol>
<li>Generate a Cargo project with your code</li>
<li>Compile it to a native binary</li>
<li>Report success or any compilation errors</li>
</ol>
<p>You should see a success message like:</p>
<pre><code>âœ“ Compiled successfully in 2.3s
</code></pre>
<h2 id="step-5-start-the-endpoint"><a class="header" href="#step-5-start-the-endpoint">Step 5: Start the Endpoint</a></h2>
<p>Click <strong>"Start"</strong> to activate the endpoint. The status should change to <strong>Running</strong>.</p>
<h2 id="step-6-test-your-endpoint"><a class="header" href="#step-6-test-your-endpoint">Step 6: Test Your Endpoint</a></h2>
<p>Make a request to your endpoint:</p>
<pre><code class="language-bash">curl http://localhost:9080/hello
</code></pre>
<p>You should receive:</p>
<pre><code class="language-json">{
  "message": "Hello from Rust Edge Gateway!",
  "path": "/hello",
  "method": "GET",
  "timestamp": "2024-01-15T10:30:00.000Z"
}
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<ul>
<li><a href="getting-started/./first-handler.html">Your First Handler</a> - Deeper dive into handler structure</li>
<li><a href="getting-started/./lifecycle.html">Handler Lifecycle</a> - Understand compilation and execution</li>
<li><a href="getting-started/../sdk/request.html">Request API</a> - Access headers, body, parameters</li>
<li><a href="getting-started/../sdk/response.html">Response API</a> - Build JSON, text, and custom responses</li>
<li><a href="getting-started/../examples/hello-world.html">Examples</a> - More code examples</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h3>
<p>Check the error message for:</p>
<ul>
<li>Missing dependencies (add to your handler's <code>use</code> statements)</li>
<li>Syntax errors (Rust compiler messages are helpful!)</li>
<li>Type mismatches</li>
</ul>
<h3 id="endpoint-not-responding"><a class="header" href="#endpoint-not-responding">Endpoint Not Responding</a></h3>
<ol>
<li>Check the endpoint is in <strong>Running</strong> status</li>
<li>Verify the path matches exactly (paths are case-sensitive)</li>
<li>Check the method matches your request</li>
<li>View endpoint logs in the admin UI</li>
</ol>
<h3 id="handler-crashes"><a class="header" href="#handler-crashes">Handler Crashes</a></h3>
<p>View the logs to see panic messages or error output. Common causes:</p>
<ul>
<li>Unwrapping <code>None</code> or <code>Err</code> values</li>
<li>Stack overflow from deep recursion</li>
<li>Accessing invalid JSON fields</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-handler"><a class="header" href="#your-first-handler">Your First Handler</a></h1>
<p>This guide explains the structure of a handler and how to work with requests and responses.</p>
<h2 id="handler-structure"><a class="header" href="#handler-structure">Handler Structure</a></h2>
<p>Every handler follows the same pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    // Your logic here
    Response::ok(json!({"status": "success"}))
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="the-prelude"><a class="header" href="#the-prelude">The Prelude</a></h3>
<p>The <code>prelude</code> module imports everything you typically need:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

// This imports:
// - Request, Response types
// - serde::{Deserialize, Serialize}
// - serde_json::{json, Value as JsonValue}
// - read_request, send_response IPC functions
// - HandlerError for error handling
<span class="boring">}</span></code></pre></pre>
<h3 id="the-handler-function"><a class="header" href="#the-handler-function">The Handler Function</a></h3>
<p>Your handler function receives a <code>Request</code> and returns a <code>Response</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    // Access request data
    let method = &amp;req.method;  // "GET", "POST", etc.
    let path = &amp;req.path;      // "/users/123"
    
    // Return a response
    Response::ok(json!({"received": path}))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-handler-loop-macro"><a class="header" href="#the-handler-loop-macro">The Handler Loop Macro</a></h3>
<p>The <code>handler_loop!</code> macro sets up the main function and IPC loop:</p>
<pre><pre class="playground"><code class="language-rust">handler_loop!(handle);

// This expands to:
fn main() {
    loop {
        match read_request() {
            Ok(req) =&gt; {
                let response = handle(req);
                send_response(response).unwrap();
            }
            Err(_) =&gt; break,
        }
    }
}</code></pre></pre>
<h2 id="working-with-requests"><a class="header" href="#working-with-requests">Working with Requests</a></h2>
<h3 id="accessing-the-body"><a class="header" href="#accessing-the-body">Accessing the Body</a></h3>
<p>For POST/PUT requests, parse the JSON body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

fn handle(req: Request) -&gt; Response {
    // Parse JSON body
    let user: CreateUser = match req.json() {
        Ok(u) =&gt; u,
        Err(e) =&gt; return Response::bad_request(format!("Invalid JSON: {}", e)),
    };
    
    Response::created(json!({
        "id": "new-user-id",
        "name": user.name,
        "email": user.email,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="path-parameters"><a class="header" href="#path-parameters">Path Parameters</a></h3>
<p>Extract dynamic path segments (e.g., <code>/users/{id}</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let user_id = req.path_param("id")
        .ok_or_else(|| "Missing user ID")?;
    
    Response::ok(json!({"user_id": user_id}))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="query-parameters"><a class="header" href="#query-parameters">Query Parameters</a></h3>
<p>Access query string values (e.g., <code>?page=1&amp;limit=10</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let page = req.query_param("page")
        .map(|s| s.parse::&lt;u32&gt;().unwrap_or(1))
        .unwrap_or(1);
    
    let limit = req.query_param("limit")
        .map(|s| s.parse::&lt;u32&gt;().unwrap_or(10))
        .unwrap_or(10);
    
    Response::ok(json!({
        "page": page,
        "limit": limit,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="headers"><a class="header" href="#headers">Headers</a></h3>
<p>Access HTTP headers (case-insensitive):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let auth = req.header("Authorization");
    let content_type = req.header("Content-Type");
    
    if auth.is_none() {
        return Response::json(401, json!({"error": "Unauthorized"}));
    }
    
    Response::ok(json!({"authenticated": true}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-responses"><a class="header" href="#working-with-responses">Working with Responses</a></h2>
<h3 id="json-responses"><a class="header" href="#json-responses">JSON Responses</a></h3>
<p>The most common response type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 200 OK with JSON
Response::ok(json!({"status": "success"}))

// 201 Created
Response::created(json!({"id": "123"}))

// Custom status with JSON
Response::json(418, json!({"error": "I'm a teapot"}))
<span class="boring">}</span></code></pre></pre>
<h3 id="error-responses"><a class="header" href="#error-responses">Error Responses</a></h3>
<p>Built-in error response helpers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::bad_request("Invalid input")      // 400
Response::not_found()                        // 404
Response::internal_error("Something broke")  // 500
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-headers"><a class="header" href="#custom-headers">Custom Headers</a></h3>
<p>Add headers to any response:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(json!({"data": "value"}))
    .with_header("X-Custom-Header", "custom-value")
    .with_header("Cache-Control", "max-age=3600")
<span class="boring">}</span></code></pre></pre>
<h3 id="text-responses"><a class="header" href="#text-responses">Text Responses</a></h3>
<p>For non-JSON responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::text(200, "Hello, World!")
Response::text(200, "&lt;html&gt;&lt;body&gt;Hello&lt;/body&gt;&lt;/html&gt;")
    .with_header("Content-Type", "text/html")
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="getting-started/./lifecycle.html">Handler Lifecycle</a> - Compilation and process management</li>
<li><a href="getting-started/../sdk/errors.html">Error Handling</a> - Structured error handling</li>
<li><a href="getting-started/../examples/hello-world.html">Examples</a> - More code examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler-lifecycle"><a class="header" href="#handler-lifecycle">Handler Lifecycle</a></h1>
<p>Understanding how handlers are compiled, started, and managed helps you write more reliable code.</p>
<h2 id="endpoint-states"><a class="header" href="#endpoint-states">Endpoint States</a></h2>
<p>An endpoint can be in one of these states:</p>
<div class="table-wrapper"><table><thead><tr><th>State</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Created</strong></td><td>Endpoint defined but code not yet compiled</td></tr>
<tr><td><strong>Compiled</strong></td><td>Code compiled successfully, ready to start</td></tr>
<tr><td><strong>Running</strong></td><td>Worker process is active and handling requests</td></tr>
<tr><td><strong>Stopped</strong></td><td>Worker process stopped, can be restarted</td></tr>
<tr><td><strong>Error</strong></td><td>Compilation or runtime error occurred</td></tr>
</tbody></table>
</div>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>When you click "Compile", the gateway:</p>
<ol>
<li><strong>Creates a Cargo project</strong> in the handlers directory</li>
<li><strong>Writes your code</strong> to <code>src/main.rs</code></li>
<li><strong>Generates Cargo.toml</strong> with the SDK dependency</li>
<li><strong>Runs <code>cargo build --release</code></strong> to compile</li>
<li><strong>Stores the binary</strong> for execution</li>
</ol>
<h3 id="generated-project-structure"><a class="header" href="#generated-project-structure">Generated Project Structure</a></h3>
<pre><code>handlers/
â””â”€â”€ {endpoint-id}/
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ Cargo.lock
    â”œâ”€â”€ src/
    â”‚   â””â”€â”€ main.rs    # Your handler code
    â””â”€â”€ target/
        â””â”€â”€ release/
            â””â”€â”€ handler  # Compiled binary
</code></pre>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<p>The generated Cargo.toml includes the SDK:</p>
<pre><code class="language-toml">[package]
name = "handler"
version = "0.1.0"
edition = "2021"

[dependencies]
rust-edge-gateway-sdk = { path = "../../crates/rust-edge-gateway-sdk" }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
</code></pre>
<p>You can request additional dependencies by using them in your code - the gateway will detect common crates like <code>chrono</code>, <code>uuid</code>, <code>regex</code>, etc.</p>
<h2 id="worker-processes"><a class="header" href="#worker-processes">Worker Processes</a></h2>
<h3 id="starting-a-handler"><a class="header" href="#starting-a-handler">Starting a Handler</a></h3>
<p>When you start an endpoint:</p>
<ol>
<li>Gateway spawns the compiled binary as a child process</li>
<li>IPC channels are established (stdin/stdout)</li>
<li>Worker enters its request loop</li>
<li>Status changes to "Running"</li>
</ol>
<h3 id="request-flow"><a class="header" href="#request-flow">Request Flow</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Gateway â”‚â”€â”€â”€â”€â–¶â”‚  stdin   â”‚â”€â”€â”€â”€â–¶â”‚ Worker â”‚
â”‚         â”‚     â”‚ (request)â”‚     â”‚        â”‚
â”‚         â”‚â—€â”€â”€â”€â”€â”‚  stdout  â”‚â—€â”€â”€â”€â”€â”‚        â”‚
â”‚         â”‚     â”‚(response)â”‚     â”‚        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>The IPC protocol uses length-prefixed JSON:</p>
<ul>
<li>4 bytes: message length (big-endian u32)</li>
<li>N bytes: JSON payload</li>
</ul>
<h3 id="worker-loop"><a class="header" href="#worker-loop">Worker Loop</a></h3>
<p>Your handler runs in a loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    // 1. Read request from stdin
    let request = read_request()?;
    
    // 2. Call your handler function
    let response = handle(request);
    
    // 3. Write response to stdout
    send_response(response)?;
}
<span class="boring">}</span></code></pre></pre>
<p>The loop exits when:</p>
<ul>
<li>stdin is closed (gateway stopped the worker)</li>
<li>An IPC error occurs</li>
<li>The process is killed</li>
</ul>
<h3 id="stopping-a-handler"><a class="header" href="#stopping-a-handler">Stopping a Handler</a></h3>
<p>When you stop an endpoint:</p>
<ol>
<li>Gateway closes the stdin pipe</li>
<li>Worker's read_request() returns an error</li>
<li>Worker exits cleanly</li>
<li>Gateway waits for process exit</li>
<li>Status changes to "Stopped"</li>
</ol>
<h2 id="hot-reload"><a class="header" href="#hot-reload">Hot Reload</a></h2>
<p>Rust Edge Gateway supports hot reloading:</p>
<ol>
<li><strong>Edit code</strong> in the admin UI</li>
<li><strong>Compile</strong> the new version</li>
<li><strong>Restart</strong> the endpoint
<ul>
<li>Old worker finishes current request</li>
<li>New worker starts with updated code</li>
</ul>
</li>
</ol>
<p>No gateway restart required!</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="compilation-errors-1"><a class="header" href="#compilation-errors-1">Compilation Errors</a></h3>
<p>If compilation fails:</p>
<ul>
<li>Error message is captured and displayed</li>
<li>Endpoint stays in previous state</li>
<li>Previous binary (if any) remains available</li>
</ul>
<h3 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h3>
<p>If your handler panics:</p>
<ul>
<li>Gateway detects the worker exit</li>
<li>Error is logged</li>
<li>Worker can be restarted</li>
<li>Endpoint moves to "Error" state</li>
</ul>
<h3 id="graceful-error-handling"><a class="header" href="#graceful-error-handling">Graceful Error Handling</a></h3>
<p>Always handle errors in your code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    match process_request(&amp;req) {
        Ok(data) =&gt; Response::ok(data),
        Err(e) =&gt; e.to_response(), // HandlerError -&gt; Response
    }
}

fn process_request(req: &amp;Request) -&gt; Result&lt;JsonValue, HandlerError&gt; {
    let body: MyInput = req.json()
        .map_err(|e| HandlerError::ValidationError(e.to_string()))?;
    
    // ... process ...
    
    Ok(json!({"result": "success"}))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler-macros"><a class="header" href="#handler-macros">Handler Macros</a></h1>
<p>The SDK provides several macros for running handler loops with different patterns.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Macro</th><th>Handler Signature</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>handler_loop!</code></td><td><code>fn(Request) -&gt; Response</code></td><td>Simple sync handlers</td></tr>
<tr><td><code>handler_loop_result!</code></td><td><code>fn(Request) -&gt; Result&lt;Response, HandlerError&gt;</code></td><td>Sync with error handling</td></tr>
<tr><td><code>handler_loop_async!</code></td><td><code>async fn(Request) -&gt; Response</code></td><td>Async handlers</td></tr>
<tr><td><code>handler_loop_async_result!</code></td><td><code>async fn(Request) -&gt; Result&lt;Response, HandlerError&gt;</code></td><td>Async with error handling</td></tr>
</tbody></table>
</div>
<h2 id="sync-handlers"><a class="header" href="#sync-handlers">Sync Handlers</a></h2>
<h3 id="handler_loop"><a class="header" href="#handler_loop"><code>handler_loop!</code></a></h3>
<p>For simple synchronous handlers that return a <code>Response</code> directly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    Response::ok(json!({"path": req.path, "method": req.method}))
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="handler_loop_result"><a class="header" href="#handler_loop_result"><code>handler_loop_result!</code></a></h3>
<p>For handlers that return <code>Result&lt;Response, HandlerError&gt;</code>. Errors are automatically converted to HTTP responses.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[derive(Deserialize)]
struct CreateItem {
    name: String,
    price: f64,
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // These all use ? operator - errors become HTTP responses
    let auth = req.require_header("Authorization")?;
    let item: CreateItem = req.json()?;
    let id: i64 = req.require_path_param("id")?;
    
    if item.price &lt; 0.0 {
        return Err(HandlerError::ValidationError("Price cannot be negative".into()));
    }
    
    Ok(Response::created(json!({"id": id, "item": item.name})))
}

handler_loop_result!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="async-handlers"><a class="header" href="#async-handlers">Async Handlers</a></h2>
<p>Async handlers require the <code>async</code> feature to be enabled.</p>
<h3 id="cargotoml-1"><a class="header" href="#cargotoml-1">Cargo.toml</a></h3>
<pre><code class="language-toml">[dependencies]
rust-edge-gateway-sdk = { git = "https://github.com/user/rust-edge-gateway", features = ["async"] }
tokio = { version = "1", features = ["full"] }
</code></pre>
<h3 id="handler_loop_async"><a class="header" href="#handler_loop_async"><code>handler_loop_async!</code></a></h3>
<p>For async handlers that return a <code>Response</code> directly. A Tokio runtime is created automatically.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

async fn handle(req: Request) -&gt; Response {
    let data = fetch_from_api().await;
    Response::ok(data)
}

handler_loop_async!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="handler_loop_async_result"><a class="header" href="#handler_loop_async_result"><code>handler_loop_async_result!</code></a></h3>
<p>For async handlers with Result-based error handling. Combines async support with automatic error conversion.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

async fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let data: CreateItem = req.json()?;
    
    // Async database call
    let id = database.insert(&amp;data).await
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;
    
    // Async file upload
    let url = s3.upload(&amp;data.file).await
        .map_err(|e| HandlerError::StorageError(e.to_string()))?;
    
    Ok(Response::created(json!({
        "id": id,
        "file_url": url
    })))
}

handler_loop_async_result!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="runtime-management"><a class="header" href="#runtime-management">Runtime Management</a></h2>
<p><strong>Important:</strong> The async macros create a single Tokio runtime that persists across all requests. This is more efficient than creating a runtime per request.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DON'T do this - creates runtime per request (inefficient):
fn handle(req: Request) -&gt; Response {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        // async work
    })
}

// DO this - runtime is created once by the macro:
async fn handle(req: Request) -&gt; Response {
    // async work directly
}
handler_loop_async!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="choosing-the-right-macro"><a class="header" href="#choosing-the-right-macro">Choosing the Right Macro</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Your handler needs...</th><th>Use this macro</th></tr></thead><tbody>
<tr><td>Simple sync logic</td><td><code>handler_loop!</code></td></tr>
<tr><td>Sync with <code>?</code> operator</td><td><code>handler_loop_result!</code></td></tr>
<tr><td>Async operations (DB, HTTP, files)</td><td><code>handler_loop_async!</code></td></tr>
<tr><td>Async with <code>?</code> operator</td><td><code>handler_loop_async_result!</code></td></tr>
</tbody></table>
</div>
<h2 id="example-complete-crud-handler"><a class="header" href="#example-complete-crud-handler">Example: Complete CRUD Handler</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

async fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    match (req.method.as_str(), req.path.as_str()) {
        ("GET", "/items") =&gt; list_items().await,
        ("POST", "/items") =&gt; create_item(&amp;req).await,
        ("GET", _) if req.path.starts_with("/items/") =&gt; get_item(&amp;req).await,
        ("DELETE", _) if req.path.starts_with("/items/") =&gt; delete_item(&amp;req).await,
        _ =&gt; Err(HandlerError::MethodNotAllowed("Use GET, POST, or DELETE".into())),
    }
}

async fn list_items() -&gt; Result&lt;Response, HandlerError&gt; {
    let items = db::get_all_items().await
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;
    Ok(Response::ok(json!({"items": items})))
}

async fn create_item(req: &amp;Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let item: NewItem = req.json()?;
    let id = db::insert_item(&amp;item).await
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;
    Ok(Response::created(json!({"id": id})))
}

handler_loop_async_result!(handle);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request"><a class="header" href="#request">Request</a></h1>
<p>The <code>Request</code> struct represents an incoming HTTP request.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Request {
    pub method: String,
    pub path: String,
    pub query: HashMap&lt;String, String&gt;,
    pub headers: HashMap&lt;String, String&gt;,
    pub body: Option&lt;String&gt;,
    pub params: HashMap&lt;String, String&gt;,
    pub client_ip: Option&lt;String&gt;,
    pub request_id: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>method</code></td><td><code>String</code></td><td>HTTP method: GET, POST, PUT, DELETE, PATCH, etc.</td></tr>
<tr><td><code>path</code></td><td><code>String</code></td><td>Request path, e.g., <code>/users/123</code></td></tr>
<tr><td><code>query</code></td><td><code>HashMap&lt;String, String&gt;</code></td><td>Query parameters from the URL</td></tr>
<tr><td><code>headers</code></td><td><code>HashMap&lt;String, String&gt;</code></td><td>HTTP headers</td></tr>
<tr><td><code>body</code></td><td><code>Option&lt;String&gt;</code></td><td>Request body (for POST, PUT, PATCH)</td></tr>
<tr><td><code>params</code></td><td><code>HashMap&lt;String, String&gt;</code></td><td>Path parameters extracted from the route</td></tr>
<tr><td><code>client_ip</code></td><td><code>Option&lt;String&gt;</code></td><td>Client's IP address</td></tr>
<tr><td><code>request_id</code></td><td><code>String</code></td><td>Unique identifier for request tracing</td></tr>
</tbody></table>
</div>
<h2 id="methods-reference"><a class="header" href="#methods-reference">Methods Reference</a></h2>
<h3 id="json-parsing"><a class="header" href="#json-parsing">JSON Parsing</a></h3>
<h4 id="jsont---resultt-handlererror"><a class="header" href="#jsont---resultt-handlererror"><code>json&lt;T&gt;() -&gt; Result&lt;T, HandlerError&gt;</code></a></h4>
<p>Parse the body as JSON into a typed struct. Returns <code>HandlerError::BadRequest</code> on parse failure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let user: CreateUser = req.json()?;  // Uses ? operator naturally
    Ok(Response::ok(json!({"name": user.name})))
}

handler_loop_result!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="query-parameters-1"><a class="header" href="#query-parameters-1">Query Parameters</a></h3>
<h4 id="query_paramkey-str---optionstring"><a class="header" href="#query_paramkey-str---optionstring"><code>query_param(key: &amp;str) -&gt; Option&lt;&amp;String&gt;</code></a></h4>
<p>Get a query parameter as a string reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// URL: /search?q=rust
let query = req.query_param("q"); // Some(&amp;"rust".to_string())
<span class="boring">}</span></code></pre></pre>
<h4 id="query_param_ast-fromstrkey-str---optiont"><a class="header" href="#query_param_ast-fromstrkey-str---optiont"><code>query_param_as&lt;T: FromStr&gt;(key: &amp;str) -&gt; Option&lt;T&gt;</code></a></h4>
<p>Get a query parameter parsed as a specific type. Returns <code>None</code> if missing or can't be parsed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// URL: /items?page=2&amp;limit=10
let page: i64 = req.query_param_as("page").unwrap_or(1);
let limit: usize = req.query_param_as("limit").unwrap_or(20);
let active: bool = req.query_param_as("active").unwrap_or(false);
<span class="boring">}</span></code></pre></pre>
<h4 id="require_query_paramt-fromstrkey-str---resultt-handlererror"><a class="header" href="#require_query_paramt-fromstrkey-str---resultt-handlererror"><code>require_query_param&lt;T: FromStr&gt;(key: &amp;str) -&gt; Result&lt;T, HandlerError&gt;</code></a></h4>
<p>Get a required query parameter. Returns <code>HandlerError::BadRequest</code> if missing or invalid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let page: i64 = req.require_query_param("page")?;
    let limit: usize = req.require_query_param("limit")?;
    Ok(Response::ok(json!({"page": page, "limit": limit})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="path-parameters-1"><a class="header" href="#path-parameters-1">Path Parameters</a></h3>
<h4 id="path_paramkey-str---optionstring"><a class="header" href="#path_paramkey-str---optionstring"><code>path_param(key: &amp;str) -&gt; Option&lt;&amp;String&gt;</code></a></h4>
<p>Get a path parameter extracted from the route pattern.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Endpoint path: /users/{id}/posts/{post_id}
// Request: /users/123/posts/456

let user_id = req.path_param("id");       // Some(&amp;"123".to_string())
let post_id = req.path_param("post_id");  // Some(&amp;"456".to_string())
<span class="boring">}</span></code></pre></pre>
<h4 id="path_param_ast-fromstrkey-str---optiont"><a class="header" href="#path_param_ast-fromstrkey-str---optiont"><code>path_param_as&lt;T: FromStr&gt;(key: &amp;str) -&gt; Option&lt;T&gt;</code></a></h4>
<p>Get a path parameter parsed as a specific type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Route: /users/{id}
let user_id: i64 = req.path_param_as("id").unwrap_or(0);
let uuid: Uuid = req.path_param_as("id").ok_or(HandlerError::BadRequest("Invalid UUID".into()))?;
<span class="boring">}</span></code></pre></pre>
<h4 id="require_path_paramt-fromstrkey-str---resultt-handlererror"><a class="header" href="#require_path_paramt-fromstrkey-str---resultt-handlererror"><code>require_path_param&lt;T: FromStr&gt;(key: &amp;str) -&gt; Result&lt;T, HandlerError&gt;</code></a></h4>
<p>Get a required path parameter. Returns <code>HandlerError::BadRequest</code> if missing or invalid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let user_id: i64 = req.require_path_param("id")?;
    Ok(Response::ok(json!({"user_id": user_id})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="headers-1"><a class="header" href="#headers-1">Headers</a></h3>
<h4 id="headerkey-str---optionstring"><a class="header" href="#headerkey-str---optionstring"><code>header(key: &amp;str) -&gt; Option&lt;&amp;String&gt;</code></a></h4>
<p>Get a header value (case-insensitive lookup).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All of these work:
let auth = req.header("Authorization");
let auth = req.header("authorization");
let auth = req.header("AUTHORIZATION");
<span class="boring">}</span></code></pre></pre>
<h4 id="require_headerkey-str---resultstring-handlererror"><a class="header" href="#require_headerkey-str---resultstring-handlererror"><code>require_header(key: &amp;str) -&gt; Result&lt;&amp;String, HandlerError&gt;</code></a></h4>
<p>Get a required header. Returns <code>HandlerError::BadRequest</code> if missing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let auth = req.require_header("Authorization")?;
    let api_key = req.require_header("X-API-Key")?;
    Ok(Response::ok(json!({"authenticated": true})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="request-inspection"><a class="header" href="#request-inspection">Request Inspection</a></h3>
<h4 id="is_methodmethod-str---bool"><a class="header" href="#is_methodmethod-str---bool"><code>is_method(method: &amp;str) -&gt; bool</code></a></h4>
<p>Check if the request method matches (case-insensitive).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if req.is_method("POST") {
    // Handle POST
}
<span class="boring">}</span></code></pre></pre>
<h4 id="content_type---optionstring"><a class="header" href="#content_type---optionstring"><code>content_type() -&gt; Option&lt;&amp;String&gt;</code></a></h4>
<p>Get the Content-Type header value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(ct) = req.content_type() {
    eprintln!("Content-Type: {}", ct);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="is_json---bool"><a class="header" href="#is_json---bool"><code>is_json() -&gt; bool</code></a></h4>
<p>Check if the request has a JSON content type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if req.is_json() {
    let data: MyStruct = req.json()?;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="is_multipart---bool"><a class="header" href="#is_multipart---bool"><code>is_multipart() -&gt; bool</code></a></h4>
<p>Check if the request has a multipart/form-data content type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if req.is_multipart() {
    let multipart = req.multipart()?;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="body_bytes---vecu8"><a class="header" href="#body_bytes---vecu8"><code>body_bytes() -&gt; Vec&lt;u8&gt;</code></a></h4>
<p>Get the raw body as bytes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let raw_body = req.body_bytes();
<span class="boring">}</span></code></pre></pre>
<h3 id="multipart-form-data"><a class="header" href="#multipart-form-data">Multipart Form Data</a></h3>
<h4 id="multipart---resultmultipartdata-handlererror"><a class="header" href="#multipart---resultmultipartdata-handlererror"><code>multipart() -&gt; Result&lt;MultipartData, HandlerError&gt;</code></a></h4>
<p>Parse multipart/form-data body for file uploads.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let multipart = req.multipart()?;

    // Get text fields
    let title = multipart.require_field("title")?;
    let description = multipart.field("description").unwrap_or(&amp;"".to_string());

    // Get uploaded file
    let file = multipart.require_file("upload")?;
    eprintln!("Received file: {} ({} bytes)", file.filename, file.data.len());

    Ok(Response::ok(json!({
        "title": title,
        "filename": file.filename,
        "size": file.data.len()
    })))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multipartdata"><a class="header" href="#multipartdata">MultipartData</a></h2>
<h3 id="fields-1"><a class="header" href="#fields-1">Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>fields</code></td><td><code>HashMap&lt;String, String&gt;</code></td><td>Text form fields</td></tr>
<tr><td><code>files</code></td><td><code>HashMap&lt;String, MultipartFile&gt;</code></td><td>Uploaded files</td></tr>
</tbody></table>
</div>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>field(name)</code></td><td><code>Option&lt;&amp;String&gt;</code></td><td>Get a text field</td></tr>
<tr><td><code>require_field(name)</code></td><td><code>Result&lt;&amp;String, HandlerError&gt;</code></td><td>Get required text field</td></tr>
<tr><td><code>file(name)</code></td><td><code>Option&lt;&amp;MultipartFile&gt;</code></td><td>Get an uploaded file</td></tr>
<tr><td><code>require_file(name)</code></td><td><code>Result&lt;&amp;MultipartFile, HandlerError&gt;</code></td><td>Get required file</td></tr>
</tbody></table>
</div>
<h2 id="multipartfile"><a class="header" href="#multipartfile">MultipartFile</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MultipartFile {
    pub filename: String,      // Original filename
    pub content_type: String,  // MIME type
    pub data: Vec&lt;u8&gt;,         // File content
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[derive(Deserialize)]
struct UpdateProfile {
    name: Option&lt;String&gt;,
    bio: Option&lt;String&gt;,
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // Log request info
    eprintln!("[{}] {} {} from {:?}",
        req.request_id, req.method, req.path, req.client_ip);

    // Check authentication
    let token = req.require_header("Authorization")?;

    // Get path parameter (typed)
    let user_id: i64 = req.require_path_param("id")?;

    // Parse body
    let update: UpdateProfile = req.json()?;

    // Process request...
    Ok(Response::ok(json!({
        "user_id": user_id,
        "updated": true,
    })))
}

handler_loop_result!(handle);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="response"><a class="header" href="#response">Response</a></h1>
<p>The <code>Response</code> struct represents an outgoing HTTP response.</p>
<h2 id="quick-reference-1"><a class="header" href="#quick-reference-1">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Status</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>ok(body)</code></td><td>200</td><td>Successful GET/PUT</td></tr>
<tr><td><code>created(body)</code></td><td>201</td><td>Successful POST</td></tr>
<tr><td><code>accepted(body)</code></td><td>202</td><td>Async operation started</td></tr>
<tr><td><code>no_content()</code></td><td>204</td><td>Successful DELETE</td></tr>
<tr><td><code>bad_request(msg)</code></td><td>400</td><td>Invalid input</td></tr>
<tr><td><code>unauthorized(msg)</code></td><td>401</td><td>Missing/invalid auth</td></tr>
<tr><td><code>forbidden(msg)</code></td><td>403</td><td>Not authorized</td></tr>
<tr><td><code>not_found()</code></td><td>404</td><td>Resource not found</td></tr>
<tr><td><code>conflict(msg)</code></td><td>409</td><td>Resource conflict</td></tr>
<tr><td><code>internal_error(msg)</code></td><td>500</td><td>Server error</td></tr>
<tr><td><code>service_unavailable(msg)</code></td><td>503</td><td>Backend down</td></tr>
</tbody></table>
</div>
<h2 id="definition-1"><a class="header" href="#definition-1">Definition</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Response {
    pub status: u16,
    pub headers: HashMap&lt;String, String&gt;,
    pub body: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="constructor-methods"><a class="header" href="#constructor-methods">Constructor Methods</a></h2>
<h3 id="newstatus-u16"><a class="header" href="#newstatus-u16"><code>new(status: u16)</code></a></h3>
<p>Create a response with just a status code (no body).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::new(204)  // 204 No Content
Response::new(301).with_header("Location", "/new-path")
<span class="boring">}</span></code></pre></pre>
<h3 id="okt-serializebody-t"><a class="header" href="#okt-serializebody-t"><code>ok&lt;T: Serialize&gt;(body: T)</code></a></h3>
<p>Create a 200 OK response with JSON body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(json!({"message": "Success"}))
Response::ok(my_struct)  // If my_struct implements Serialize
<span class="boring">}</span></code></pre></pre>
<h3 id="jsont-serializestatus-u16-body-t"><a class="header" href="#jsont-serializestatus-u16-body-t"><code>json&lt;T: Serialize&gt;(status: u16, body: T)</code></a></h3>
<p>Create a JSON response with a custom status code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::json(201, json!({"id": "new-id"}))
Response::json(400, json!({"error": "Invalid input"}))
<span class="boring">}</span></code></pre></pre>
<h3 id="textstatus-u16-body-impl-intostring"><a class="header" href="#textstatus-u16-body-impl-intostring"><code>text(status: u16, body: impl Into&lt;String&gt;)</code></a></h3>
<p>Create a plain text response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::text(200, "Hello, World!")
Response::text(500, "Internal Server Error")
<span class="boring">}</span></code></pre></pre>
<h3 id="htmlstatus-u16-body-impl-intostring"><a class="header" href="#htmlstatus-u16-body-impl-intostring"><code>html(status: u16, body: impl Into&lt;String&gt;)</code></a></h3>
<p>Create an HTML response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::html(200, "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;")
<span class="boring">}</span></code></pre></pre>
<h3 id="binarystatus-u16-data-impl-asrefu8-content_type-impl-intostring"><a class="header" href="#binarystatus-u16-data-impl-asrefu8-content_type-impl-intostring"><code>binary(status: u16, data: impl AsRef&lt;[u8]&gt;, content_type: impl Into&lt;String&gt;)</code></a></h3>
<p>Create a binary response for files, images, etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Serve an image
Response::binary(200, image_bytes, "image/png")

// Serve a PDF with download prompt
Response::binary(200, pdf_bytes, "application/pdf")
    .with_header("Content-Disposition", "attachment; filename=\"report.pdf\"")

// Inline image
Response::binary(200, jpeg_bytes, "image/jpeg")
    .with_header("Content-Disposition", "inline; filename=\"photo.jpg\"")
<span class="boring">}</span></code></pre></pre>
<h3 id="createdt-serializebody-t"><a class="header" href="#createdt-serializebody-t"><code>created&lt;T: Serialize&gt;(body: T)</code></a></h3>
<p>Create a 201 Created response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::created(json!({"id": "12345", "name": "New Resource"}))
<span class="boring">}</span></code></pre></pre>
<h3 id="acceptedt-serializebody-t"><a class="header" href="#acceptedt-serializebody-t"><code>accepted&lt;T: Serialize&gt;(body: T)</code></a></h3>
<p>Create a 202 Accepted response (for async operations).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::accepted(json!({"job_id": "abc123", "status": "processing"}))
<span class="boring">}</span></code></pre></pre>
<h3 id="no_content"><a class="header" href="#no_content"><code>no_content()</code></a></h3>
<p>Create a 204 No Content response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::no_content()  // Used for DELETE
<span class="boring">}</span></code></pre></pre>
<h3 id="redirectstatus-u16-location-impl-intostring"><a class="header" href="#redirectstatus-u16-location-impl-intostring"><code>redirect(status: u16, location: impl Into&lt;String&gt;)</code></a></h3>
<p>Create a redirect response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::redirect(302, "https://example.com/new-location")
Response::redirect(301, "/permanent-new-path")
<span class="boring">}</span></code></pre></pre>
<h2 id="error-response-helpers"><a class="header" href="#error-response-helpers">Error Response Helpers</a></h2>
<h3 id="bad_requestmessage-impl-intostring"><a class="header" href="#bad_requestmessage-impl-intostring"><code>bad_request(message: impl Into&lt;String&gt;)</code></a></h3>
<p>400 Bad Request.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::bad_request("Missing required field: email")
<span class="boring">}</span></code></pre></pre>
<h3 id="unauthorizedmessage-impl-intostring"><a class="header" href="#unauthorizedmessage-impl-intostring"><code>unauthorized(message: impl Into&lt;String&gt;)</code></a></h3>
<p>401 Unauthorized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::unauthorized("Invalid or expired token")
<span class="boring">}</span></code></pre></pre>
<h3 id="forbiddenmessage-impl-intostring"><a class="header" href="#forbiddenmessage-impl-intostring"><code>forbidden(message: impl Into&lt;String&gt;)</code></a></h3>
<p>403 Forbidden.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::forbidden("You don't have permission to access this resource")
<span class="boring">}</span></code></pre></pre>
<h3 id="not_found--not_found_msgmessage"><a class="header" href="#not_found--not_found_msgmessage"><code>not_found()</code> / <code>not_found_msg(message)</code></a></h3>
<p>404 Not Found.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::not_found()
Response::not_found_msg("User with ID 123 not found")
<span class="boring">}</span></code></pre></pre>
<h3 id="conflictmessage-impl-intostring"><a class="header" href="#conflictmessage-impl-intostring"><code>conflict(message: impl Into&lt;String&gt;)</code></a></h3>
<p>409 Conflict.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::conflict("A user with this email already exists")
<span class="boring">}</span></code></pre></pre>
<h3 id="internal_errormessage-impl-intostring"><a class="header" href="#internal_errormessage-impl-intostring"><code>internal_error(message: impl Into&lt;String&gt;)</code></a></h3>
<p>500 Internal Server Error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::internal_error("Database connection failed")
<span class="boring">}</span></code></pre></pre>
<h3 id="service_unavailablemessage-impl-intostring"><a class="header" href="#service_unavailablemessage-impl-intostring"><code>service_unavailable(message: impl Into&lt;String&gt;)</code></a></h3>
<p>503 Service Unavailable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::service_unavailable("Database is currently unavailable")
<span class="boring">}</span></code></pre></pre>
<h2 id="builder-methods"><a class="header" href="#builder-methods">Builder Methods</a></h2>
<h3 id="with_headerkey-value"><a class="header" href="#with_headerkey-value"><code>with_header(key, value)</code></a></h3>
<p>Add a header to the response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(json!({"data": "value"}))
    .with_header("Cache-Control", "max-age=3600")
    .with_header("X-Custom-Header", "custom-value")
<span class="boring">}</span></code></pre></pre>
<h3 id="with_bodybody-impl-intostring"><a class="header" href="#with_bodybody-impl-intostring"><code>with_body(body: impl Into&lt;String&gt;)</code></a></h3>
<p>Set or replace the response body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::new(200)
    .with_header("Content-Type", "text/html")
    .with_body("&lt;html&gt;&lt;body&gt;Hello!&lt;/body&gt;&lt;/html&gt;")
<span class="boring">}</span></code></pre></pre>
<h3 id="with_corsorigin-impl-intostring"><a class="header" href="#with_corsorigin-impl-intostring"><code>with_cors(origin: impl Into&lt;String&gt;)</code></a></h3>
<p>Add CORS headers for cross-origin requests.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(data).with_cors("*")
Response::ok(data).with_cors("https://myapp.com")
<span class="boring">}</span></code></pre></pre>
<h3 id="with_cachemax_age_seconds-u32"><a class="header" href="#with_cachemax_age_seconds-u32"><code>with_cache(max_age_seconds: u32)</code></a></h3>
<p>Add caching headers.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(data).with_cache(3600)  // Cache for 1 hour
Response::ok(data).with_cache(0)     // No cache
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="restful-api"><a class="header" href="#restful-api">RESTful API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET /items - List items
Response::ok(json!({"items": items}))

// GET /items/{id} - Get single item
Response::ok(item)  // or Response::not_found()

// POST /items - Create item
Response::created(json!({"id": new_id, ...item}))

// PUT /items/{id} - Update item
Response::ok(updated_item)

// DELETE /items/{id} - Delete item
Response::no_content()
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-with-result"><a class="header" href="#error-handling-with-result">Error Handling with Result</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let user = find_user(&amp;req)?;  // Returns 404 if not found
    Ok(Response::ok(user))
}

handler_loop_result!(handle);  // Errors auto-convert to Response
<span class="boring">}</span></code></pre></pre>
<h3 id="file-uploads-response"><a class="header" href="#file-uploads-response">File Uploads Response</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_upload(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let multipart = req.multipart()?;
    let file = multipart.require_file("document")?;

    // Process file...
    let saved_id = save_to_storage(&amp;file.data)?;

    Ok(Response::created(json!({
        "id": saved_id,
        "filename": file.filename,
        "size": file.data.len(),
        "content_type": file.content_type
    })))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="serving-files"><a class="header" href="#serving-files">Serving Files</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serve_image(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let id = req.require_path_param::&lt;String&gt;("id")?;
    let image_data = load_image(&amp;id)?;

    Ok(Response::binary(200, image_data, "image/png")
        .with_cache(86400)  // Cache for 1 day
        .with_header("Content-Disposition", format!("inline; filename=\"{}.png\"", id)))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-content-types"><a class="header" href="#custom-content-types">Custom Content Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// XML
Response::new(200)
    .with_header("Content-Type", "application/xml")
    .with_body("&lt;root&gt;&lt;item&gt;Value&lt;/item&gt;&lt;/root&gt;")

// CSV with download
Response::new(200)
    .with_header("Content-Type", "text/csv")
    .with_header("Content-Disposition", "attachment; filename=\"data.csv\"")
    .with_body("id,name\n1,Alice\n2,Bob")
<span class="boring">}</span></code></pre></pre>
<h3 id="cors-preflight"><a class="header" href="#cors-preflight">CORS Preflight</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    if req.is_method("OPTIONS") {
        return Response::no_content()
            .with_cors("*")
            .with_header("Access-Control-Max-Age", "86400");
    }

    // Handle actual request...
    Response::ok(data).with_cors("*")
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h1>
<p>The SDK provides a <code>HandlerError</code> enum for structured error handling with automatic HTTP status code mapping.</p>
<h2 id="quick-reference-2"><a class="header" href="#quick-reference-2">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Status</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>BadRequest(msg)</code></td><td>400</td><td>Invalid input, malformed JSON</td></tr>
<tr><td><code>ValidationError(msg)</code></td><td>400</td><td>Semantic validation failures</td></tr>
<tr><td><code>Unauthorized(msg)</code></td><td>401</td><td>Missing or invalid auth</td></tr>
<tr><td><code>Forbidden(msg)</code></td><td>403</td><td>Authenticated but not authorized</td></tr>
<tr><td><code>NotFound</code> / <code>NotFoundMessage(msg)</code></td><td>404</td><td>Resource not found</td></tr>
<tr><td><code>MethodNotAllowed(msg)</code></td><td>405</td><td>Wrong HTTP method</td></tr>
<tr><td><code>Conflict(msg)</code></td><td>409</td><td>Resource conflict (duplicate)</td></tr>
<tr><td><code>PayloadTooLarge(msg)</code></td><td>413</td><td>Request body too large</td></tr>
<tr><td><code>Internal(msg)</code> / <code>InternalError(msg)</code></td><td>500</td><td>Server error</td></tr>
<tr><td><code>DatabaseError(msg)</code></td><td>500</td><td>Database operation failed</td></tr>
<tr><td><code>StorageError(msg)</code></td><td>500</td><td>Storage operation failed</td></tr>
<tr><td><code>ServiceUnavailable(msg)</code></td><td>503</td><td>Backend service down</td></tr>
</tbody></table>
</div>
<h2 id="handlererror-definition"><a class="header" href="#handlererror-definition">HandlerError Definition</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum HandlerError {
    // 4xx Client Errors
    BadRequest(String),
    ValidationError(String),
    Unauthorized(String),
    Forbidden(String),
    NotFound,
    NotFoundMessage(String),
    MethodNotAllowed(String),
    Conflict(String),
    PayloadTooLarge(String),

    // 5xx Server Errors
    IpcError(String),
    SerializationError(serde_json::Error),
    DatabaseError(String),
    RedisError(String),
    StorageError(String),
    InternalError(String),
    Internal(String),
    ServiceUnavailable(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="automatic-response-conversion"><a class="header" href="#automatic-response-conversion">Automatic Response Conversion</a></h3>
<p><code>HandlerError</code> implements <code>From&lt;HandlerError&gt; for Response</code>, so you can use <code>.into()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    match process(&amp;req) {
        Ok(data) =&gt; Response::ok(data),
        Err(e) =&gt; e.into(),  // Automatically converts to Response
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="use-with-handler_loop_result"><a class="header" href="#use-with-handler_loop_result">Use with handler_loop_result!</a></h3>
<p>The <code>handler_loop_result!</code> macro automatically converts errors to responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let data: MyInput = req.json()?;  // BadRequest on parse failure
    let id: i64 = req.require_path_param("id")?;  // BadRequest if missing
    let auth = req.require_header("Authorization")?;  // BadRequest if missing

    Ok(Response::ok(json!({"id": id, "data": data})))
}

handler_loop_result!(handle);  // Errors auto-convert to HTTP responses
<span class="boring">}</span></code></pre></pre>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<h3 id="status_code---u16"><a class="header" href="#status_code---u16"><code>status_code() -&gt; u16</code></a></h3>
<p>Get the HTTP status code for this error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err = HandlerError::NotFound;
assert_eq!(err.status_code(), 404);

let err = HandlerError::BadRequest("Invalid input".into());
assert_eq!(err.status_code(), 400);
<span class="boring">}</span></code></pre></pre>
<h3 id="to_response---response"><a class="header" href="#to_response---response"><code>to_response() -&gt; Response</code></a></h3>
<p>Convert the error to an HTTP Response:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err = HandlerError::ValidationError("Invalid email".to_string());
let response = err.to_response();
// Response { status: 400, body: {"error": "Validation error: Invalid email"} }
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<h3 id="clean-result-based-handlers"><a class="header" href="#clean-result-based-handlers">Clean Result-Based Handlers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[derive(Deserialize)]
struct CreateUser {
    email: String,
    name: String,
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // Parse body - returns BadRequest on failure
    let body: CreateUser = req.json()?;

    // Validate
    if body.email.is_empty() {
        return Err(HandlerError::ValidationError("Email is required".into()));
    }

    // Check authentication
    let token = req.require_header("Authorization")?;

    // Get typed path parameter
    let user_id: i64 = req.require_path_param("id")?;

    // Simulate database operation
    let user = find_user(user_id)
        .ok_or(HandlerError::NotFound)?;

    Ok(Response::ok(user))
}

handler_loop_result!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="converting-external-errors"><a class="header" href="#converting-external-errors">Converting External Errors</a></h3>
<p>Map external library errors to <code>HandlerError</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_to_database(data: &amp;MyData) -&gt; Result&lt;i64, HandlerError&gt; {
    let conn = get_connection()
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;

    let id = conn.insert(data)
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;

    Ok(id)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h3>
<p>Define domain-specific errors and convert to <code>HandlerError</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum AppError {
    UserNotFound(String),
    DuplicateEmail,
    InvalidCredentials,
    RateLimited,
}

impl From&lt;AppError&gt; for HandlerError {
    fn from(e: AppError) -&gt; Self {
        match e {
            AppError::UserNotFound(id) =&gt;
                HandlerError::NotFoundMessage(format!("User {} not found", id)),
            AppError::DuplicateEmail =&gt;
                HandlerError::Conflict("Email already registered".into()),
            AppError::InvalidCredentials =&gt;
                HandlerError::Unauthorized("Invalid email or password".into()),
            AppError::RateLimited =&gt;
                HandlerError::ServiceUnavailable("Rate limit exceeded, try again later".into()),
        }
    }
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let result = business_logic(&amp;req)
        .map_err(HandlerError::from)?;  // Convert AppError to HandlerError
    Ok(Response::ok(result))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="async-error-handling"><a class="header" href="#async-error-handling">Async Error Handling</a></h3>
<p>Works the same with async handlers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let data: CreateItem = req.json()?;

    let id = database.insert(&amp;data).await
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;

    let uploaded = s3.put_object(&amp;data.file).await
        .map_err(|e| HandlerError::StorageError(e.to_string()))?;

    Ok(Response::created(json!({
        "id": id,
        "file_url": uploaded.url
    })))
}

handler_loop_async_result!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="logging-errors"><a class="header" href="#logging-errors">Logging Errors</a></h3>
<p>Always log errors for debugging (logs go to stderr, captured by gateway):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    match process(&amp;req) {
        Ok(data) =&gt; Ok(Response::ok(data)),
        Err(e) =&gt; {
            eprintln!("[{}] Error: {} ({})",
                req.request_id,
                e,
                e.status_code()
            );
            Err(e)  // Will be converted to Response by handler_loop_result!
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Use <code>handler_loop_result!</code></strong> - Simplifies error handling with automatic conversion</li>
<li><strong>Use specific error variants</strong> - <code>BadRequest</code> vs <code>ValidationError</code> vs <code>Unauthorized</code></li>
<li><strong>Always log errors</strong> - Use <code>eprintln!</code> for debugging</li>
<li><strong>Convert early</strong> - Map external errors to <code>HandlerError</code> at the boundary</li>
<li><strong>Include context</strong> - Error messages should help debugging</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="services"><a class="header" href="#services">Services</a></h1>
<p>Rust Edge Gateway can connect your handlers to backend services like databases, Redis, and object storage.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Services are configured in the gateway admin UI and made available to handlers. Your handler code uses typed service handles to interact with backends.</p>
<h2 id="available-service-types"><a class="header" href="#available-service-types">Available Service Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Service</th><th>Description</th><th>Use Cases</th></tr></thead><tbody>
<tr><td><strong>SQLite</strong></td><td>Embedded SQL database</td><td>Local data, caching, simple apps</td></tr>
<tr><td><strong>PostgreSQL</strong></td><td>Advanced relational database</td><td>Complex queries, transactions</td></tr>
<tr><td><strong>MySQL</strong></td><td>Popular relational database</td><td>Web applications, compatibility</td></tr>
<tr><td><strong>Redis</strong></td><td>In-memory data store</td><td>Caching, sessions, pub/sub</td></tr>
<tr><td><strong>MongoDB</strong></td><td>Document database</td><td>Flexible schemas, JSON data</td></tr>
<tr><td><strong>MinIO</strong></td><td>S3-compatible object storage</td><td>File uploads, media storage</td></tr>
<tr><td><strong>Memcached</strong></td><td>Distributed caching</td><td>High-speed key-value caching</td></tr>
<tr><td><strong>FTP/SFTP</strong></td><td>File transfer protocols</td><td>File uploads, vendor integrations</td></tr>
<tr><td><strong>Email</strong></td><td>SMTP email sending</td><td>Notifications, alerts, reports</td></tr>
</tbody></table>
</div>
<h2 id="configuring-services"><a class="header" href="#configuring-services">Configuring Services</a></h2>
<h3 id="via-admin-ui"><a class="header" href="#via-admin-ui">Via Admin UI</a></h3>
<ol>
<li>Go to <strong>Services</strong> in the admin panel</li>
<li>Click <strong>Create Service</strong></li>
<li>Select service type and configure connection</li>
<li>Test the connection</li>
<li>Bind to endpoints</li>
</ol>
<h3 id="via-api"><a class="header" href="#via-api">Via API</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:9081/api/services \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Main Database",
    "service_type": "postgres",
    "config": {
      "host": "db.example.com",
      "port": 5432,
      "database": "myapp",
      "username": "app_user",
      "password": "secret"
    }
  }'
</code></pre>
<h2 id="using-services-in-handlers"><a class="header" href="#using-services-in-handlers">Using Services in Handlers</a></h2>
<p>Services are accessed through typed handles in your handler code.</p>
<h3 id="database-example"><a class="header" href="#database-example">Database Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let db = DbPool { pool_id: "main-db".to_string() };
    
    // Query
    let result = db.query(
        "SELECT id, name FROM users WHERE active = ?",
        &amp;["true"]
    );
    
    match result {
        Ok(data) =&gt; Response::ok(json!({"users": data.rows})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="redis-example"><a class="header" href="#redis-example">Redis Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let redis = RedisPool { pool_id: "cache".to_string() };
    
    // Try cache first
    if let Ok(Some(cached)) = redis.get("user:123") {
        return Response::ok(json!({"source": "cache", "data": cached}));
    }
    
    // Cache miss - fetch and store
    let data = fetch_from_db();
    let _ = redis.setex("user:123", &amp;data, 300); // Cache for 5 minutes
    
    Response::ok(json!({"source": "db", "data": data}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="service-handles"><a class="header" href="#service-handles">Service Handles</a></h2>
<h3 id="dbpool"><a class="header" href="#dbpool">DbPool</a></h3>
<p>For SQL databases (PostgreSQL, MySQL, SQLite):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DbPool {
    pub pool_id: String,
}

impl DbPool {
    /// Execute a query, returns rows
    fn query(&amp;self, sql: &amp;str, params: &amp;[&amp;str]) -&gt; Result&lt;DbResult, HandlerError&gt;;
    
    /// Execute a statement (INSERT, UPDATE, DELETE)
    fn execute(&amp;self, sql: &amp;str, params: &amp;[&amp;str]) -&gt; Result&lt;u64, HandlerError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="redispool"><a class="header" href="#redispool">RedisPool</a></h3>
<p>For Redis:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RedisPool {
    pub pool_id: String,
}

impl RedisPool {
    /// Get a value
    fn get(&amp;self, key: &amp;str) -&gt; Result&lt;Option&lt;String&gt;, HandlerError&gt;;
    
    /// Set a value
    fn set(&amp;self, key: &amp;str, value: &amp;str) -&gt; Result&lt;(), HandlerError&gt;;
    
    /// Set with expiration (seconds)
    fn setex(&amp;self, key: &amp;str, value: &amp;str, seconds: u64) -&gt; Result&lt;(), HandlerError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="binding-services-to-endpoints"><a class="header" href="#binding-services-to-endpoints">Binding Services to Endpoints</a></h2>
<p>Services must be bound to endpoints before they can be used:</p>
<ol>
<li>Create the service in the admin UI</li>
<li>Open the endpoint configuration</li>
<li>Add the service binding with a pool ID</li>
<li>The pool ID is used in your handler code</li>
</ol>
<p>This allows the same endpoint code to use different service instances in different environments (dev, staging, prod).</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="sdk/./services/database.html">Database Service Details</a></li>
<li><a href="sdk/./services/redis.html">Redis Service Details</a></li>
<li><a href="sdk/./services/ftp.html">FTP/SFTP Service Details</a></li>
<li><a href="sdk/./services/email.html">Email Service Details</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-abstraction"><a class="header" href="#storage-abstraction">Storage Abstraction</a></h1>
<p>A unified interface for storing data across different backends.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The <code>Storage</code> type provides a single API that works with:</p>
<ul>
<li><strong>Database backends</strong> - SQLite, PostgreSQL, MySQL</li>
<li><strong>Object storage</strong> - MinIO, S3-compatible storage</li>
<li><strong>File storage</strong> - FTP, FTPS, SFTP</li>
</ul>
<p>This allows you to write handler code once and deploy it with different backends.</p>
<h2 id="creating-a-storage-instance"><a class="header" href="#creating-a-storage-instance">Creating a Storage Instance</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

// Database storage (SQLite, PostgreSQL, MySQL)
let db_storage = Storage::database("my-db-pool", "my_table");

// Object storage (MinIO, S3)
let obj_storage = Storage::object_storage("my-minio-pool", "data/items");

// File storage (FTP, SFTP)
let file_storage = Storage::file_storage("my-ftp-pool", "/data/items");
<span class="boring">}</span></code></pre></pre>
<h2 id="storage-operations"><a class="header" href="#storage-operations">Storage Operations</a></h2>
<h3 id="get-by-id"><a class="header" href="#get-by-id">Get by ID</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let storage = Storage::database("pool", "users");

match storage.get("user-123") {
    Ok(Some(user)) =&gt; {
        // user is a JsonValue
        println!("Found: {}", user["name"]);
    }
    Ok(None) =&gt; {
        println!("Not found");
    }
    Err(e) =&gt; {
        eprintln!("Error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="list-records"><a class="header" href="#list-records">List Records</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// List all
let all_items = storage.list(None)?;

// List with filter (interpreted based on backend)
// For databases: WHERE status = ?
// For files: filter by filename pattern
let filtered = storage.list(Some("active"))?;
<span class="boring">}</span></code></pre></pre>
<h3 id="create-record"><a class="header" href="#create-record">Create Record</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = json!({
    "name": "Widget",
    "price": 29.99,
    "in_stock": true
});

storage.create("item-001", &amp;item)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="update-record"><a class="header" href="#update-record">Update Record</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let updated = json!({
    "name": "Widget Pro",
    "price": 39.99,
    "in_stock": true
});

storage.update("item-001", &amp;updated)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="delete-record"><a class="header" href="#delete-record">Delete Record</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match storage.delete("item-001")? {
    true =&gt; println!("Deleted"),
    false =&gt; println!("Not found"),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="backend-behavior"><a class="header" href="#backend-behavior">Backend Behavior</a></h2>
<h3 id="database-sqlite-postgresql-mysql"><a class="header" href="#database-sqlite-postgresql-mysql">Database (SQLite, PostgreSQL, MySQL)</a></h3>
<ul>
<li>Records stored as table rows</li>
<li><code>table_name</code> specifies the table</li>
<li>Filter parameter used in <code>WHERE status = ?</code></li>
<li>Requires table to exist with proper schema</li>
</ul>
<h3 id="object-storage-minio-s3"><a class="header" href="#object-storage-minio-s3">Object Storage (MinIO, S3)</a></h3>
<ul>
<li>Records stored as JSON files</li>
<li>Path: <code>{base_path}/{id}.json</code></li>
<li>Filter parameter passed to listing API</li>
<li>Automatically creates bucket if needed</li>
</ul>
<h3 id="file-storage-ftp-sftp"><a class="header" href="#file-storage-ftp-sftp">File Storage (FTP, SFTP)</a></h3>
<ul>
<li>Records stored as JSON files</li>
<li>Path: <code>{base_path}/{id}.json</code></li>
<li>Filter parameter filters file listing</li>
<li>Directory must exist on server</li>
</ul>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn get_storage() -&gt; Storage {
    // Change this to switch backends:
    // Storage::database("pool", "items")
    // Storage::object_storage("minio", "items")
    Storage::file_storage("ftp", "/data/items")
}

fn handle(req: Request) -&gt; Response {
    let storage = get_storage();
    
    match req.method.as_str() {
        "GET" =&gt; {
            if let Some(id) = req.path_param("id") {
                // Get single item
                match storage.get(id) {
                    Ok(Some(item)) =&gt; Response::ok(item),
                    Ok(None) =&gt; Response::not_found(),
                    Err(e) =&gt; e.to_response(),
                }
            } else {
                // List all items
                match storage.list(req.query_param("status").map(|s| s.as_str())) {
                    Ok(items) =&gt; Response::ok(json!({"items": items})),
                    Err(e) =&gt; e.to_response(),
                }
            }
        }
        "POST" =&gt; {
            let data: JsonValue = req.json().unwrap();
            let id = format!("item-{}", generate_id());
            match storage.create(&amp;id, &amp;data) {
                Ok(()) =&gt; Response::created(json!({"id": id})),
                Err(e) =&gt; e.to_response(),
            }
        }
        _ =&gt; Response::json(405, json!({"error": "Method not allowed"}))
    }
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="sdk/services/../examples/petstore.html">Pet Store Demo</a> - Complete example using Storage</li>
<li><a href="sdk/services/./database.html">Database Services</a> - Direct database access</li>
<li><a href="sdk/services/./ftp.html">FTP Services</a> - FTP/SFTP configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-service"><a class="header" href="#database-service">Database Service</a></h1>
<p>Connect to SQL databases (PostgreSQL, MySQL, SQLite) from your handlers.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h3>
<pre><code class="language-json">{
  "service_type": "postgres",
  "config": {
    "host": "localhost",
    "port": 5432,
    "database": "myapp",
    "username": "app_user",
    "password": "secret",
    "ssl_mode": "prefer",
    "pool_size": 10
  }
}
</code></pre>
<h3 id="mysql"><a class="header" href="#mysql">MySQL</a></h3>
<pre><code class="language-json">{
  "service_type": "mysql",
  "config": {
    "host": "localhost",
    "port": 3306,
    "database": "myapp",
    "username": "app_user",
    "password": "secret",
    "use_ssl": false,
    "pool_size": 10
  }
}
</code></pre>
<h3 id="sqlite"><a class="header" href="#sqlite">SQLite</a></h3>
<pre><code class="language-json">{
  "service_type": "sqlite",
  "config": {
    "path": "/data/app.db",
    "create_if_missing": true
  }
}
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="basic-query"><a class="header" href="#basic-query">Basic Query</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let db = DbPool { pool_id: "main".to_string() };
    
    let result = db.query("SELECT * FROM users WHERE active = ?", &amp;["true"]);
    
    match result {
        Ok(data) =&gt; Response::ok(json!({"users": data.rows})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="query-with-parameters"><a class="header" href="#query-with-parameters">Query with Parameters</a></h3>
<p>Always use parameterized queries to prevent SQL injection:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD - parameterized
db.query("SELECT * FROM users WHERE id = ?", &amp;[&amp;user_id])

// BAD - string concatenation (SQL injection risk!)
// db.query(&amp;format!("SELECT * FROM users WHERE id = {}", user_id), &amp;[])
<span class="boring">}</span></code></pre></pre>
<h3 id="insert-update-delete"><a class="header" href="#insert-update-delete">Insert, Update, Delete</a></h3>
<p>Use <code>execute</code> for statements that modify data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_user(db: &amp;DbPool, name: &amp;str, email: &amp;str) -&gt; Result&lt;u64, HandlerError&gt; {
    db.execute(
        "INSERT INTO users (name, email) VALUES (?, ?)",
        &amp;[name, email]
    )
}

fn update_user(db: &amp;DbPool, id: &amp;str, name: &amp;str) -&gt; Result&lt;u64, HandlerError&gt; {
    db.execute(
        "UPDATE users SET name = ? WHERE id = ?",
        &amp;[name, id]
    )
}

fn delete_user(db: &amp;DbPool, id: &amp;str) -&gt; Result&lt;u64, HandlerError&gt; {
    db.execute("DELETE FROM users WHERE id = ?", &amp;[id])
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-results"><a class="header" href="#working-with-results">Working with Results</a></h3>
<p>The <code>DbResult</code> contains rows as JSON objects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = db.query("SELECT id, name, email FROM users", &amp;[])?;

// result.rows is Vec&lt;HashMap&lt;String, Value&gt;&gt;
for row in &amp;result.rows {
    let id = row.get("id");
    let name = row.get("name");
    println!("User: {:?} - {:?}", id, name);
}

// Or serialize the whole result
Response::ok(json!({
    "users": result.rows,
    "count": result.rows.len(),
}))
<span class="boring">}</span></code></pre></pre>
<h3 id="typed-results"><a class="header" href="#typed-results">Typed Results</a></h3>
<p>Parse rows into your own structs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct User {
    id: i64,
    name: String,
    email: String,
}

fn get_user(db: &amp;DbPool, id: &amp;str) -&gt; Result&lt;Option&lt;User&gt;, HandlerError&gt; {
    let result = db.query("SELECT * FROM users WHERE id = ?", &amp;[id])?;
    
    if let Some(row) = result.rows.first() {
        let user: User = serde_json::from_value(row.clone().into())
            .map_err(|e| HandlerError::Internal(e.to_string()))?;
        Ok(Some(user))
    } else {
        Ok(None)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let db = DbPool { pool_id: "main".to_string() };
    
    let result = db.query("SELECT * FROM users", &amp;[]);
    
    match result {
        Ok(data) =&gt; Response::ok(json!({"users": data.rows})),
        Err(HandlerError::DatabaseError(msg)) =&gt; {
            eprintln!("Database error: {}", msg);
            Response::internal_error("Database temporarily unavailable")
        }
        Err(HandlerError::ServiceUnavailable(msg)) =&gt; {
            Response::json(503, json!({"error": "Service unavailable", "retry_after": 5}))
        }
        Err(e) =&gt; e.to_response(),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Always use parameterized queries</strong> - Never concatenate user input into SQL</li>
<li><strong>Handle connection errors gracefully</strong> - Services may be temporarily unavailable</li>
<li><strong>Use appropriate pool sizes</strong> - Match your concurrency needs</li>
<li><strong>Keep queries simple</strong> - Complex logic is better in your handler code</li>
<li><strong>Log errors</strong> - Use <code>eprintln!</code> for debugging database issues</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis-service"><a class="header" href="#redis-service">Redis Service</a></h1>
<p>Use Redis for caching, sessions, and fast key-value storage.</p>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<pre><code class="language-json">{
  "service_type": "redis",
  "config": {
    "host": "localhost",
    "port": 6379,
    "password": null,
    "database": 0,
    "use_tls": false,
    "pool_size": 10
  }
}
</code></pre>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td>required</td><td>Redis server hostname</td></tr>
<tr><td><code>port</code></td><td>u16</td><td>6379</td><td>Redis server port</td></tr>
<tr><td><code>password</code></td><td>string</td><td>null</td><td>Redis password (optional)</td></tr>
<tr><td><code>database</code></td><td>u8</td><td>0</td><td>Redis database number (0-15)</td></tr>
<tr><td><code>use_tls</code></td><td>bool</td><td>false</td><td>Enable TLS encryption</td></tr>
<tr><td><code>pool_size</code></td><td>u32</td><td>10</td><td>Connection pool size</td></tr>
<tr><td><code>username</code></td><td>string</td><td>null</td><td>Username for Redis 6+ ACL</td></tr>
</tbody></table>
</div>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let redis = RedisPool { pool_id: "cache".to_string() };
    
    // Get a value
    match redis.get("my-key") {
        Ok(Some(value)) =&gt; Response::ok(json!({"value": value})),
        Ok(None) =&gt; Response::not_found(),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="set-values"><a class="header" href="#set-values">Set Values</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set without expiration
redis.set("key", "value")?;

// Set with expiration (seconds)
redis.setex("session:abc123", &amp;session_data, 3600)?; // 1 hour
redis.setex("rate:user:123", "1", 60)?; // 1 minute
<span class="boring">}</span></code></pre></pre>
<h3 id="caching-pattern"><a class="header" href="#caching-pattern">Caching Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let redis = RedisPool { pool_id: "cache".to_string() };
    let db = DbPool { pool_id: "main".to_string() };
    
    let user_id = req.path_param("id").unwrap();
    let cache_key = format!("user:{}", user_id);
    
    // Try cache first
    if let Ok(Some(cached)) = redis.get(&amp;cache_key) {
        return Response::ok(json!({
            "source": "cache",
            "user": serde_json::from_str::&lt;JsonValue&gt;(&amp;cached).unwrap()
        }));
    }
    
    // Cache miss - fetch from database
    let result = db.query("SELECT * FROM users WHERE id = ?", &amp;[user_id])?;
    
    if let Some(user) = result.rows.first() {
        // Cache for 5 minutes
        let user_json = serde_json::to_string(user).unwrap();
        let _ = redis.setex(&amp;cache_key, &amp;user_json, 300);
        
        return Response::ok(json!({
            "source": "database",
            "user": user
        }));
    }
    
    Response::not_found()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="session-management"><a class="header" href="#session-management">Session Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_session(redis: &amp;RedisPool, session_id: &amp;str) -&gt; Result&lt;Option&lt;Session&gt;, HandlerError&gt; {
    let key = format!("session:{}", session_id);
    
    match redis.get(&amp;key)? {
        Some(data) =&gt; {
            let session: Session = serde_json::from_str(&amp;data)
                .map_err(|e| HandlerError::Internal(e.to_string()))?;
            Ok(Some(session))
        }
        None =&gt; Ok(None),
    }
}

fn save_session(redis: &amp;RedisPool, session_id: &amp;str, session: &amp;Session) -&gt; Result&lt;(), HandlerError&gt; {
    let key = format!("session:{}", session_id);
    let data = serde_json::to_string(session)
        .map_err(|e| HandlerError::Internal(e.to_string()))?;
    
    // Sessions expire in 24 hours
    redis.setex(&amp;key, &amp;data, 86400)
}

#[derive(Serialize, Deserialize)]
struct Session {
    user_id: String,
    created_at: String,
    data: JsonValue,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_rate_limit(redis: &amp;RedisPool, client_ip: &amp;str) -&gt; Result&lt;bool, HandlerError&gt; {
    let key = format!("rate:{}", client_ip);
    
    match redis.get(&amp;key)? {
        Some(count) =&gt; {
            let count: u32 = count.parse().unwrap_or(0);
            if count &gt;= 100 {
                return Ok(false); // Rate limited
            }
            // Note: This is a simplified example
            // Real implementation would use INCR command
            redis.setex(&amp;key, &amp;(count + 1).to_string(), 60)?;
            Ok(true)
        }
        None =&gt; {
            redis.setex(&amp;key, "1", 60)?;
            Ok(true)
        }
    }
}

fn handle(req: Request) -&gt; Response {
    let redis = RedisPool { pool_id: "cache".to_string() };
    
    let client_ip = req.client_ip.as_deref().unwrap_or("unknown");
    
    match check_rate_limit(&amp;redis, client_ip) {
        Ok(true) =&gt; {
            // Process request normally
            Response::ok(json!({"status": "ok"}))
        }
        Ok(false) =&gt; {
            Response::json(429, json!({"error": "Too many requests"}))
                .with_header("Retry-After", "60")
        }
        Err(e) =&gt; {
            // If Redis is down, allow the request (fail open)
            eprintln!("Rate limit check failed: {}", e);
            Response::ok(json!({"status": "ok"}))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match redis.get("key") {
    Ok(Some(value)) =&gt; { /* use value */ }
    Ok(None) =&gt; { /* key doesn't exist */ }
    Err(HandlerError::RedisError(msg)) =&gt; {
        eprintln!("Redis error: {}", msg);
        // Fallback behavior
    }
    Err(HandlerError::ServiceUnavailable(_)) =&gt; {
        // Redis is down - decide on fallback
    }
    Err(e) =&gt; { /* other error */ }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Use meaningful key prefixes</strong> - <code>user:123</code>, <code>session:abc</code>, <code>cache:posts:1</code></li>
<li><strong>Always set expiration for cache keys</strong> - Prevents unbounded memory growth</li>
<li><strong>Handle Redis unavailability</strong> - Decide on fail-open vs fail-closed</li>
<li><strong>Don't store large values</strong> - Redis works best with small, fast lookups</li>
<li><strong>Use JSON for structured data</strong> - Easy to serialize/deserialize</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ftpsftp-service"><a class="header" href="#ftpsftp-service">FTP/SFTP Service</a></h1>
<p>Transfer files to and from remote servers using FTP, FTPS, or SFTP.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="ftp-unencrypted"><a class="header" href="#ftp-unencrypted">FTP (Unencrypted)</a></h3>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "ftp.example.com",
    "port": 21,
    "username": "user",
    "password": "secret",
    "protocol": "ftp",
    "base_path": "/uploads",
    "passive_mode": true,
    "timeout_seconds": 30
  }
}
</code></pre>
<h3 id="ftps-ftp-over-tls"><a class="header" href="#ftps-ftp-over-tls">FTPS (FTP over TLS)</a></h3>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "ftp.example.com",
    "port": 21,
    "username": "user",
    "password": "secret",
    "protocol": "ftps",
    "passive_mode": true
  }
}
</code></pre>
<h3 id="sftp-ssh-file-transfer"><a class="header" href="#sftp-ssh-file-transfer">SFTP (SSH File Transfer)</a></h3>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "sftp.example.com",
    "port": 22,
    "username": "user",
    "password": "secret",
    "protocol": "sftp",
    "base_path": "/home/user/uploads"
  }
}
</code></pre>
<p>Or with SSH key authentication:</p>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "sftp.example.com",
    "port": 22,
    "username": "user",
    "private_key_path": "/path/to/id_rsa",
    "protocol": "sftp"
  }
}
</code></pre>
<h2 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td>required</td><td>FTP server hostname</td></tr>
<tr><td><code>port</code></td><td>u16</td><td>21/22</td><td>Server port (21 for FTP/FTPS, 22 for SFTP)</td></tr>
<tr><td><code>username</code></td><td>string</td><td>required</td><td>Login username</td></tr>
<tr><td><code>password</code></td><td>string</td><td>null</td><td>Login password</td></tr>
<tr><td><code>private_key_path</code></td><td>string</td><td>null</td><td>Path to SSH private key (SFTP only)</td></tr>
<tr><td><code>protocol</code></td><td>string</td><td>"ftp"</td><td>Protocol: "ftp", "ftps", or "sftp"</td></tr>
<tr><td><code>base_path</code></td><td>string</td><td>null</td><td>Default directory on server</td></tr>
<tr><td><code>passive_mode</code></td><td>bool</td><td>true</td><td>Use passive mode (FTP/FTPS only)</td></tr>
<tr><td><code>timeout_seconds</code></td><td>u32</td><td>30</td><td>Connection timeout</td></tr>
</tbody></table>
</div>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<h3 id="upload-a-file"><a class="header" href="#upload-a-file">Upload a File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let ftp = FtpPool { pool_id: "uploads".to_string() };
    
    // Upload content
    let content = req.body.as_ref().unwrap();
    let result = ftp.put("/reports/daily.csv", content.as_bytes());
    
    match result {
        Ok(()) =&gt; Response::ok(json!({"uploaded": true})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="download-a-file"><a class="header" href="#download-a-file">Download a File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let ftp = FtpPool { pool_id: "files".to_string() };
    
    let filename = req.path_param("filename").unwrap();
    let path = format!("/data/{}", filename);
    
    match ftp.get(&amp;path) {
        Ok(content) =&gt; Response::new(200)
            .with_header("Content-Type", "application/octet-stream")
            .with_body(content),
        Err(e) =&gt; Response::not_found(),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="list-directory"><a class="header" href="#list-directory">List Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let ftp = FtpPool { pool_id: "files".to_string() };
    
    match ftp.list("/reports") {
        Ok(files) =&gt; Response::ok(json!({"files": files})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<ul>
<li><strong>File uploads</strong> - Accept user uploads and store on FTP server</li>
<li><strong>Report distribution</strong> - Upload generated reports to partner SFTP servers</li>
<li><strong>Data import</strong> - Download files from vendor FTP for processing</li>
<li><strong>Backup</strong> - Archive data to remote storage</li>
<li><strong>Legacy integration</strong> - Connect to systems that only support FTP</li>
</ul>
<h2 id="security-notes"><a class="header" href="#security-notes">Security Notes</a></h2>
<ol>
<li><strong>Prefer SFTP</strong> - Uses SSH encryption, most secure option</li>
<li><strong>Use FTPS if SFTP unavailable</strong> - TLS encryption for FTP</li>
<li><strong>Avoid plain FTP</strong> - Credentials sent in cleartext</li>
<li><strong>Use SSH keys</strong> - More secure than passwords for SFTP</li>
<li><strong>Restrict base_path</strong> - Limit access to specific directories</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="email-smtp-service"><a class="header" href="#email-smtp-service">Email (SMTP) Service</a></h1>
<p>Send emails from your handlers using SMTP.</p>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<h3 id="basic-smtp-with-starttls"><a class="header" href="#basic-smtp-with-starttls">Basic SMTP with STARTTLS</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "smtp.example.com",
    "port": 587,
    "username": "sender@example.com",
    "password": "app-password",
    "encryption": "starttls",
    "from_address": "noreply@example.com",
    "from_name": "My App",
    "reply_to": "support@example.com"
  }
}
</code></pre>
<h3 id="gmail-smtp"><a class="header" href="#gmail-smtp">Gmail SMTP</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "smtp.gmail.com",
    "port": 587,
    "username": "your-email@gmail.com",
    "password": "your-app-password",
    "encryption": "starttls",
    "from_address": "your-email@gmail.com",
    "from_name": "Your Name"
  }
}
</code></pre>
<h3 id="implicit-tls-port-465"><a class="header" href="#implicit-tls-port-465">Implicit TLS (Port 465)</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "smtp.example.com",
    "port": 465,
    "username": "sender@example.com",
    "password": "secret",
    "encryption": "tls",
    "from_address": "noreply@example.com"
  }
}
</code></pre>
<h3 id="local-smtp-no-auth"><a class="header" href="#local-smtp-no-auth">Local SMTP (No Auth)</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "localhost",
    "port": 25,
    "encryption": "none",
    "from_address": "app@localhost"
  }
}
</code></pre>
<h2 id="configuration-options-2"><a class="header" href="#configuration-options-2">Configuration Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td>required</td><td>SMTP server hostname</td></tr>
<tr><td><code>port</code></td><td>u16</td><td>587</td><td>SMTP port</td></tr>
<tr><td><code>username</code></td><td>string</td><td>null</td><td>Auth username (usually email address)</td></tr>
<tr><td><code>password</code></td><td>string</td><td>null</td><td>Auth password or app password</td></tr>
<tr><td><code>encryption</code></td><td>string</td><td>"starttls"</td><td>Encryption: "none", "starttls", or "tls"</td></tr>
<tr><td><code>from_address</code></td><td>string</td><td>required</td><td>Default sender email</td></tr>
<tr><td><code>from_name</code></td><td>string</td><td>null</td><td>Default sender display name</td></tr>
<tr><td><code>reply_to</code></td><td>string</td><td>null</td><td>Default reply-to address</td></tr>
<tr><td><code>timeout_seconds</code></td><td>u32</td><td>30</td><td>Connection timeout</td></tr>
<tr><td><code>max_retries</code></td><td>u32</td><td>3</td><td>Send retry attempts</td></tr>
</tbody></table>
</div>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<h3 id="send-a-simple-email"><a class="header" href="#send-a-simple-email">Send a Simple Email</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let email = EmailPool { pool_id: "notifications".to_string() };
    
    let result = email.send(
        "user@example.com",
        "Welcome!",
        "Thanks for signing up.",
    );
    
    match result {
        Ok(()) =&gt; Response::ok(json!({"sent": true})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="send-html-email"><a class="header" href="#send-html-email">Send HTML Email</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let email = EmailPool { pool_id: "notifications".to_string() };
    
    let html = r#"
        &lt;h1&gt;Welcome!&lt;/h1&gt;
        &lt;p&gt;Thanks for joining us.&lt;/p&gt;
        &lt;a href="https://example.com/verify"&gt;Verify your email&lt;/a&gt;
    "#;
    
    let result = email.send_html(
        "user@example.com",
        "Welcome to Our App",
        html,
    );
    
    match result {
        Ok(()) =&gt; Response::ok(json!({"sent": true})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="send-with-custom-from"><a class="header" href="#send-with-custom-from">Send with Custom From</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = email.send_from(
    "support@example.com",  // From
    "Support Team",         // From name
    "user@example.com",     // To
    "Your Ticket #123",     // Subject
    "We've received your support request...",
);
<span class="boring">}</span></code></pre></pre>
<h2 id="common-providers"><a class="header" href="#common-providers">Common Providers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Provider</th><th>Host</th><th>Port</th><th>Encryption</th></tr></thead><tbody>
<tr><td>Gmail</td><td>smtp.gmail.com</td><td>587</td><td>starttls</td></tr>
<tr><td>Outlook</td><td>smtp.office365.com</td><td>587</td><td>starttls</td></tr>
<tr><td>SendGrid</td><td>smtp.sendgrid.net</td><td>587</td><td>starttls</td></tr>
<tr><td>Mailgun</td><td>smtp.mailgun.org</td><td>587</td><td>starttls</td></tr>
<tr><td>Amazon SES</td><td>email-smtp.{region}.amazonaws.com</td><td>587</td><td>starttls</td></tr>
</tbody></table>
</div>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Use app passwords</strong> - Don't use your main account password</li>
<li><strong>Set up SPF/DKIM</strong> - Improve deliverability</li>
<li><strong>Handle failures</strong> - Emails can fail; log and retry</li>
<li><strong>Rate limit</strong> - Don't spam; respect provider limits</li>
<li><strong>Use templates</strong> - Consistent formatting</li>
<li><strong>Test with sandbox</strong> - Use test mode before production</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>The simplest possible handler.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(_req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello, World!"
    }))
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="endpoint-configuration"><a class="header" href="#endpoint-configuration">Endpoint Configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Value</th></tr></thead><tbody>
<tr><td>Path</td><td><code>/hello</code></td></tr>
<tr><td>Method</td><td><code>GET</code></td></tr>
<tr><td>Domain</td><td><code>*</code></td></tr>
</tbody></table>
</div>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<pre><code class="language-bash">curl http://localhost:9080/hello
</code></pre>
<h2 id="response-1"><a class="header" href="#response-1">Response</a></h2>
<pre><code class="language-json">{
  "message": "Hello, World!"
}
</code></pre>
<h2 id="variations"><a class="header" href="#variations">Variations</a></h2>
<h3 id="with-request-info"><a class="header" href="#with-request-info">With Request Info</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello, World!",
        "method": req.method,
        "path": req.path,
        "request_id": req.request_id,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="plain-text"><a class="header" href="#plain-text">Plain Text</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(_req: Request) -&gt; Response {
    Response::text(200, "Hello, World!")
}
<span class="boring">}</span></code></pre></pre>
<h3 id="html"><a class="header" href="#html">HTML</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(_req: Request) -&gt; Response {
    Response::new(200)
        .with_header("Content-Type", "text/html")
        .with_body("&lt;h1&gt;Hello, World!&lt;/h1&gt;")
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-api"><a class="header" href="#json-api">JSON API</a></h1>
<p>Build a RESTful JSON API endpoint.</p>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[derive(Deserialize)]
struct CreateItem {
    name: String,
    description: Option&lt;String&gt;,
    price: f64,
}

#[derive(Serialize)]
struct Item {
    id: String,
    name: String,
    description: Option&lt;String&gt;,
    price: f64,
    created_at: String,
}

fn handle(req: Request) -&gt; Response {
    // Parse request body
    let input: CreateItem = match req.json() {
        Ok(data) =&gt; data,
        Err(e) =&gt; return Response::bad_request(format!("Invalid JSON: {}", e)),
    };
    
    // Validate
    if input.name.is_empty() {
        return Response::bad_request("Name is required");
    }
    
    if input.price &lt; 0.0 {
        return Response::bad_request("Price must be non-negative");
    }
    
    // Create item (in real app, save to database)
    let item = Item {
        id: uuid::Uuid::new_v4().to_string(),
        name: input.name,
        description: input.description,
        price: input.price,
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    // Return 201 Created
    Response::created(item)
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="endpoint-configuration-1"><a class="header" href="#endpoint-configuration-1">Endpoint Configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Value</th></tr></thead><tbody>
<tr><td>Path</td><td><code>/items</code></td></tr>
<tr><td>Method</td><td><code>POST</code></td></tr>
<tr><td>Domain</td><td><code>*</code></td></tr>
</tbody></table>
</div>
<h2 id="test-1"><a class="header" href="#test-1">Test</a></h2>
<pre><code class="language-bash">curl -X POST http://localhost:9080/items \
  -H "Content-Type: application/json" \
  -d '{"name": "Widget", "description": "A useful widget", "price": 19.99}'
</code></pre>
<h2 id="response-2"><a class="header" href="#response-2">Response</a></h2>
<pre><code class="language-json">{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Widget",
  "description": "A useful widget",
  "price": 19.99,
  "created_at": "2024-01-15T10:30:00.000Z"
}
</code></pre>
<h2 id="full-crud-example"><a class="header" href="#full-crud-example">Full CRUD Example</a></h2>
<p>For a complete CRUD API, create multiple endpoints:</p>
<h3 id="get-items---list-items"><a class="header" href="#get-items---list-items">GET /items - List Items</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(_req: Request) -&gt; Response {
    // In real app, fetch from database
    let items = vec![
        json!({"id": "1", "name": "Item 1"}),
        json!({"id": "2", "name": "Item 2"}),
    ];
    
    Response::ok(json!({
        "items": items,
        "count": items.len(),
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get-itemsid---get-item"><a class="header" href="#get-itemsid---get-item">GET /items/{id} - Get Item</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let id = match req.path_param("id") {
        Some(id) =&gt; id,
        None =&gt; return Response::bad_request("Missing ID"),
    };
    
    // In real app, fetch from database
    if id == "1" {
        Response::ok(json!({
            "id": "1",
            "name": "Item 1",
            "price": 9.99,
        }))
    } else {
        Response::not_found()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="put-itemsid---update-item"><a class="header" href="#put-itemsid---update-item">PUT /items/{id} - Update Item</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct UpdateItem {
    name: Option&lt;String&gt;,
    price: Option&lt;f64&gt;,
}

fn handle(req: Request) -&gt; Response {
    let id = match req.path_param("id") {
        Some(id) =&gt; id.clone(),
        None =&gt; return Response::bad_request("Missing ID"),
    };
    
    let update: UpdateItem = match req.json() {
        Ok(data) =&gt; data,
        Err(e) =&gt; return Response::bad_request(format!("Invalid JSON: {}", e)),
    };
    
    // In real app, update in database
    Response::ok(json!({
        "id": id,
        "name": update.name.unwrap_or("Unchanged".to_string()),
        "updated": true,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="delete-itemsid---delete-item"><a class="header" href="#delete-itemsid---delete-item">DELETE /items/{id} - Delete Item</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let id = match req.path_param("id") {
        Some(id) =&gt; id,
        None =&gt; return Response::bad_request("Missing ID"),
    };
    
    // In real app, delete from database
    eprintln!("Deleted item: {}", id);
    
    Response::no_content()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-parameters-2"><a class="header" href="#path-parameters-2">Path Parameters</a></h1>
<p>Extract dynamic values from URL paths.</p>
<h2 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h2>
<p><strong>Endpoint Path:</strong> <code>/users/{id}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    // Extract the {id} parameter
    let user_id = match req.path_param("id") {
        Some(id) =&gt; id,
        None =&gt; return Response::bad_request("Missing user ID"),
    };
    
    Response::ok(json!({
        "user_id": user_id,
        "message": format!("Fetching user {}", user_id),
    }))
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="test-2"><a class="header" href="#test-2">Test</a></h2>
<pre><code class="language-bash">curl http://localhost:9080/users/123
</code></pre>
<h2 id="response-3"><a class="header" href="#response-3">Response</a></h2>
<pre><code class="language-json">{
  "user_id": "123",
  "message": "Fetching user 123"
}
</code></pre>
<h2 id="multiple-parameters"><a class="header" href="#multiple-parameters">Multiple Parameters</a></h2>
<p><strong>Endpoint Path:</strong> <code>/users/{user_id}/posts/{post_id}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let user_id = req.path_param("user_id");
    let post_id = req.path_param("post_id");
    
    match (user_id, post_id) {
        (Some(uid), Some(pid)) =&gt; {
            Response::ok(json!({
                "user_id": uid,
                "post_id": pid,
            }))
        }
        _ =&gt; Response::bad_request("Missing parameters"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-3"><a class="header" href="#test-3">Test</a></h3>
<pre><code class="language-bash">curl http://localhost:9080/users/42/posts/7
</code></pre>
<h3 id="response-4"><a class="header" href="#response-4">Response</a></h3>
<pre><code class="language-json">{
  "user_id": "42",
  "post_id": "7"
}
</code></pre>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h2>
<p>Path parameters are always strings. Convert them to other types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let id_str = req.path_param("id")
        .ok_or("Missing ID")?;
    
    // Parse to integer
    let id: i64 = match id_str.parse() {
        Ok(n) =&gt; n,
        Err(_) =&gt; return Response::bad_request("ID must be a number"),
    };
    
    // Parse to UUID
    let uuid_str = req.path_param("uuid")
        .ok_or("Missing UUID")?;
    
    let uuid = match uuid::Uuid::parse_str(uuid_str) {
        Ok(u) =&gt; u,
        Err(_) =&gt; return Response::bad_request("Invalid UUID format"),
    };
    
    Response::ok(json!({
        "id": id,
        "uuid": uuid.to_string(),
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="optional-parameters-with-defaults"><a class="header" href="#optional-parameters-with-defaults">Optional Parameters with Defaults</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    // Get page number, default to 1
    let page: u32 = req.path_param("page")
        .and_then(|p| p.parse().ok())
        .unwrap_or(1);
    
    Response::ok(json!({"page": page}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="route-patterns"><a class="header" href="#route-patterns">Route Patterns</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Matches</th><th>Parameters</th></tr></thead><tbody>
<tr><td><code>/users/{id}</code></td><td><code>/users/123</code></td><td><code>id: "123"</code></td></tr>
<tr><td><code>/api/{version}/items</code></td><td><code>/api/v2/items</code></td><td><code>version: "v2"</code></td></tr>
<tr><td><code>/files/{path}</code></td><td><code>/files/docs</code></td><td><code>path: "docs"</code></td></tr>
<tr><td><code>/{org}/{repo}/issues/{num}</code></td><td><code>/acme/proj/issues/42</code></td><td><code>org: "acme"</code>, <code>repo: "proj"</code>, <code>num: "42"</code></td></tr>
</tbody></table>
</div>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="resource-by-id"><a class="header" href="#resource-by-id">Resource by ID</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET /users/{id}
fn get_user(req: Request) -&gt; Response {
    let id = req.path_param("id").unwrap();
    // Fetch user by ID
    Response::ok(json!({"id": id, "name": "John"}))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="nested-resources"><a class="header" href="#nested-resources">Nested Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET /organizations/{org_id}/teams/{team_id}/members
fn get_team_members(req: Request) -&gt; Response {
    let org_id = req.path_param("org_id").unwrap();
    let team_id = req.path_param("team_id").unwrap();
    
    Response::ok(json!({
        "organization": org_id,
        "team": team_id,
        "members": ["alice", "bob"],
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="slug-based-routes"><a class="header" href="#slug-based-routes">Slug-based Routes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET /blog/{slug}
fn get_blog_post(req: Request) -&gt; Response {
    let slug = req.path_param("slug").unwrap();
    
    // Lookup by slug
    Response::ok(json!({
        "slug": slug,
        "title": format!("Post: {}", slug),
    }))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-parameters-2"><a class="header" href="#query-parameters-2">Query Parameters</a></h1>
<p>Access URL query string values.</p>
<h2 id="basic-example-1"><a class="header" href="#basic-example-1">Basic Example</a></h2>
<p><strong>Endpoint Path:</strong> <code>/search</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    // Get query parameter
    let query = req.query_param("q")
        .map(|s| s.to_string())
        .unwrap_or_default();
    
    if query.is_empty() {
        return Response::bad_request("Missing search query");
    }
    
    Response::ok(json!({
        "query": query,
        "results": [],
    }))
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="test-4"><a class="header" href="#test-4">Test</a></h2>
<pre><code class="language-bash">curl "http://localhost:9080/search?q=rust"
</code></pre>
<h2 id="response-5"><a class="header" href="#response-5">Response</a></h2>
<pre><code class="language-json">{
  "query": "rust",
  "results": []
}
</code></pre>
<h2 id="pagination-example"><a class="header" href="#pagination-example">Pagination Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    // Parse pagination parameters with defaults
    let page: u32 = req.query_param("page")
        .and_then(|p| p.parse().ok())
        .unwrap_or(1);
    
    let limit: u32 = req.query_param("limit")
        .and_then(|l| l.parse().ok())
        .unwrap_or(10)
        .min(100);  // Cap at 100
    
    let offset = (page - 1) * limit;
    
    Response::ok(json!({
        "page": page,
        "limit": limit,
        "offset": offset,
        "items": [],
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-5"><a class="header" href="#test-5">Test</a></h3>
<pre><code class="language-bash">curl "http://localhost:9080/items?page=2&amp;limit=20"
</code></pre>
<h3 id="response-6"><a class="header" href="#response-6">Response</a></h3>
<pre><code class="language-json">{
  "page": 2,
  "limit": 20,
  "offset": 20,
  "items": []
}
</code></pre>
<h2 id="filtering-example"><a class="header" href="#filtering-example">Filtering Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    // Get filter parameters
    let status = req.query_param("status");
    let category = req.query_param("category");
    let min_price: Option&lt;f64&gt; = req.query_param("min_price")
        .and_then(|p| p.parse().ok());
    let max_price: Option&lt;f64&gt; = req.query_param("max_price")
        .and_then(|p| p.parse().ok());
    
    Response::ok(json!({
        "filters": {
            "status": status,
            "category": category,
            "price_range": {
                "min": min_price,
                "max": max_price,
            },
        },
        "items": [],
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-6"><a class="header" href="#test-6">Test</a></h3>
<pre><code class="language-bash">curl "http://localhost:9080/products?status=active&amp;category=electronics&amp;min_price=100"
</code></pre>
<h2 id="sorting-example"><a class="header" href="#sorting-example">Sorting Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let sort_by = req.query_param("sort")
        .map(|s| s.to_string())
        .unwrap_or_else(|| "created_at".to_string());
    
    let order = req.query_param("order")
        .map(|s| s.to_string())
        .unwrap_or_else(|| "desc".to_string());
    
    // Validate sort field
    let valid_fields = ["name", "created_at", "price", "popularity"];
    if !valid_fields.contains(&amp;sort_by.as_str()) {
        return Response::bad_request(format!(
            "Invalid sort field. Valid options: {:?}", valid_fields
        ));
    }
    
    Response::ok(json!({
        "sort": {
            "field": sort_by,
            "order": order,
        },
        "items": [],
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="boolean-parameters"><a class="header" href="#boolean-parameters">Boolean Parameters</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    // Parse boolean parameters
    let include_deleted = req.query_param("include_deleted")
        .map(|v| v == "true" || v == "1")
        .unwrap_or(false);
    
    let verbose = req.query_param("verbose")
        .map(|v| v == "true" || v == "1")
        .unwrap_or(false);
    
    Response::ok(json!({
        "include_deleted": include_deleted,
        "verbose": verbose,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="all-query-parameters"><a class="header" href="#all-query-parameters">All Query Parameters</a></h2>
<p>Access all query parameters at once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    // Log all query parameters
    for (key, value) in &amp;req.query {
        eprintln!("Query param: {} = {}", key, value);
    }
    
    Response::ok(json!({
        "query_params": req.query,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="validation-helper"><a class="header" href="#validation-helper">Validation Helper</a></h2>
<p>Create a reusable validation function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_pagination(req: &amp;Request) -&gt; Result&lt;(u32, u32), Response&gt; {
    let page: u32 = req.query_param("page")
        .and_then(|p| p.parse().ok())
        .unwrap_or(1);
    
    if page == 0 {
        return Err(Response::bad_request("Page must be &gt;= 1"));
    }
    
    let limit: u32 = req.query_param("limit")
        .and_then(|l| l.parse().ok())
        .unwrap_or(10);
    
    if limit &gt; 100 {
        return Err(Response::bad_request("Limit must be &lt;= 100"));
    }
    
    Ok((page, limit))
}

fn handle(req: Request) -&gt; Response {
    let (page, limit) = match parse_pagination(&amp;req) {
        Ok(p) =&gt; p,
        Err(response) =&gt; return response,
    };
    
    Response::ok(json!({"page": page, "limit": limit}))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h1>
<p>Robust error handling patterns for handlers.</p>
<h2 id="basic-pattern"><a class="header" href="#basic-pattern">Basic Pattern</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    match process_request(&amp;req) {
        Ok(data) =&gt; Response::ok(data),
        Err(e) =&gt; e.to_response(),
    }
}

fn process_request(req: &amp;Request) -&gt; Result&lt;JsonValue, HandlerError&gt; {
    let input: CreateUser = req.json()
        .map_err(|e| HandlerError::ValidationError(e.to_string()))?;
    
    // Process and return result
    Ok(json!({"id": "123", "name": input.name}))
}

#[derive(Deserialize)]
struct CreateUser {
    name: String,
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="error-types-and-status-codes"><a class="header" href="#error-types-and-status-codes">Error Types and Status Codes</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(req: &amp;Request) -&gt; Result&lt;JsonValue, HandlerError&gt; {
    // 400 Bad Request - Invalid input
    if req.body.is_none() {
        return Err(HandlerError::ValidationError("Body required".into()));
    }
    
    // 401 Unauthorized - Missing/invalid auth
    if req.header("Authorization").is_none() {
        return Err(HandlerError::Unauthorized("Token required".into()));
    }
    
    // 404 Not Found - Resource doesn't exist
    let user = find_user("123");
    if user.is_none() {
        return Err(HandlerError::NotFound("User not found".into()));
    }
    
    // 503 Service Unavailable - Backend down
    if !database_available() {
        return Err(HandlerError::ServiceUnavailable("Database down".into()));
    }
    
    // 500 Internal Error - Unexpected error
    if something_broke() {
        return Err(HandlerError::Internal("Unexpected error".into()));
    }
    
    Ok(json!({"status": "ok"}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct RegisterUser {
    email: String,
    password: String,
    name: String,
}

fn validate_input(input: &amp;RegisterUser) -&gt; Result&lt;(), HandlerError&gt; {
    // Email validation
    if !input.email.contains('@') {
        return Err(HandlerError::ValidationError(
            "Invalid email format".into()
        ));
    }
    
    // Password validation
    if input.password.len() &lt; 8 {
        return Err(HandlerError::ValidationError(
            "Password must be at least 8 characters".into()
        ));
    }
    
    // Name validation
    if input.name.trim().is_empty() {
        return Err(HandlerError::ValidationError(
            "Name is required".into()
        ));
    }
    
    Ok(())
}

fn handle(req: Request) -&gt; Response {
    let input: RegisterUser = match req.json() {
        Ok(i) =&gt; i,
        Err(e) =&gt; return Response::bad_request(format!("Invalid JSON: {}", e)),
    };
    
    if let Err(e) = validate_input(&amp;input) {
        return e.to_response();
    }
    
    Response::created(json!({"email": input.email}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-error-type"><a class="header" href="#custom-error-type">Custom Error Type</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum AppError {
    UserNotFound(String),
    EmailTaken(String),
    InvalidCredentials,
    RateLimited,
    DatabaseError(String),
}

impl From&lt;AppError&gt; for HandlerError {
    fn from(e: AppError) -&gt; Self {
        match e {
            AppError::UserNotFound(id) =&gt; 
                HandlerError::NotFound(format!("User {} not found", id)),
            AppError::EmailTaken(email) =&gt; 
                HandlerError::ValidationError(format!("Email {} already registered", email)),
            AppError::InvalidCredentials =&gt; 
                HandlerError::Unauthorized("Invalid email or password".into()),
            AppError::RateLimited =&gt; 
                HandlerError::Internal("Rate limit exceeded".into()),
            AppError::DatabaseError(msg) =&gt; 
                HandlerError::DatabaseError(msg),
        }
    }
}

fn process(req: &amp;Request) -&gt; Result&lt;JsonValue, AppError&gt; {
    // Business logic with custom errors
    Err(AppError::InvalidCredentials)
}

fn handle(req: Request) -&gt; Response {
    match process(&amp;req) {
        Ok(data) =&gt; Response::ok(data),
        Err(e) =&gt; HandlerError::from(e).to_response(),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="logging-errors-1"><a class="header" href="#logging-errors-1">Logging Errors</a></h2>
<p>Always log errors for debugging:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    match process(&amp;req) {
        Ok(data) =&gt; Response::ok(data),
        Err(e) =&gt; {
            // Log with request ID for tracing
            eprintln!("[{}] Error: {}", req.request_id, e);
            
            // Log stack trace for internal errors
            if matches!(e, HandlerError::Internal(_) | HandlerError::DatabaseError(_)) {
                eprintln!("[{}] Request path: {}", req.request_id, req.path);
                eprintln!("[{}] Request body: {:?}", req.request_id, req.body);
            }
            
            e.to_response()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h2>
<p>Handle service failures gracefully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let redis = RedisPool { pool_id: "cache".to_string() };
    let db = DbPool { pool_id: "main".to_string() };
    
    // Try cache first
    let cached = redis.get("data:key");
    
    match cached {
        Ok(Some(data)) =&gt; {
            return Response::ok(json!({"source": "cache", "data": data}));
        }
        Ok(None) =&gt; { /* Cache miss, continue */ }
        Err(e) =&gt; {
            // Log but don't fail - Redis being down shouldn't break the app
            eprintln!("Redis error (non-fatal): {}", e);
        }
    }
    
    // Fallback to database
    match db.query("SELECT * FROM data", &amp;[]) {
        Ok(result) =&gt; Response::ok(json!({"source": "db", "data": result.rows})),
        Err(e) =&gt; {
            eprintln!("Database error: {}", e);
            Response::json(503, json!({
                "error": "Service temporarily unavailable",
                "retry_after": 5,
            }))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pet-store-demo"><a class="header" href="#pet-store-demo">Pet Store Demo</a></h1>
<p>A complete REST API example demonstrating the same Pet Store API working with multiple storage backends.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The Pet Store demo shows how Rust Edge Gateway's <code>Storage</code> abstraction allows the <strong>same handler code</strong> to work with:</p>
<ul>
<li><strong>SQLite</strong> - Embedded database (no external dependencies)</li>
<li><strong>PostgreSQL</strong> - Full-featured relational database</li>
<li><strong>MySQL</strong> - Popular relational database</li>
<li><strong>MinIO</strong> - Object storage (pets stored as JSON files)</li>
<li><strong>FTP/SFTP</strong> - File transfer (pets stored as JSON files)</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><code class="language-bash">cd examples/petstore

# SQLite (default - no external dependencies)
./setup.sh sqlite

# PostgreSQL
./setup.sh postgres

# MySQL
./setup.sh mysql

# MinIO (object storage)
./setup.sh minio

# FTP/SFTP (file storage)
./setup.sh ftp
</code></pre>
<h2 id="api-endpoints"><a class="header" href="#api-endpoints">API Endpoints</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/pets</code></td><td>List all pets (optional <code>?status=</code> filter)</td></tr>
<tr><td>POST</td><td><code>/pets</code></td><td>Create a new pet</td></tr>
<tr><td>GET</td><td><code>/pets/{petId}</code></td><td>Get a pet by ID</td></tr>
<tr><td>PUT</td><td><code>/pets/{petId}</code></td><td>Update a pet</td></tr>
<tr><td>DELETE</td><td><code>/pets/{petId}</code></td><td>Delete a pet</td></tr>
</tbody></table>
</div>
<h2 id="storage-abstraction-1"><a class="header" href="#storage-abstraction-1">Storage Abstraction</a></h2>
<p>The key to multi-backend support is the <code>Storage</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn get_storage() -&gt; Storage {
    // Choose one:
    Storage::database("petstore", "pets")           // SQLite/PostgreSQL/MySQL
    Storage::object_storage("petstore", "pets")     // MinIO/S3
    Storage::file_storage("petstore", "pets")       // FTP/SFTP
}

fn handle(req: Request) -&gt; Response {
    let storage = get_storage();
    
    match storage.list(None) {
        Ok(pets) =&gt; Response::ok(json!({"pets": pets})),
        Err(e) =&gt; e.to_response(),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="storage-api"><a class="header" href="#storage-api">Storage API</a></h2>
<p>All storage backends implement the same interface:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get a record by ID
storage.get("pet-123") -&gt; Result&lt;Option&lt;JsonValue&gt;, HandlerError&gt;

// List all records (with optional filter)
storage.list(Some("available")) -&gt; Result&lt;Vec&lt;JsonValue&gt;, HandlerError&gt;

// Create a new record
storage.create("pet-123", &amp;pet_json) -&gt; Result&lt;(), HandlerError&gt;

// Update an existing record
storage.update("pet-123", &amp;pet_json) -&gt; Result&lt;(), HandlerError&gt;

// Delete a record
storage.delete("pet-123") -&gt; Result&lt;bool, HandlerError&gt;
<span class="boring">}</span></code></pre></pre>
<h2 id="database-schema"><a class="header" href="#database-schema">Database Schema</a></h2>
<p>For SQL backends, use the provided schema:</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS pets (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    category TEXT,
    tags TEXT,  -- JSON array as string
    status TEXT NOT NULL DEFAULT 'available',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_pets_status ON pets(status);
</code></pre>
<h2 id="file-storage-format"><a class="header" href="#file-storage-format">File Storage Format</a></h2>
<p>For MinIO and FTP backends, pets are stored as individual JSON files:</p>
<pre><code>/pets/
  pet-001.json
  pet-002.json
  pet-003.json
</code></pre>
<p>Each file contains:</p>
<pre><code class="language-json">{
  "id": "pet-001",
  "name": "Buddy",
  "category": "dog",
  "tags": ["friendly", "trained"],
  "status": "available",
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:30:00Z"
}
</code></pre>
<h2 id="handler-code"><a class="header" href="#handler-code">Handler Code</a></h2>
<p>See the handler implementations in <code>examples/petstore/handlers/</code>:</p>
<ul>
<li><code>list_pets.rs</code> - List with optional status filter</li>
<li><code>get_pet.rs</code> - Get by ID</li>
<li><code>create_pet.rs</code> - Create with validation</li>
<li><code>update_pet.rs</code> - Partial update support</li>
<li><code>delete_pet.rs</code> - Delete by ID</li>
</ul>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre><code class="language-bash"># Create a pet
curl -X POST http://petstore.example.com/pets \
  -H "Content-Type: application/json" \
  -d '{"name": "Buddy", "category": "dog", "status": "available"}'

# List all pets
curl http://petstore.example.com/pets

# Filter by status
curl http://petstore.example.com/pets?status=available

# Get a specific pet
curl http://petstore.example.com/pets/pet-001

# Update a pet
curl -X PUT http://petstore.example.com/pets/pet-001 \
  -H "Content-Type: application/json" \
  -d '{"status": "sold"}'

# Delete a pet
curl -X DELETE http://petstore.example.com/pets/pet-001
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="management-api"><a class="header" href="#management-api">Management API</a></h1>
<p>The Rust Edge Gateway provides a REST API for managing endpoints, domains, collections, and services.</p>
<h2 id="base-url"><a class="header" href="#base-url">Base URL</a></h2>
<pre><code>http://localhost:9081/api
</code></pre>
<p>In production, access via your admin domain:</p>
<pre><code>https://rust-edge-gateway.yourdomain.com/api
</code></pre>
<h2 id="response-format"><a class="header" href="#response-format">Response Format</a></h2>
<p>All API responses follow this format:</p>
<pre><code class="language-json">{
  "ok": true,
  "data": { ... }
}
</code></pre>
<p>Or for errors:</p>
<pre><code class="language-json">{
  "ok": false,
  "error": "Error message"
}
</code></pre>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>Currently, the API is open. Future versions will support authentication.</p>
<h2 id="rate-limiting-1"><a class="header" href="#rate-limiting-1">Rate Limiting</a></h2>
<p>No rate limiting is currently applied to the management API.</p>
<h2 id="endpoints-overview"><a class="header" href="#endpoints-overview">Endpoints Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Endpoints</th></tr></thead><tbody>
<tr><td><a href="api/./domains.html">Domains</a></td><td><code>/api/domains/*</code></td></tr>
<tr><td><a href="api/./collections.html">Collections</a></td><td><code>/api/collections/*</code></td></tr>
<tr><td><a href="api/./services.html">Services</a></td><td><code>/api/services/*</code></td></tr>
<tr><td><a href="api/./endpoints.html">Endpoints</a></td><td><code>/api/endpoints/*</code></td></tr>
<tr><td>Import</td><td><code>/api/import/*</code></td></tr>
<tr><td>System</td><td><code>/api/health</code>, <code>/api/stats</code></td></tr>
</tbody></table>
</div>
<h2 id="system-endpoints"><a class="header" href="#system-endpoints">System Endpoints</a></h2>
<h3 id="health-check"><a class="header" href="#health-check">Health Check</a></h3>
<p>Check if the gateway is running.</p>
<pre><code class="language-bash">GET /api/health
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "status": "healthy",
    "version": "0.1.0"
  }
}
</code></pre>
<h3 id="statistics"><a class="header" href="#statistics">Statistics</a></h3>
<p>Get gateway statistics.</p>
<pre><code class="language-bash">GET /api/stats
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "endpoints_total": 10,
    "endpoints_running": 8,
    "requests_handled": 1234,
    "uptime_seconds": 3600
  }
}
</code></pre>
<h2 id="import-endpoints"><a class="header" href="#import-endpoints">Import Endpoints</a></h2>
<h3 id="import-openapi-spec"><a class="header" href="#import-openapi-spec">Import OpenAPI Spec</a></h3>
<p>Create endpoints from an OpenAPI 3.x specification.</p>
<pre><code class="language-bash">POST /api/import/openapi
Content-Type: application/json

{
  "spec": "openapi: 3.0.0\ninfo:\n  title: Pet Store\n...",
  "domain": "api.example.com",
  "domain_id": "uuid-of-domain",
  "create_collection": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spec</code></td><td>string</td><td>Yes</td><td>OpenAPI YAML or JSON content</td></tr>
<tr><td><code>domain</code></td><td>string</td><td>Yes</td><td>Domain to associate endpoints with</td></tr>
<tr><td><code>domain_id</code></td><td>string</td><td>No*</td><td>Domain UUID (*required if create_collection is true)</td></tr>
<tr><td><code>collection_id</code></td><td>string</td><td>No</td><td>Existing collection to add endpoints to</td></tr>
<tr><td><code>create_collection</code></td><td>bool</td><td>No</td><td>Create new collection from spec info</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "collection": {
      "id": "uuid",
      "name": "Pet Store",
      "base_path": "/v1"
    },
    "endpoints_created": 5,
    "endpoints": [
      {"id": "uuid", "name": "getPets", "path": "/pets", "method": "GET"},
      {"id": "uuid", "name": "createPet", "path": "/pets", "method": "POST"}
    ]
  }
}
</code></pre>
<h3 id="import-bundle-zip"><a class="header" href="#import-bundle-zip">Import Bundle (ZIP)</a></h3>
<p>Upload a ZIP file containing an OpenAPI spec and handler code files.</p>
<pre><code class="language-bash">POST /api/import/bundle?domain=api.example.com&amp;create_collection=true&amp;domain_id=uuid&amp;compile=true&amp;start=true
Content-Type: multipart/form-data

# Form field: bundle (or file, zip) = your-bundle.zip
</code></pre>
<p><strong>Query Parameters:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>domain</code></td><td>string</td><td>Yes</td><td>Domain to associate endpoints with</td></tr>
<tr><td><code>domain_id</code></td><td>string</td><td>No*</td><td>Domain UUID (*required if create_collection is true)</td></tr>
<tr><td><code>collection_id</code></td><td>string</td><td>No</td><td>Existing collection to add endpoints to</td></tr>
<tr><td><code>create_collection</code></td><td>bool</td><td>No</td><td>Create new collection from spec info</td></tr>
<tr><td><code>compile</code></td><td>bool</td><td>No</td><td>Compile handlers after import</td></tr>
<tr><td><code>start</code></td><td>bool</td><td>No</td><td>Start handlers after compilation (requires compile=true)</td></tr>
</tbody></table>
</div>
<p><strong>Bundle Structure:</strong></p>
<pre><code>bundle.zip
â”œâ”€â”€ openapi.yaml          # OpenAPI spec (or openapi.json, api.yaml, spec.yaml)
â””â”€â”€ handlers/             # Handler files (can also be at root or in src/)
    â”œâ”€â”€ get_pets.rs       # Matches operationId "getPets" or "get_pets"
    â”œâ”€â”€ create_pet.rs     # Matches operationId "createPet" or "create_pet"
    â””â”€â”€ get_pet_by_id.rs  # Matches operationId "getPetById" or "get_pet_by_id"
</code></pre>
<p>Handler files are matched to OpenAPI operations by normalizing names:</p>
<ul>
<li><code>getPet.rs</code> â†’ matches operationId <code>getPet</code> or <code>get_pet</code></li>
<li><code>list_all_pets.rs</code> â†’ matches operationId <code>listAllPets</code> or <code>list_all_pets</code></li>
</ul>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "collection": {"id": "uuid", "name": "Pet Store"},
    "endpoints_created": 5,
    "endpoints_updated": 0,
    "handlers_matched": 5,
    "compiled": 5,
    "started": 5,
    "endpoints": [...],
    "errors": []
  }
}
</code></pre>
<p><strong>Example with curl:</strong></p>
<pre><code class="language-bash">curl -X POST "http://localhost:8081/api/import/bundle?domain=api.example.com&amp;create_collection=true&amp;domain_id=abc123&amp;compile=true&amp;start=true" \
  -F "bundle=@my-api.zip"
</code></pre>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="list-with-filters"><a class="header" href="#list-with-filters">List with Filters</a></h3>
<p>Most list endpoints support query parameters:</p>
<pre><code class="language-bash">GET /api/endpoints?domain=api.example.com&amp;enabled=true
</code></pre>
<h3 id="pagination"><a class="header" href="#pagination">Pagination</a></h3>
<p>List endpoints will support pagination in future versions:</p>
<pre><code class="language-bash">GET /api/endpoints?page=1&amp;limit=20
</code></pre>
<h3 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h3>
<p>Always check the <code>ok</code> field in responses:</p>
<pre><code class="language-javascript">const response = await fetch('/api/endpoints');
const data = await response.json();

if (data.ok) {
  console.log('Endpoints:', data.data);
} else {
  console.error('Error:', data.error);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domains-api"><a class="header" href="#domains-api">Domains API</a></h1>
<p>Domains represent the top-level organization for your endpoints (e.g., <code>api.example.com</code>).</p>
<h2 id="list-domains"><a class="header" href="#list-domains">List Domains</a></h2>
<pre><code class="language-bash">GET /api/domains
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Production API",
      "host": "api.example.com",
      "description": "Main production API",
      "enabled": true,
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<h2 id="create-domain"><a class="header" href="#create-domain">Create Domain</a></h2>
<pre><code class="language-bash">POST /api/domains
Content-Type: application/json

{
  "name": "Production API",
  "host": "api.example.com",
  "description": "Main production API",
  "enabled": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Display name for the domain</td></tr>
<tr><td><code>host</code></td><td>string</td><td>Yes</td><td>Hostname (e.g., <code>api.example.com</code>)</td></tr>
<tr><td><code>description</code></td><td>string</td><td>No</td><td>Optional description</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>No</td><td>Whether domain is active (default: true)</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Production API",
    "host": "api.example.com",
    "description": "Main production API",
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="get-domain"><a class="header" href="#get-domain">Get Domain</a></h2>
<pre><code class="language-bash">GET /api/domains/{id}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Production API",
    "host": "api.example.com",
    "description": "Main production API",
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="update-domain"><a class="header" href="#update-domain">Update Domain</a></h2>
<pre><code class="language-bash">PUT /api/domains/{id}
Content-Type: application/json

{
  "name": "Updated API Name",
  "description": "Updated description",
  "enabled": false
}
</code></pre>
<p><strong>Request Body:</strong></p>
<p>All fields are optional. Only provided fields will be updated.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Display name</td></tr>
<tr><td><code>host</code></td><td>string</td><td>Hostname</td></tr>
<tr><td><code>description</code></td><td>string</td><td>Description</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>Active status</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Updated API Name",
    "host": "api.example.com",
    "description": "Updated description",
    "enabled": false,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T11:00:00Z"
  }
}
</code></pre>
<h2 id="delete-domain"><a class="header" href="#delete-domain">Delete Domain</a></h2>
<pre><code class="language-bash">DELETE /api/domains/{id}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": null
}
</code></pre>
<p><strong>Note:</strong> Deleting a domain will also delete all associated collections and endpoints.</p>
<h2 id="get-domain-collections"><a class="header" href="#get-domain-collections">Get Domain Collections</a></h2>
<p>List all collections belonging to a domain.</p>
<pre><code class="language-bash">GET /api/domains/{id}/collections
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "collection-uuid",
      "domain_id": "domain-uuid",
      "name": "Pet Store",
      "description": "Pet management endpoints",
      "base_path": "/pets",
      "enabled": true,
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections-api"><a class="header" href="#collections-api">Collections API</a></h1>
<p>Collections group related endpoints within a domain (e.g., "Pet Store", "User Management").</p>
<h2 id="list-collections"><a class="header" href="#list-collections">List Collections</a></h2>
<pre><code class="language-bash">GET /api/collections
</code></pre>
<p><strong>Query Parameters:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>domain_id</code></td><td>string</td><td>Filter by domain UUID</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "domain_id": "domain-uuid",
      "name": "Pet Store",
      "description": "Pet management endpoints",
      "base_path": "/pets",
      "enabled": true,
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<h2 id="create-collection"><a class="header" href="#create-collection">Create Collection</a></h2>
<pre><code class="language-bash">POST /api/collections
Content-Type: application/json

{
  "domain_id": "domain-uuid",
  "name": "Pet Store",
  "description": "Pet management endpoints",
  "base_path": "/pets",
  "enabled": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>domain_id</code></td><td>string</td><td>Yes</td><td>Parent domain UUID</td></tr>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Display name</td></tr>
<tr><td><code>description</code></td><td>string</td><td>No</td><td>Optional description</td></tr>
<tr><td><code>base_path</code></td><td>string</td><td>No</td><td>Common path prefix for endpoints</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>No</td><td>Whether collection is active (default: true)</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "domain_id": "domain-uuid",
    "name": "Pet Store",
    "description": "Pet management endpoints",
    "base_path": "/pets",
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="get-collection"><a class="header" href="#get-collection">Get Collection</a></h2>
<pre><code class="language-bash">GET /api/collections/{id}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "domain_id": "domain-uuid",
    "name": "Pet Store",
    "description": "Pet management endpoints",
    "base_path": "/pets",
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="update-collection"><a class="header" href="#update-collection">Update Collection</a></h2>
<pre><code class="language-bash">PUT /api/collections/{id}
Content-Type: application/json

{
  "name": "Updated Name",
  "description": "Updated description",
  "base_path": "/v2/pets",
  "enabled": false
}
</code></pre>
<p><strong>Request Body:</strong></p>
<p>All fields are optional. Only provided fields will be updated.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Display name</td></tr>
<tr><td><code>description</code></td><td>string</td><td>Description</td></tr>
<tr><td><code>base_path</code></td><td>string</td><td>Path prefix</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>Active status</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "domain_id": "domain-uuid",
    "name": "Updated Name",
    "description": "Updated description",
    "base_path": "/v2/pets",
    "enabled": false,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T11:00:00Z"
  }
}
</code></pre>
<h2 id="delete-collection"><a class="header" href="#delete-collection">Delete Collection</a></h2>
<pre><code class="language-bash">DELETE /api/collections/{id}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": null
}
</code></pre>
<p><strong>Note:</strong> Deleting a collection will also delete all associated endpoints.</p>
<h2 id="get-collection-endpoints"><a class="header" href="#get-collection-endpoints">Get Collection Endpoints</a></h2>
<p>List all endpoints in a collection.</p>
<pre><code class="language-bash">GET /api/collections/{id}/endpoints
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "endpoint-uuid",
      "name": "getPets",
      "path": "/pets",
      "method": "GET",
      "domain": "api.example.com",
      "collection_id": "collection-uuid",
      "description": "List all pets",
      "enabled": true
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="services-api"><a class="header" href="#services-api">Services API</a></h1>
<p>Services represent backend connections (databases, caches, storage) that handlers can use.</p>
<h2 id="list-services"><a class="header" href="#list-services">List Services</a></h2>
<pre><code class="language-bash">GET /api/services
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Main Database",
      "service_type": "postgres",
      "config": {
        "host": "db.example.com",
        "port": 5432,
        "database": "myapp"
      },
      "enabled": true,
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<h2 id="create-service"><a class="header" href="#create-service">Create Service</a></h2>
<pre><code class="language-bash">POST /api/services
Content-Type: application/json

{
  "name": "Main Database",
  "service_type": "postgres",
  "config": {
    "host": "db.example.com",
    "port": 5432,
    "database": "myapp",
    "username": "app_user",
    "password": "secret"
  },
  "enabled": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Display name</td></tr>
<tr><td><code>service_type</code></td><td>string</td><td>Yes</td><td>Type of service (see below)</td></tr>
<tr><td><code>config</code></td><td>object</td><td>Yes</td><td>Service-specific configuration</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>No</td><td>Whether service is active (default: true)</td></tr>
</tbody></table>
</div>
<p><strong>Service Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sqlite</code></td><td>SQLite embedded database</td></tr>
<tr><td><code>postgres</code></td><td>PostgreSQL database</td></tr>
<tr><td><code>mysql</code></td><td>MySQL database</td></tr>
<tr><td><code>redis</code></td><td>Redis cache/store</td></tr>
<tr><td><code>mongodb</code></td><td>MongoDB document database</td></tr>
<tr><td><code>minio</code></td><td>MinIO/S3 object storage</td></tr>
<tr><td><code>memcached</code></td><td>Memcached cache</td></tr>
<tr><td><code>ftp</code></td><td>FTP/FTPS/SFTP file transfer</td></tr>
<tr><td><code>email</code></td><td>SMTP email sending</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Main Database",
    "service_type": "postgres",
    "config": { ... },
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="get-service"><a class="header" href="#get-service">Get Service</a></h2>
<pre><code class="language-bash">GET /api/services/{id}
</code></pre>
<h2 id="update-service"><a class="header" href="#update-service">Update Service</a></h2>
<pre><code class="language-bash">PUT /api/services/{id}
Content-Type: application/json

{
  "name": "Updated Name",
  "config": {
    "host": "new-db.example.com"
  },
  "enabled": false
}
</code></pre>
<h2 id="delete-service"><a class="header" href="#delete-service">Delete Service</a></h2>
<pre><code class="language-bash">DELETE /api/services/{id}
</code></pre>
<h2 id="test-service-connection"><a class="header" href="#test-service-connection">Test Service Connection</a></h2>
<p>Test if the service is reachable and properly configured.</p>
<pre><code class="language-bash">POST /api/services/{id}/test
</code></pre>
<p><strong>Response (Success):</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "connected": true,
    "latency_ms": 5,
    "message": "Connection successful"
  }
}
</code></pre>
<p><strong>Response (Failure):</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "connected": false,
    "error": "Connection refused"
  }
}
</code></pre>
<h2 id="service-configuration-examples"><a class="header" href="#service-configuration-examples">Service Configuration Examples</a></h2>
<h3 id="postgresql-1"><a class="header" href="#postgresql-1">PostgreSQL</a></h3>
<pre><code class="language-json">{
  "service_type": "postgres",
  "config": {
    "host": "localhost",
    "port": 5432,
    "database": "myapp",
    "username": "app_user",
    "password": "secret",
    "ssl_mode": "prefer",
    "pool_size": 10
  }
}
</code></pre>
<h3 id="mysql-1"><a class="header" href="#mysql-1">MySQL</a></h3>
<pre><code class="language-json">{
  "service_type": "mysql",
  "config": {
    "host": "localhost",
    "port": 3306,
    "database": "myapp",
    "username": "app_user",
    "password": "secret",
    "use_ssl": false,
    "pool_size": 10
  }
}
</code></pre>
<h3 id="redis"><a class="header" href="#redis">Redis</a></h3>
<pre><code class="language-json">{
  "service_type": "redis",
  "config": {
    "host": "localhost",
    "port": 6379,
    "password": null,
    "database": 0,
    "use_tls": false,
    "pool_size": 10
  }
}
</code></pre>
<h3 id="sqlite-1"><a class="header" href="#sqlite-1">SQLite</a></h3>
<pre><code class="language-json">{
  "service_type": "sqlite",
  "config": {
    "path": "/data/app.db",
    "create_if_missing": true
  }
}
</code></pre>
<h3 id="minio"><a class="header" href="#minio">MinIO</a></h3>
<pre><code class="language-json">{
  "service_type": "minio",
  "config": {
    "endpoint": "minio.example.com:9000",
    "access_key": "minioadmin",
    "secret_key": "minioadmin",
    "use_ssl": true,
    "bucket": "uploads"
  }
}
</code></pre>
<h3 id="ftpsftp"><a class="header" href="#ftpsftp">FTP/SFTP</a></h3>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "sftp.example.com",
    "port": 22,
    "username": "user",
    "password": "secret",
    "protocol": "sftp",
    "base_path": "/uploads",
    "timeout_seconds": 30
  }
}
</code></pre>
<h3 id="email-smtp"><a class="header" href="#email-smtp">Email (SMTP)</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "smtp.example.com",
    "port": 587,
    "username": "sender@example.com",
    "password": "app-password",
    "encryption": "starttls",
    "from_address": "noreply@example.com",
    "from_name": "My App"
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="endpoints-api"><a class="header" href="#endpoints-api">Endpoints API</a></h1>
<p>Endpoints are the core resource - each represents a route with handler code.</p>
<h2 id="list-endpoints"><a class="header" href="#list-endpoints">List Endpoints</a></h2>
<pre><code class="language-bash">GET /api/endpoints
</code></pre>
<p><strong>Query Parameters:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>domain</code></td><td>string</td><td>Filter by domain hostname</td></tr>
<tr><td><code>collection_id</code></td><td>string</td><td>Filter by collection UUID</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>Filter by enabled status</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "getPets",
      "path": "/pets",
      "method": "GET",
      "domain": "api.example.com",
      "collection_id": "collection-uuid",
      "description": "List all pets",
      "code": "use rust_edge_gateway_sdk::prelude::*;\n...",
      "enabled": true,
      "status": "running",
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<h2 id="create-endpoint"><a class="header" href="#create-endpoint">Create Endpoint</a></h2>
<pre><code class="language-bash">POST /api/endpoints
Content-Type: application/json

{
  "name": "getPets",
  "path": "/pets",
  "method": "GET",
  "domain": "api.example.com",
  "collection_id": "collection-uuid",
  "description": "List all pets",
  "code": "use rust_edge_gateway_sdk::prelude::*;\n\nfn handle(req: Request) -&gt; Response {\n    Response::ok(json!({\"pets\": []}))\n}\n\nhandler_loop!(handle);",
  "enabled": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Endpoint name (for display)</td></tr>
<tr><td><code>path</code></td><td>string</td><td>Yes</td><td>URL path pattern (e.g., <code>/pets/{id}</code>)</td></tr>
<tr><td><code>method</code></td><td>string</td><td>Yes</td><td>HTTP method (GET, POST, PUT, DELETE, PATCH)</td></tr>
<tr><td><code>domain</code></td><td>string</td><td>Yes</td><td>Domain hostname or <code>*</code> for all</td></tr>
<tr><td><code>collection_id</code></td><td>string</td><td>No</td><td>Parent collection UUID</td></tr>
<tr><td><code>description</code></td><td>string</td><td>No</td><td>Description of the endpoint</td></tr>
<tr><td><code>code</code></td><td>string</td><td>No</td><td>Rust handler code</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>No</td><td>Whether endpoint is active (default: true)</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "getPets",
    "path": "/pets",
    "method": "GET",
    "domain": "api.example.com",
    "collection_id": "collection-uuid",
    "description": "List all pets",
    "code": "...",
    "enabled": true,
    "status": "created",
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="get-endpoint"><a class="header" href="#get-endpoint">Get Endpoint</a></h2>
<pre><code class="language-bash">GET /api/endpoints/{id}
</code></pre>
<h2 id="update-endpoint"><a class="header" href="#update-endpoint">Update Endpoint</a></h2>
<pre><code class="language-bash">PUT /api/endpoints/{id}
Content-Type: application/json

{
  "name": "Updated Name",
  "code": "// new code...",
  "enabled": false
}
</code></pre>
<h2 id="delete-endpoint"><a class="header" href="#delete-endpoint">Delete Endpoint</a></h2>
<pre><code class="language-bash">DELETE /api/endpoints/{id}
</code></pre>
<h2 id="compile-endpoint"><a class="header" href="#compile-endpoint">Compile Endpoint</a></h2>
<p>Compile the handler code into an executable.</p>
<pre><code class="language-bash">POST /api/endpoints/{id}/compile
</code></pre>
<p><strong>Response (Success):</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "status": "compiled",
    "message": "Compilation successful"
  }
}
</code></pre>
<p><strong>Response (Failure):</strong></p>
<pre><code class="language-json">{
  "ok": false,
  "error": "error[E0308]: mismatched types\n  --&gt; src/main.rs:5:5\n..."
}
</code></pre>
<h2 id="start-endpoint"><a class="header" href="#start-endpoint">Start Endpoint</a></h2>
<p>Start the worker process for this endpoint.</p>
<pre><code class="language-bash">POST /api/endpoints/{id}/start
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "status": "running",
    "pid": 12345
  }
}
</code></pre>
<h2 id="stop-endpoint"><a class="header" href="#stop-endpoint">Stop Endpoint</a></h2>
<p>Stop the worker process.</p>
<pre><code class="language-bash">POST /api/endpoints/{id}/stop
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "status": "stopped"
  }
}
</code></pre>
<h2 id="endpoint-status-values"><a class="header" href="#endpoint-status-values">Endpoint Status Values</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td><code>created</code></td><td>Endpoint defined, not yet compiled</td></tr>
<tr><td><code>compiled</code></td><td>Code compiled successfully</td></tr>
<tr><td><code>running</code></td><td>Worker process is active</td></tr>
<tr><td><code>stopped</code></td><td>Worker stopped, can be restarted</td></tr>
<tr><td><code>error</code></td><td>Compilation or runtime error</td></tr>
</tbody></table>
</div>
<h2 id="bind-service-to-endpoint"><a class="header" href="#bind-service-to-endpoint">Bind Service to Endpoint</a></h2>
<p>Associate a service with an endpoint.</p>
<pre><code class="language-bash">POST /api/endpoints/{id}/services
Content-Type: application/json

{
  "service_id": "service-uuid",
  "pool_id": "main-db"
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>service_id</code></td><td>string</td><td>Yes</td><td>Service UUID to bind</td></tr>
<tr><td><code>pool_id</code></td><td>string</td><td>Yes</td><td>Identifier used in handler code</td></tr>
</tbody></table>
</div>
<h2 id="unbind-service"><a class="header" href="#unbind-service">Unbind Service</a></h2>
<pre><code class="language-bash">DELETE /api/endpoints/{endpoint_id}/services/{service_id}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
