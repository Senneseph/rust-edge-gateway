<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Edge Gateway</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for writing handlers and using the Rust Edge Gateway SDK">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Edge Gateway</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Senneseph/rust-edge-gateway" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-edge-gateway"><a class="header" href="#rust-edge-gateway">Rust Edge Gateway</a></h1>
<p><strong>Rust Edge Gateway</strong> is a high-performance API gateway that lets you write request handlers in Rust. Your handlers are compiled to native dynamic libraries and loaded directly into the gateway process, providing:</p>
<ul>
<li>ğŸš€ <strong>Native Performance</strong> - Handlers compile to optimized native code (.so/.dll)</li>
<li>âš¡ <strong>Zero-Copy Execution</strong> - Direct function calls, no serialization overhead</li>
<li>ğŸ”„ <strong>Hot Reload</strong> - Swap handlers without restarting the gateway</li>
<li>ğŸ­ <strong>Actor-Based Services</strong> - Database, cache, and storage via message-passing</li>
<li>ğŸ”€ <strong>Graceful Draining</strong> - Zero-downtime deployments with request draining</li>
<li>ğŸ› ï¸ <strong>Simple SDK</strong> - Easy-to-use Context, Request, and Response API</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client    â”‚â”€â”€â”€â”€â–¶â”‚  Edge Gateway    â”‚â”€â”€â”€â”€â–¶â”‚  Your Handler   â”‚
â”‚  (Browser,  â”‚     â”‚  (Routes &amp;       â”‚     â”‚  (Dynamic       â”‚
â”‚   API, etc) â”‚â—€â”€â”€â”€â”€â”‚   Manages)       â”‚â—€â”€â”€â”€â”€â”‚   Library .so)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Service Actorsâ”‚
                    â”‚  (DB, Cache,  â”‚
                    â”‚   Storage)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<ol>
<li><strong>Gateway receives request</strong> - The gateway matches the incoming request to an endpoint</li>
<li><strong>Handler is invoked</strong> - The compiled handler library is called directly via function pointer</li>
<li><strong>Handler processes</strong> - Your code runs with access to the Context API and Service Actors</li>
<li><strong>Response returned</strong> - The handler returns a Response directly to the gateway</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>The fastest way to get started is to:</p>
<ol>
<li>Access the Admin UI at <code>/admin/</code></li>
<li>Create a new endpoint</li>
<li>Write your handler code</li>
<li>Compile and deploy</li>
</ol>
<p>See the <a href="./getting-started/quick-start.html">Quick Start</a> guide for detailed instructions.</p>
<h2 id="sdk-overview"><a class="header" href="#sdk-overview">SDK Overview</a></h2>
<p>Your handler code uses the <code>rust-edge-gateway-sdk</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello, World!",
        "path": req.path,
        "method": req.method,
    }))
}
<span class="boring">}</span></code></pre></pre>
<p>The SDK provides:</p>
<ul>
<li><strong><a href="./sdk/context.html">Context</a></strong> - Access to Service Actors (database, cache, storage)</li>
<li><strong><a href="./sdk/request.html">Request</a></strong> - Access HTTP method, path, headers, body, query params</li>
<li><strong><a href="./sdk/response.html">Response</a></strong> - Build HTTP responses with JSON, text, or custom content</li>
<li><strong><a href="./sdk/errors.html">HandlerError</a></strong> - Structured error handling with HTTP status codes</li>
<li><strong><a href="./sdk/services.html">Services</a></strong> - Database, cache, and storage service actors</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>Rust Edge Gateway uses a dynamic library loading model with actor-based services:</p>
<ul>
<li><strong>Main Gateway</strong> - Axum-based HTTP server handling routing</li>
<li><strong>Handler Registry</strong> - Manages loaded handler libraries with hot-swap support</li>
<li><strong>Dynamic Libraries</strong> - Your compiled handlers as <code>.so</code> (Linux), <code>.dll</code> (Windows), or <code>.dylib</code> (macOS)</li>
<li><strong>Service Actors</strong> - Message-passing based services for database, cache, and storage</li>
<li><strong>Graceful Draining</strong> - Old handlers complete in-flight requests during updates</li>
</ul>
<p>This architecture provides:</p>
<ul>
<li><strong>Performance</strong> - Direct function calls with zero serialization overhead</li>
<li><strong>Hot Swapping</strong> - Replace handlers without gateway restart</li>
<li><strong>Zero Downtime</strong> - Graceful draining ensures no dropped requests during updates</li>
<li><strong>Scalability</strong> - Async handlers with Tokio runtime for high concurrency</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>This guide will help you create your first Rust Edge Gateway endpoint in under 5 minutes.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Rust Edge Gateway running (either locally via Docker or deployed)</li>
<li>Access to the Admin UI</li>
</ul>
<h2 id="step-1-access-the-admin-ui"><a class="header" href="#step-1-access-the-admin-ui">Step 1: Access the Admin UI</a></h2>
<p>Navigate to your gateway's admin interface:</p>
<ul>
<li><strong>Local Development</strong>: <code>http://localhost:9081/admin/</code></li>
<li><strong>Production</strong>: <code>https://rust-edge-gateway.yourdomain.com/admin/</code></li>
</ul>
<h2 id="step-2-create-an-endpoint"><a class="header" href="#step-2-create-an-endpoint">Step 2: Create an Endpoint</a></h2>
<ol>
<li>Click <strong>"Create Endpoint"</strong> or the <strong>+</strong> button</li>
<li>Fill in the endpoint details:</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Example Value</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Name</strong></td><td><code>hello-world</code></td><td>Unique identifier for your endpoint</td></tr>
<tr><td><strong>Path</strong></td><td><code>/hello</code></td><td>The URL path to match</td></tr>
<tr><td><strong>Method</strong></td><td><code>GET</code></td><td>HTTP method (GET, POST, PUT, DELETE, etc.)</td></tr>
<tr><td><strong>Domain</strong></td><td><code>*</code></td><td>Domain to match (or <code>*</code> for all)</td></tr>
</tbody></table>
</div>
<ol start="3">
<li>Click <strong>Save</strong></li>
</ol>
<h2 id="step-3-write-handler-code"><a class="header" href="#step-3-write-handler-code">Step 3: Write Handler Code</a></h2>
<p>In the code editor, replace the default code with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello from Rust Edge Gateway!",
        "path": req.path,
        "method": req.method,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-4-compile"><a class="header" href="#step-4-compile">Step 4: Compile</a></h2>
<p>Click the <strong>"Compile"</strong> button. The gateway will:</p>
<ol>
<li>Generate a Cargo project with your code</li>
<li>Compile it to a dynamic library (<code>.so</code>/<code>.dll</code>)</li>
<li>Report success or any compilation errors</li>
</ol>
<p>You should see a success message like:</p>
<pre><code>âœ“ Compiled successfully in 2.3s
</code></pre>
<h2 id="step-5-deploy-the-endpoint"><a class="header" href="#step-5-deploy-the-endpoint">Step 5: Deploy the Endpoint</a></h2>
<p>Click <strong>"Deploy"</strong> to load the handler. The status should change to <strong>Loaded</strong>.</p>
<p>The handler is now active and receiving requests - no separate "start" step needed!</p>
<h2 id="step-6-test-your-endpoint"><a class="header" href="#step-6-test-your-endpoint">Step 6: Test Your Endpoint</a></h2>
<p>Make a request to your endpoint:</p>
<pre><code class="language-bash">curl http://localhost:9080/hello
</code></pre>
<p>You should receive:</p>
<pre><code class="language-json">{
  "message": "Hello from Rust Edge Gateway!",
  "path": "/hello",
  "method": "GET"
}
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<ul>
<li><a href="getting-started/./first-handler.html">Your First Handler</a> - Deeper dive into handler structure</li>
<li><a href="getting-started/./lifecycle.html">Handler Lifecycle</a> - Understand compilation, loading, and hot-swapping</li>
<li><a href="getting-started/../sdk/context.html">Context API</a> - Access services via the Context</li>
<li><a href="getting-started/../sdk/request.html">Request API</a> - Access headers, body, parameters</li>
<li><a href="getting-started/../sdk/response.html">Response API</a> - Build JSON, text, and custom responses</li>
<li><a href="getting-started/../examples/hello-world.html">Examples</a> - More code examples</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h3>
<p>Check the error message for:</p>
<ul>
<li>Missing dependencies (add to your handler's <code>use</code> statements)</li>
<li>Syntax errors (Rust compiler messages are helpful!)</li>
<li>Type mismatches</li>
<li>Missing <code>#[handler]</code> attribute</li>
</ul>
<h3 id="endpoint-not-responding"><a class="header" href="#endpoint-not-responding">Endpoint Not Responding</a></h3>
<ol>
<li>Check the endpoint is in <strong>Loaded</strong> status</li>
<li>Verify the path matches exactly (paths are case-sensitive)</li>
<li>Check the method matches your request</li>
<li>View endpoint logs in the admin UI</li>
</ol>
<h3 id="handler-errors"><a class="header" href="#handler-errors">Handler Errors</a></h3>
<p>View the logs to see panic messages or error output. Common causes:</p>
<ul>
<li>Unwrapping <code>None</code> or <code>Err</code> values</li>
<li>Accessing invalid JSON fields</li>
<li>Service actor communication errors</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-handler"><a class="header" href="#your-first-handler">Your First Handler</a></h1>
<p>This guide explains the structure of a handler and how to work with the Context, Request, and Response.</p>
<h2 id="handler-structure"><a class="header" href="#handler-structure">Handler Structure</a></h2>
<p>Every handler follows the same pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    // Your logic here
    Response::ok(json!({"status": "success"}))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-prelude"><a class="header" href="#the-prelude">The Prelude</a></h3>
<p>The <code>prelude</code> module imports everything you typically need:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

// This imports:
// - Context for service access
// - Request, Response types
// - serde::{Deserialize, Serialize}
// - serde_json::{json, Value as JsonValue}
// - HandlerError for error handling
// - The #[handler] attribute macro
<span class="boring">}</span></code></pre></pre>
<h3 id="the-handler-function"><a class="header" href="#the-handler-function">The Handler Function</a></h3>
<p>Your handler function receives a <code>Context</code> and <code>Request</code>, and returns a <code>Response</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    // Access request data
    let method = &amp;req.method;  // "GET", "POST", etc.
    let path = &amp;req.path;      // "/users/123"

    // Access services via ctx (database, cache, storage)
    // let db = ctx.database();

    // Return a response
    Response::ok(json!({"received": path}))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-handler-attribute"><a class="header" href="#the-handler-attribute">The Handler Attribute</a></h3>
<p>The <code>#[handler]</code> attribute macro generates the entry point for the dynamic library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    // ...
}

// This generates:
// #[no_mangle]
// pub extern "C" fn handler_entry(ctx: &amp;Context, req: Request) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Response&gt; + Send&gt;&gt; {
//     Box::pin(handle(ctx, req))
// }
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-requests"><a class="header" href="#working-with-requests">Working with Requests</a></h2>
<h3 id="accessing-the-body"><a class="header" href="#accessing-the-body">Accessing the Body</a></h3>
<p>For POST/PUT requests, parse the JSON body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    // Parse JSON body
    let user: CreateUser = match req.json() {
        Ok(u) =&gt; u,
        Err(e) =&gt; return Response::bad_request(format!("Invalid JSON: {}", e)),
    };

    Response::created(json!({
        "id": "new-user-id",
        "name": user.name,
        "email": user.email,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="path-parameters"><a class="header" href="#path-parameters">Path Parameters</a></h3>
<p>Extract dynamic path segments (e.g., <code>/users/{id}</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    let user_id = req.path_param("id")
        .ok_or_else(|| "Missing user ID")?;

    Response::ok(json!({"user_id": user_id}))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="query-parameters"><a class="header" href="#query-parameters">Query Parameters</a></h3>
<p>Access query string values (e.g., <code>?page=1&amp;limit=10</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    let page = req.query_param("page")
        .map(|s| s.parse::&lt;u32&gt;().unwrap_or(1))
        .unwrap_or(1);

    let limit = req.query_param("limit")
        .map(|s| s.parse::&lt;u32&gt;().unwrap_or(10))
        .unwrap_or(10);

    Response::ok(json!({
        "page": page,
        "limit": limit,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="headers"><a class="header" href="#headers">Headers</a></h3>
<p>Access HTTP headers (case-insensitive):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    let auth = req.header("Authorization");
    let content_type = req.header("Content-Type");

    if auth.is_none() {
        return Response::json(401, json!({"error": "Unauthorized"}));
    }

    Response::ok(json!({"authenticated": true}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-responses"><a class="header" href="#working-with-responses">Working with Responses</a></h2>
<h3 id="json-responses"><a class="header" href="#json-responses">JSON Responses</a></h3>
<p>The most common response type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 200 OK with JSON
Response::ok(json!({"status": "success"}))

// 201 Created
Response::created(json!({"id": "123"}))

// Custom status with JSON
Response::json(418, json!({"error": "I'm a teapot"}))
<span class="boring">}</span></code></pre></pre>
<h3 id="error-responses"><a class="header" href="#error-responses">Error Responses</a></h3>
<p>Built-in error response helpers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::bad_request("Invalid input")      // 400
Response::not_found()                        // 404
Response::internal_error("Something broke")  // 500
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-headers"><a class="header" href="#custom-headers">Custom Headers</a></h3>
<p>Add headers to any response:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(json!({"data": "value"}))
    .with_header("X-Custom-Header", "custom-value")
    .with_header("Cache-Control", "max-age=3600")
<span class="boring">}</span></code></pre></pre>
<h3 id="text-responses"><a class="header" href="#text-responses">Text Responses</a></h3>
<p>For non-JSON responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::text(200, "Hello, World!")
Response::text(200, "&lt;html&gt;&lt;body&gt;Hello&lt;/body&gt;&lt;/html&gt;")
    .with_header("Content-Type", "text/html")
<span class="boring">}</span></code></pre></pre>
<h2 id="using-the-context"><a class="header" href="#using-the-context">Using the Context</a></h2>
<p>The <code>Context</code> provides access to Service Actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    // Access database service
    let db = ctx.database("main-db").await?;
    let users = db.query("SELECT * FROM users").await?;

    // Access cache service
    let cache = ctx.cache("redis").await?;
    cache.set("key", "value", 300).await?;

    // Access storage service
    let storage = ctx.storage("s3").await?;
    storage.put("file.txt", data).await?;

    Response::ok(json!({"users": users}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="getting-started/./lifecycle.html">Handler Lifecycle</a> - Compilation, loading, and hot-swapping</li>
<li><a href="getting-started/../sdk/context.html">Context API</a> - Service access via Context</li>
<li><a href="getting-started/../sdk/errors.html">Error Handling</a> - Structured error handling</li>
<li><a href="getting-started/../examples/hello-world.html">Examples</a> - More code examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler-lifecycle"><a class="header" href="#handler-lifecycle">Handler Lifecycle</a></h1>
<p>Understanding how handlers are compiled, loaded, and managed helps you write more reliable code.</p>
<h2 id="endpoint-states"><a class="header" href="#endpoint-states">Endpoint States</a></h2>
<p>An endpoint can be in one of these states:</p>
<div class="table-wrapper"><table><thead><tr><th>State</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Created</strong></td><td>Endpoint defined but code not yet compiled</td></tr>
<tr><td><strong>Compiled</strong></td><td>Code compiled to dynamic library, ready to load</td></tr>
<tr><td><strong>Loaded</strong></td><td>Handler library loaded into gateway, handling requests</td></tr>
<tr><td><strong>Draining</strong></td><td>Old handler finishing in-flight requests during update</td></tr>
<tr><td><strong>Error</strong></td><td>Compilation or runtime error occurred</td></tr>
</tbody></table>
</div>
<h2 id="compilation"><a class="header" href="#compilation">Compilation</a></h2>
<p>When you click "Compile", the gateway:</p>
<ol>
<li><strong>Creates a Cargo project</strong> in the handlers directory</li>
<li><strong>Writes your code</strong> to <code>src/lib.rs</code></li>
<li><strong>Generates Cargo.toml</strong> with the SDK dependency and <code>cdylib</code> crate type</li>
<li><strong>Runs <code>cargo build --release</code></strong> to compile</li>
<li><strong>Produces a dynamic library</strong> (<code>.so</code>, <code>.dll</code>, or <code>.dylib</code>)</li>
</ol>
<h3 id="generated-project-structure"><a class="header" href="#generated-project-structure">Generated Project Structure</a></h3>
<pre><code>handlers/
â””â”€â”€ {endpoint-id}/
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ Cargo.lock
    â”œâ”€â”€ src/
    â”‚   â””â”€â”€ lib.rs    # Your handler code
    â””â”€â”€ target/
        â””â”€â”€ release/
            â””â”€â”€ libhandler_{id}.so  # Compiled library (Linux)
</code></pre>
<h3 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h3>
<p>The generated Cargo.toml includes the SDK and configures a dynamic library:</p>
<pre><code class="language-toml">[package]
name = "handler_{endpoint_id}"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
rust-edge-gateway-sdk = { path = "../../crates/rust-edge-gateway-sdk" }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
</code></pre>
<h2 id="handler-loading"><a class="header" href="#handler-loading">Handler Loading</a></h2>
<h3 id="loading-a-handler"><a class="header" href="#loading-a-handler">Loading a Handler</a></h3>
<p>When you deploy an endpoint:</p>
<ol>
<li>Gateway loads the dynamic library using <code>libloading</code></li>
<li>Locates the <code>handler_entry</code> symbol (function pointer)</li>
<li>Registers the handler in the <code>HandlerRegistry</code></li>
<li>Status changes to "Loaded"</li>
</ol>
<h3 id="request-flow"><a class="header" href="#request-flow">Request Flow</a></h3>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Request   â”‚â”€â”€â”€â”€â–¶â”‚  HandlerRegistry â”‚â”€â”€â”€â”€â–¶â”‚  handler_entry  â”‚
â”‚             â”‚     â”‚  (lookup by ID)  â”‚     â”‚  (fn pointer)   â”‚
â”‚             â”‚â—€â”€â”€â”€â”€â”‚                  â”‚â—€â”€â”€â”€â”€â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>The handler is called directly via function pointer - no serialization or IPC overhead.</p>
<h3 id="handler-function"><a class="header" href="#handler-function">Handler Function</a></h3>
<p>Your handler is an async function that receives a Context and Request:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    // Access services via ctx
    // Process request
    // Return response
    Response::ok(json!({"status": "success"}))
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[handler]</code> macro generates the <code>handler_entry</code> symbol that the gateway looks for.</p>
<h2 id="hot-swapping-with-graceful-draining"><a class="header" href="#hot-swapping-with-graceful-draining">Hot Swapping with Graceful Draining</a></h2>
<p>Rust Edge Gateway supports zero-downtime updates with graceful draining:</p>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h3>
<ol>
<li><strong>Compile new version</strong> - New handler library is compiled</li>
<li><strong>Load new handler</strong> - New library is loaded into memory</li>
<li><strong>Atomic swap</strong> - New handler starts receiving new requests</li>
<li><strong>Drain old handler</strong> - Old handler finishes in-flight requests</li>
<li><strong>Unload old handler</strong> - Once drained, old library is unloaded</li>
</ol>
<h3 id="request-tracking"><a class="header" href="#request-tracking">Request Tracking</a></h3>
<p>Each handler tracks active requests:</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Handler Update Timeline                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶   â”‚
â”‚                                                              â”‚
â”‚  Old Handler:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  â”‚
â”‚                (handling)  (draining)  (unloaded)            â”‚
â”‚                                                              â”‚
â”‚  New Handler:  â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â”‚
â”‚                            (handling new requests)           â”‚
â”‚                                                              â”‚
â”‚                     â–²                                        â”‚
â”‚                     â”‚ Swap point                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="drain-timeout"><a class="header" href="#drain-timeout">Drain Timeout</a></h3>
<p>If the old handler doesn't drain within the timeout (default: 30 seconds), it is forcefully unloaded. Configure this based on your longest expected request duration.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="compilation-errors-1"><a class="header" href="#compilation-errors-1">Compilation Errors</a></h3>
<p>If compilation fails:</p>
<ul>
<li>Error message is captured and displayed</li>
<li>Endpoint stays in previous state</li>
<li>Previous library (if any) remains loaded</li>
</ul>
<h3 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h3>
<p>If your handler panics:</p>
<ul>
<li>The panic is caught by the gateway</li>
<li>Error is logged</li>
<li>Other handlers continue working</li>
<li>The specific request returns a 500 error</li>
</ul>
<h3 id="graceful-error-handling"><a class="header" href="#graceful-error-handling">Graceful Error Handling</a></h3>
<p>Always handle errors in your code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    match process_request(ctx, &amp;req).await {
        Ok(data) =&gt; Response::ok(data),
        Err(e) =&gt; e.to_response(), // HandlerError -&gt; Response
    }
}

async fn process_request(ctx: &amp;Context, req: &amp;Request) -&gt; Result&lt;JsonValue, HandlerError&gt; {
    let body: MyInput = req.json()
        .map_err(|e| HandlerError::ValidationError(e.to_string()))?;

    // Use services via ctx
    // ... process ...

    Ok(json!({"result": "success"}))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler-attribute"><a class="header" href="#handler-attribute">Handler Attribute</a></h1>
<p>The SDK provides the <code>#[handler]</code> attribute macro for creating handler entry points.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Handler Signature</th><th>Use Case</th></tr></thead><tbody>
<tr><td>Basic</td><td><code>async fn(&amp;Context, Request) -&gt; Response</code></td><td>Standard handlers</td></tr>
<tr><td>With Result</td><td><code>async fn(&amp;Context, Request) -&gt; Result&lt;Response, HandlerError&gt;</code></td><td>Error handling with <code>?</code></td></tr>
</tbody></table>
</div>
<h2 id="the-handler-attribute-1"><a class="header" href="#the-handler-attribute-1">The Handler Attribute</a></h2>
<p>The <code>#[handler]</code> attribute generates the dynamic library entry point:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    Response::ok(json!({"path": req.path, "method": req.method}))
}
<span class="boring">}</span></code></pre></pre>
<p>This generates a <code>handler_entry</code> symbol that the gateway loads and calls directly.</p>
<h2 id="handler-signature"><a class="header" href="#handler-signature">Handler Signature</a></h2>
<p>All handlers receive:</p>
<ul>
<li><code>ctx: &amp;Context</code> - Access to Service Actors (database, cache, storage)</li>
<li><code>req: Request</code> - The incoming HTTP request</li>
</ul>
<p>And return:</p>
<ul>
<li><code>Response</code> - The HTTP response to send</li>
</ul>
<h3 id="basic-handler"><a class="header" href="#basic-handler">Basic Handler</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello!",
        "path": req.path
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handler-with-error-handling"><a class="header" href="#handler-with-error-handling">Handler with Error Handling</a></h3>
<p>For handlers that use the <code>?</code> operator, return <code>Result&lt;Response, HandlerError&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[derive(Deserialize)]
struct CreateItem {
    name: String,
    price: f64,
}

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // These all use ? operator - errors become HTTP responses
    let auth = req.require_header("Authorization")?;
    let item: CreateItem = req.json()?;

    if item.price &lt; 0.0 {
        return Err(HandlerError::ValidationError("Price cannot be negative".into()));
    }

    Ok(Response::created(json!({"name": item.name})))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-services-via-context"><a class="header" href="#using-services-via-context">Using Services via Context</a></h2>
<p>The <code>Context</code> provides access to Service Actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // Database operations
    let db = ctx.database("main-db").await?;
    let users = db.query("SELECT * FROM users WHERE active = $1", &amp;[&amp;true]).await?;

    // Cache operations
    let cache = ctx.cache("redis").await?;
    if let Some(cached) = cache.get("users:all").await? {
        return Ok(Response::ok(cached));
    }

    // Storage operations
    let storage = ctx.storage("s3").await?;
    let file = storage.get("config.json").await?;

    Ok(Response::ok(json!({"users": users})))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="async-by-default"><a class="header" href="#async-by-default">Async by Default</a></h2>
<p>All handlers are async - the gateway runs them on a Tokio runtime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    // You can use .await directly
    let data = fetch_from_api().await;

    // Concurrent operations
    let (users, products) = tokio::join!(
        fetch_users(),
        fetch_products()
    );

    Response::ok(json!({"users": users, "products": products}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="example-complete-crud-handler"><a class="header" href="#example-complete-crud-handler">Example: Complete CRUD Handler</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    match (req.method.as_str(), req.path.as_str()) {
        ("GET", "/items") =&gt; list_items(ctx).await,
        ("POST", "/items") =&gt; create_item(ctx, &amp;req).await,
        ("GET", _) if req.path.starts_with("/items/") =&gt; get_item(ctx, &amp;req).await,
        ("DELETE", _) if req.path.starts_with("/items/") =&gt; delete_item(ctx, &amp;req).await,
        _ =&gt; Err(HandlerError::MethodNotAllowed("Use GET, POST, or DELETE".into())),
    }
}

async fn list_items(ctx: &amp;Context) -&gt; Result&lt;Response, HandlerError&gt; {
    let db = ctx.database("main-db").await?;
    let items = db.query("SELECT * FROM items", &amp;[]).await?;
    Ok(Response::ok(json!({"items": items})))
}

async fn create_item(ctx: &amp;Context, req: &amp;Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let item: NewItem = req.json()?;
    let db = ctx.database("main-db").await?;
    let id = db.execute("INSERT INTO items (name) VALUES ($1) RETURNING id", &amp;[&amp;item.name]).await?;
    Ok(Response::created(json!({"id": id})))
}

async fn get_item(ctx: &amp;Context, req: &amp;Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let id = req.path.strip_prefix("/items/").unwrap_or("");
    let db = ctx.database("main-db").await?;
    let item = db.query_one("SELECT * FROM items WHERE id = $1", &amp;[&amp;id]).await?;
    Ok(Response::ok(item))
}

async fn delete_item(ctx: &amp;Context, req: &amp;Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let id = req.path.strip_prefix("/items/").unwrap_or("");
    let db = ctx.database("main-db").await?;
    db.execute("DELETE FROM items WHERE id = $1", &amp;[&amp;id]).await?;
    Ok(Response::no_content())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-api"><a class="header" href="#context-api">Context API</a></h1>
<p>The <code>Context</code> provides access to Service Actors from within your handler. It's the bridge between your handler code and backend services like databases, caches, and storage.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Every handler receives a <code>Context</code> reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Response {
    // Use ctx to access services
    let db = ctx.database("main-db").await?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="available-services"><a class="header" href="#available-services">Available Services</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ctx.database(name)</code></td><td><code>DatabaseHandle</code></td><td>SQL database connection</td></tr>
<tr><td><code>ctx.cache(name)</code></td><td><code>CacheHandle</code></td><td>Key-value cache (Redis)</td></tr>
<tr><td><code>ctx.storage(name)</code></td><td><code>StorageHandle</code></td><td>Object storage (S3/MinIO)</td></tr>
</tbody></table>
</div>
<h2 id="database-access"><a class="header" href="#database-access">Database Access</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let db = ctx.database("main-db").await?;
    
    // Query with parameters
    let users = db.query(
        "SELECT id, name, email FROM users WHERE active = $1",
        &amp;[&amp;true]
    ).await?;
    
    // Execute (INSERT, UPDATE, DELETE)
    let affected = db.execute(
        "UPDATE users SET last_login = NOW() WHERE id = $1",
        &amp;[&amp;user_id]
    ).await?;
    
    // Query single row
    let user = db.query_one(
        "SELECT * FROM users WHERE id = $1",
        &amp;[&amp;user_id]
    ).await?;
    
    Ok(Response::ok(json!({"users": users})))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cache-access"><a class="header" href="#cache-access">Cache Access</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let cache = ctx.cache("redis").await?;
    
    // Try cache first
    if let Some(cached) = cache.get("users:all").await? {
        return Ok(Response::ok(cached));
    }
    
    // Cache miss - fetch from database
    let db = ctx.database("main-db").await?;
    let users = db.query("SELECT * FROM users", &amp;[]).await?;
    
    // Store in cache with TTL (seconds)
    cache.set("users:all", &amp;users, 300).await?;
    
    Ok(Response::ok(json!({"users": users})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cache-operations"><a class="header" href="#cache-operations">Cache Operations</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>get(key)</code></td><td>Get value by key</td></tr>
<tr><td><code>set(key, value, ttl)</code></td><td>Set value with TTL in seconds</td></tr>
<tr><td><code>delete(key)</code></td><td>Delete a key</td></tr>
<tr><td><code>exists(key)</code></td><td>Check if key exists</td></tr>
<tr><td><code>incr(key)</code></td><td>Increment numeric value</td></tr>
<tr><td><code>decr(key)</code></td><td>Decrement numeric value</td></tr>
</tbody></table>
</div>
<h2 id="storage-access"><a class="header" href="#storage-access">Storage Access</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let storage = ctx.storage("s3").await?;
    
    // Upload file
    let data = req.body_bytes();
    storage.put("uploads/file.txt", data).await?;
    
    // Download file
    let content = storage.get("config/settings.json").await?;
    
    // List files
    let files = storage.list("uploads/").await?;
    
    // Delete file
    storage.delete("uploads/old-file.txt").await?;
    
    // Get signed URL (for direct client access)
    let url = storage.presigned_url("uploads/file.txt", 3600).await?;
    
    Ok(Response::ok(json!({"url": url})))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="service-configuration"><a class="header" href="#service-configuration">Service Configuration</a></h2>
<p>Services are configured in the Admin UI or via the Management API. Each service has a unique name that you use to access it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These names come from your service configuration
let main_db = ctx.database("main-db").await?;
let read_replica = ctx.database("read-replica").await?;
let session_cache = ctx.cache("sessions").await?;
let file_storage = ctx.storage("uploads").await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Service operations return <code>Result</code> types that can be used with <code>?</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // Service errors are automatically converted to HandlerError
    let db = ctx.database("main-db").await?;
    let users = db.query("SELECT * FROM users", &amp;[]).await?;
    
    Ok(Response::ok(json!({"users": users})))
}
<span class="boring">}</span></code></pre></pre>
<p>Common error types:</p>
<ul>
<li><code>ServiceNotFound</code> - The named service doesn't exist</li>
<li><code>ConnectionError</code> - Failed to connect to the service</li>
<li><code>QueryError</code> - Database query failed</li>
<li><code>StorageError</code> - Storage operation failed</li>
</ul>
<h2 id="actor-based-architecture"><a class="header" href="#actor-based-architecture">Actor-Based Architecture</a></h2>
<p>Under the hood, services use an actor-based architecture:</p>
<ol>
<li><strong>Service Actors</strong> run as background tasks</li>
<li><strong>Handlers send messages</strong> to actors via channels</li>
<li><strong>Actors process requests</strong> and send responses back</li>
<li><strong>Connection pooling</strong> is handled automatically</li>
</ol>
<p>This provides:</p>
<ul>
<li><strong>Isolation</strong> - Service failures don't crash handlers</li>
<li><strong>Concurrency</strong> - Multiple handlers can share services safely</li>
<li><strong>Efficiency</strong> - Connection pools are reused across requests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request"><a class="header" href="#request">Request</a></h1>
<p>The <code>Request</code> struct represents an incoming HTTP request.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Request {
    pub method: String,
    pub path: String,
    pub query: HashMap&lt;String, String&gt;,
    pub headers: HashMap&lt;String, String&gt;,
    pub body: Option&lt;String&gt;,
    pub params: HashMap&lt;String, String&gt;,
    pub client_ip: Option&lt;String&gt;,
    pub request_id: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>method</code></td><td><code>String</code></td><td>HTTP method: GET, POST, PUT, DELETE, PATCH, etc.</td></tr>
<tr><td><code>path</code></td><td><code>String</code></td><td>Request path, e.g., <code>/users/123</code></td></tr>
<tr><td><code>query</code></td><td><code>HashMap&lt;String, String&gt;</code></td><td>Query parameters from the URL</td></tr>
<tr><td><code>headers</code></td><td><code>HashMap&lt;String, String&gt;</code></td><td>HTTP headers</td></tr>
<tr><td><code>body</code></td><td><code>Option&lt;String&gt;</code></td><td>Request body (for POST, PUT, PATCH)</td></tr>
<tr><td><code>params</code></td><td><code>HashMap&lt;String, String&gt;</code></td><td>Path parameters extracted from the route</td></tr>
<tr><td><code>client_ip</code></td><td><code>Option&lt;String&gt;</code></td><td>Client's IP address</td></tr>
<tr><td><code>request_id</code></td><td><code>String</code></td><td>Unique identifier for request tracing</td></tr>
</tbody></table>
</div>
<h2 id="methods-reference"><a class="header" href="#methods-reference">Methods Reference</a></h2>
<h3 id="json-parsing"><a class="header" href="#json-parsing">JSON Parsing</a></h3>
<h4 id="jsont---resultt-handlererror"><a class="header" href="#jsont---resultt-handlererror"><code>json&lt;T&gt;() -&gt; Result&lt;T, HandlerError&gt;</code></a></h4>
<p>Parse the body as JSON into a typed struct. Returns <code>HandlerError::BadRequest</code> on parse failure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let user: CreateUser = req.json()?;  // Uses ? operator naturally
    Ok(Response::ok(json!({"name": user.name})))
}

handler_loop_result!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="query-parameters-1"><a class="header" href="#query-parameters-1">Query Parameters</a></h3>
<h4 id="query_paramkey-str---optionstring"><a class="header" href="#query_paramkey-str---optionstring"><code>query_param(key: &amp;str) -&gt; Option&lt;&amp;String&gt;</code></a></h4>
<p>Get a query parameter as a string reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// URL: /search?q=rust
let query = req.query_param("q"); // Some(&amp;"rust".to_string())
<span class="boring">}</span></code></pre></pre>
<h4 id="query_param_ast-fromstrkey-str---optiont"><a class="header" href="#query_param_ast-fromstrkey-str---optiont"><code>query_param_as&lt;T: FromStr&gt;(key: &amp;str) -&gt; Option&lt;T&gt;</code></a></h4>
<p>Get a query parameter parsed as a specific type. Returns <code>None</code> if missing or can't be parsed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// URL: /items?page=2&amp;limit=10
let page: i64 = req.query_param_as("page").unwrap_or(1);
let limit: usize = req.query_param_as("limit").unwrap_or(20);
let active: bool = req.query_param_as("active").unwrap_or(false);
<span class="boring">}</span></code></pre></pre>
<h4 id="require_query_paramt-fromstrkey-str---resultt-handlererror"><a class="header" href="#require_query_paramt-fromstrkey-str---resultt-handlererror"><code>require_query_param&lt;T: FromStr&gt;(key: &amp;str) -&gt; Result&lt;T, HandlerError&gt;</code></a></h4>
<p>Get a required query parameter. Returns <code>HandlerError::BadRequest</code> if missing or invalid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let page: i64 = req.require_query_param("page")?;
    let limit: usize = req.require_query_param("limit")?;
    Ok(Response::ok(json!({"page": page, "limit": limit})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="path-parameters-1"><a class="header" href="#path-parameters-1">Path Parameters</a></h3>
<h4 id="path_paramkey-str---optionstring"><a class="header" href="#path_paramkey-str---optionstring"><code>path_param(key: &amp;str) -&gt; Option&lt;&amp;String&gt;</code></a></h4>
<p>Get a path parameter extracted from the route pattern.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Endpoint path: /users/{id}/posts/{post_id}
// Request: /users/123/posts/456

let user_id = req.path_param("id");       // Some(&amp;"123".to_string())
let post_id = req.path_param("post_id");  // Some(&amp;"456".to_string())
<span class="boring">}</span></code></pre></pre>
<h4 id="path_param_ast-fromstrkey-str---optiont"><a class="header" href="#path_param_ast-fromstrkey-str---optiont"><code>path_param_as&lt;T: FromStr&gt;(key: &amp;str) -&gt; Option&lt;T&gt;</code></a></h4>
<p>Get a path parameter parsed as a specific type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Route: /users/{id}
let user_id: i64 = req.path_param_as("id").unwrap_or(0);
let uuid: Uuid = req.path_param_as("id").ok_or(HandlerError::BadRequest("Invalid UUID".into()))?;
<span class="boring">}</span></code></pre></pre>
<h4 id="require_path_paramt-fromstrkey-str---resultt-handlererror"><a class="header" href="#require_path_paramt-fromstrkey-str---resultt-handlererror"><code>require_path_param&lt;T: FromStr&gt;(key: &amp;str) -&gt; Result&lt;T, HandlerError&gt;</code></a></h4>
<p>Get a required path parameter. Returns <code>HandlerError::BadRequest</code> if missing or invalid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let user_id: i64 = req.require_path_param("id")?;
    Ok(Response::ok(json!({"user_id": user_id})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="headers-1"><a class="header" href="#headers-1">Headers</a></h3>
<h4 id="headerkey-str---optionstring"><a class="header" href="#headerkey-str---optionstring"><code>header(key: &amp;str) -&gt; Option&lt;&amp;String&gt;</code></a></h4>
<p>Get a header value (case-insensitive lookup).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All of these work:
let auth = req.header("Authorization");
let auth = req.header("authorization");
let auth = req.header("AUTHORIZATION");
<span class="boring">}</span></code></pre></pre>
<h4 id="require_headerkey-str---resultstring-handlererror"><a class="header" href="#require_headerkey-str---resultstring-handlererror"><code>require_header(key: &amp;str) -&gt; Result&lt;&amp;String, HandlerError&gt;</code></a></h4>
<p>Get a required header. Returns <code>HandlerError::BadRequest</code> if missing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let auth = req.require_header("Authorization")?;
    let api_key = req.require_header("X-API-Key")?;
    Ok(Response::ok(json!({"authenticated": true})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="request-inspection"><a class="header" href="#request-inspection">Request Inspection</a></h3>
<h4 id="is_methodmethod-str---bool"><a class="header" href="#is_methodmethod-str---bool"><code>is_method(method: &amp;str) -&gt; bool</code></a></h4>
<p>Check if the request method matches (case-insensitive).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if req.is_method("POST") {
    // Handle POST
}
<span class="boring">}</span></code></pre></pre>
<h4 id="content_type---optionstring"><a class="header" href="#content_type---optionstring"><code>content_type() -&gt; Option&lt;&amp;String&gt;</code></a></h4>
<p>Get the Content-Type header value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(ct) = req.content_type() {
    eprintln!("Content-Type: {}", ct);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="is_json---bool"><a class="header" href="#is_json---bool"><code>is_json() -&gt; bool</code></a></h4>
<p>Check if the request has a JSON content type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if req.is_json() {
    let data: MyStruct = req.json()?;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="is_multipart---bool"><a class="header" href="#is_multipart---bool"><code>is_multipart() -&gt; bool</code></a></h4>
<p>Check if the request has a multipart/form-data content type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if req.is_multipart() {
    let multipart = req.multipart()?;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="body_bytes---vecu8"><a class="header" href="#body_bytes---vecu8"><code>body_bytes() -&gt; Vec&lt;u8&gt;</code></a></h4>
<p>Get the raw body as bytes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let raw_body = req.body_bytes();
<span class="boring">}</span></code></pre></pre>
<h3 id="multipart-form-data"><a class="header" href="#multipart-form-data">Multipart Form Data</a></h3>
<h4 id="multipart---resultmultipartdata-handlererror"><a class="header" href="#multipart---resultmultipartdata-handlererror"><code>multipart() -&gt; Result&lt;MultipartData, HandlerError&gt;</code></a></h4>
<p>Parse multipart/form-data body for file uploads.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let multipart = req.multipart()?;

    // Get text fields
    let title = multipart.require_field("title")?;
    let description = multipart.field("description").unwrap_or(&amp;"".to_string());

    // Get uploaded file
    let file = multipart.require_file("upload")?;
    eprintln!("Received file: {} ({} bytes)", file.filename, file.data.len());

    Ok(Response::ok(json!({
        "title": title,
        "filename": file.filename,
        "size": file.data.len()
    })))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multipartdata"><a class="header" href="#multipartdata">MultipartData</a></h2>
<h3 id="fields-1"><a class="header" href="#fields-1">Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>fields</code></td><td><code>HashMap&lt;String, String&gt;</code></td><td>Text form fields</td></tr>
<tr><td><code>files</code></td><td><code>HashMap&lt;String, MultipartFile&gt;</code></td><td>Uploaded files</td></tr>
</tbody></table>
</div>
<h3 id="methods"><a class="header" href="#methods">Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>field(name)</code></td><td><code>Option&lt;&amp;String&gt;</code></td><td>Get a text field</td></tr>
<tr><td><code>require_field(name)</code></td><td><code>Result&lt;&amp;String, HandlerError&gt;</code></td><td>Get required text field</td></tr>
<tr><td><code>file(name)</code></td><td><code>Option&lt;&amp;MultipartFile&gt;</code></td><td>Get an uploaded file</td></tr>
<tr><td><code>require_file(name)</code></td><td><code>Result&lt;&amp;MultipartFile, HandlerError&gt;</code></td><td>Get required file</td></tr>
</tbody></table>
</div>
<h2 id="multipartfile"><a class="header" href="#multipartfile">MultipartFile</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MultipartFile {
    pub filename: String,      // Original filename
    pub content_type: String,  // MIME type
    pub data: Vec&lt;u8&gt;,         // File content
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[derive(Deserialize)]
struct UpdateProfile {
    name: Option&lt;String&gt;,
    bio: Option&lt;String&gt;,
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // Log request info
    eprintln!("[{}] {} {} from {:?}",
        req.request_id, req.method, req.path, req.client_ip);

    // Check authentication
    let token = req.require_header("Authorization")?;

    // Get path parameter (typed)
    let user_id: i64 = req.require_path_param("id")?;

    // Parse body
    let update: UpdateProfile = req.json()?;

    // Process request...
    Ok(Response::ok(json!({
        "user_id": user_id,
        "updated": true,
    })))
}

handler_loop_result!(handle);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="response"><a class="header" href="#response">Response</a></h1>
<p>The <code>Response</code> struct represents an outgoing HTTP response.</p>
<h2 id="quick-reference-1"><a class="header" href="#quick-reference-1">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Status</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>ok(body)</code></td><td>200</td><td>Successful GET/PUT</td></tr>
<tr><td><code>created(body)</code></td><td>201</td><td>Successful POST</td></tr>
<tr><td><code>accepted(body)</code></td><td>202</td><td>Async operation started</td></tr>
<tr><td><code>no_content()</code></td><td>204</td><td>Successful DELETE</td></tr>
<tr><td><code>bad_request(msg)</code></td><td>400</td><td>Invalid input</td></tr>
<tr><td><code>unauthorized(msg)</code></td><td>401</td><td>Missing/invalid auth</td></tr>
<tr><td><code>forbidden(msg)</code></td><td>403</td><td>Not authorized</td></tr>
<tr><td><code>not_found()</code></td><td>404</td><td>Resource not found</td></tr>
<tr><td><code>conflict(msg)</code></td><td>409</td><td>Resource conflict</td></tr>
<tr><td><code>internal_error(msg)</code></td><td>500</td><td>Server error</td></tr>
<tr><td><code>service_unavailable(msg)</code></td><td>503</td><td>Backend down</td></tr>
</tbody></table>
</div>
<h2 id="definition-1"><a class="header" href="#definition-1">Definition</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Response {
    pub status: u16,
    pub headers: HashMap&lt;String, String&gt;,
    pub body: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="constructor-methods"><a class="header" href="#constructor-methods">Constructor Methods</a></h2>
<h3 id="newstatus-u16"><a class="header" href="#newstatus-u16"><code>new(status: u16)</code></a></h3>
<p>Create a response with just a status code (no body).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::new(204)  // 204 No Content
Response::new(301).with_header("Location", "/new-path")
<span class="boring">}</span></code></pre></pre>
<h3 id="okt-serializebody-t"><a class="header" href="#okt-serializebody-t"><code>ok&lt;T: Serialize&gt;(body: T)</code></a></h3>
<p>Create a 200 OK response with JSON body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(json!({"message": "Success"}))
Response::ok(my_struct)  // If my_struct implements Serialize
<span class="boring">}</span></code></pre></pre>
<h3 id="jsont-serializestatus-u16-body-t"><a class="header" href="#jsont-serializestatus-u16-body-t"><code>json&lt;T: Serialize&gt;(status: u16, body: T)</code></a></h3>
<p>Create a JSON response with a custom status code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::json(201, json!({"id": "new-id"}))
Response::json(400, json!({"error": "Invalid input"}))
<span class="boring">}</span></code></pre></pre>
<h3 id="textstatus-u16-body-impl-intostring"><a class="header" href="#textstatus-u16-body-impl-intostring"><code>text(status: u16, body: impl Into&lt;String&gt;)</code></a></h3>
<p>Create a plain text response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::text(200, "Hello, World!")
Response::text(500, "Internal Server Error")
<span class="boring">}</span></code></pre></pre>
<h3 id="htmlstatus-u16-body-impl-intostring"><a class="header" href="#htmlstatus-u16-body-impl-intostring"><code>html(status: u16, body: impl Into&lt;String&gt;)</code></a></h3>
<p>Create an HTML response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::html(200, "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;")
<span class="boring">}</span></code></pre></pre>
<h3 id="binarystatus-u16-data-impl-asrefu8-content_type-impl-intostring"><a class="header" href="#binarystatus-u16-data-impl-asrefu8-content_type-impl-intostring"><code>binary(status: u16, data: impl AsRef&lt;[u8]&gt;, content_type: impl Into&lt;String&gt;)</code></a></h3>
<p>Create a binary response for files, images, etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Serve an image
Response::binary(200, image_bytes, "image/png")

// Serve a PDF with download prompt
Response::binary(200, pdf_bytes, "application/pdf")
    .with_header("Content-Disposition", "attachment; filename=\"report.pdf\"")

// Inline image
Response::binary(200, jpeg_bytes, "image/jpeg")
    .with_header("Content-Disposition", "inline; filename=\"photo.jpg\"")
<span class="boring">}</span></code></pre></pre>
<h3 id="createdt-serializebody-t"><a class="header" href="#createdt-serializebody-t"><code>created&lt;T: Serialize&gt;(body: T)</code></a></h3>
<p>Create a 201 Created response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::created(json!({"id": "12345", "name": "New Resource"}))
<span class="boring">}</span></code></pre></pre>
<h3 id="acceptedt-serializebody-t"><a class="header" href="#acceptedt-serializebody-t"><code>accepted&lt;T: Serialize&gt;(body: T)</code></a></h3>
<p>Create a 202 Accepted response (for async operations).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::accepted(json!({"job_id": "abc123", "status": "processing"}))
<span class="boring">}</span></code></pre></pre>
<h3 id="no_content"><a class="header" href="#no_content"><code>no_content()</code></a></h3>
<p>Create a 204 No Content response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::no_content()  // Used for DELETE
<span class="boring">}</span></code></pre></pre>
<h3 id="redirectstatus-u16-location-impl-intostring"><a class="header" href="#redirectstatus-u16-location-impl-intostring"><code>redirect(status: u16, location: impl Into&lt;String&gt;)</code></a></h3>
<p>Create a redirect response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::redirect(302, "https://example.com/new-location")
Response::redirect(301, "/permanent-new-path")
<span class="boring">}</span></code></pre></pre>
<h2 id="error-response-helpers"><a class="header" href="#error-response-helpers">Error Response Helpers</a></h2>
<h3 id="bad_requestmessage-impl-intostring"><a class="header" href="#bad_requestmessage-impl-intostring"><code>bad_request(message: impl Into&lt;String&gt;)</code></a></h3>
<p>400 Bad Request.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::bad_request("Missing required field: email")
<span class="boring">}</span></code></pre></pre>
<h3 id="unauthorizedmessage-impl-intostring"><a class="header" href="#unauthorizedmessage-impl-intostring"><code>unauthorized(message: impl Into&lt;String&gt;)</code></a></h3>
<p>401 Unauthorized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::unauthorized("Invalid or expired token")
<span class="boring">}</span></code></pre></pre>
<h3 id="forbiddenmessage-impl-intostring"><a class="header" href="#forbiddenmessage-impl-intostring"><code>forbidden(message: impl Into&lt;String&gt;)</code></a></h3>
<p>403 Forbidden.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::forbidden("You don't have permission to access this resource")
<span class="boring">}</span></code></pre></pre>
<h3 id="not_found--not_found_msgmessage"><a class="header" href="#not_found--not_found_msgmessage"><code>not_found()</code> / <code>not_found_msg(message)</code></a></h3>
<p>404 Not Found.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::not_found()
Response::not_found_msg("User with ID 123 not found")
<span class="boring">}</span></code></pre></pre>
<h3 id="conflictmessage-impl-intostring"><a class="header" href="#conflictmessage-impl-intostring"><code>conflict(message: impl Into&lt;String&gt;)</code></a></h3>
<p>409 Conflict.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::conflict("A user with this email already exists")
<span class="boring">}</span></code></pre></pre>
<h3 id="internal_errormessage-impl-intostring"><a class="header" href="#internal_errormessage-impl-intostring"><code>internal_error(message: impl Into&lt;String&gt;)</code></a></h3>
<p>500 Internal Server Error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::internal_error("Database connection failed")
<span class="boring">}</span></code></pre></pre>
<h3 id="service_unavailablemessage-impl-intostring"><a class="header" href="#service_unavailablemessage-impl-intostring"><code>service_unavailable(message: impl Into&lt;String&gt;)</code></a></h3>
<p>503 Service Unavailable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::service_unavailable("Database is currently unavailable")
<span class="boring">}</span></code></pre></pre>
<h2 id="builder-methods"><a class="header" href="#builder-methods">Builder Methods</a></h2>
<h3 id="with_headerkey-value"><a class="header" href="#with_headerkey-value"><code>with_header(key, value)</code></a></h3>
<p>Add a header to the response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(json!({"data": "value"}))
    .with_header("Cache-Control", "max-age=3600")
    .with_header("X-Custom-Header", "custom-value")
<span class="boring">}</span></code></pre></pre>
<h3 id="with_bodybody-impl-intostring"><a class="header" href="#with_bodybody-impl-intostring"><code>with_body(body: impl Into&lt;String&gt;)</code></a></h3>
<p>Set or replace the response body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::new(200)
    .with_header("Content-Type", "text/html")
    .with_body("&lt;html&gt;&lt;body&gt;Hello!&lt;/body&gt;&lt;/html&gt;")
<span class="boring">}</span></code></pre></pre>
<h3 id="with_corsorigin-impl-intostring"><a class="header" href="#with_corsorigin-impl-intostring"><code>with_cors(origin: impl Into&lt;String&gt;)</code></a></h3>
<p>Add CORS headers for cross-origin requests.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(data).with_cors("*")
Response::ok(data).with_cors("https://myapp.com")
<span class="boring">}</span></code></pre></pre>
<h3 id="with_cachemax_age_seconds-u32"><a class="header" href="#with_cachemax_age_seconds-u32"><code>with_cache(max_age_seconds: u32)</code></a></h3>
<p>Add caching headers.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Response::ok(data).with_cache(3600)  // Cache for 1 hour
Response::ok(data).with_cache(0)     // No cache
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="restful-api"><a class="header" href="#restful-api">RESTful API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET /items - List items
Response::ok(json!({"items": items}))

// GET /items/{id} - Get single item
Response::ok(item)  // or Response::not_found()

// POST /items - Create item
Response::created(json!({"id": new_id, ...item}))

// PUT /items/{id} - Update item
Response::ok(updated_item)

// DELETE /items/{id} - Delete item
Response::no_content()
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-with-result"><a class="header" href="#error-handling-with-result">Error Handling with Result</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let user = find_user(&amp;req)?;  // Returns 404 if not found
    Ok(Response::ok(user))
}

handler_loop_result!(handle);  // Errors auto-convert to Response
<span class="boring">}</span></code></pre></pre>
<h3 id="file-uploads-response"><a class="header" href="#file-uploads-response">File Uploads Response</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_upload(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let multipart = req.multipart()?;
    let file = multipart.require_file("document")?;

    // Process file...
    let saved_id = save_to_storage(&amp;file.data)?;

    Ok(Response::created(json!({
        "id": saved_id,
        "filename": file.filename,
        "size": file.data.len(),
        "content_type": file.content_type
    })))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="serving-files"><a class="header" href="#serving-files">Serving Files</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn serve_image(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let id = req.require_path_param::&lt;String&gt;("id")?;
    let image_data = load_image(&amp;id)?;

    Ok(Response::binary(200, image_data, "image/png")
        .with_cache(86400)  // Cache for 1 day
        .with_header("Content-Disposition", format!("inline; filename=\"{}.png\"", id)))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-content-types"><a class="header" href="#custom-content-types">Custom Content Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// XML
Response::new(200)
    .with_header("Content-Type", "application/xml")
    .with_body("&lt;root&gt;&lt;item&gt;Value&lt;/item&gt;&lt;/root&gt;")

// CSV with download
Response::new(200)
    .with_header("Content-Type", "text/csv")
    .with_header("Content-Disposition", "attachment; filename=\"data.csv\"")
    .with_body("id,name\n1,Alice\n2,Bob")
<span class="boring">}</span></code></pre></pre>
<h3 id="cors-preflight"><a class="header" href="#cors-preflight">CORS Preflight</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    if req.is_method("OPTIONS") {
        return Response::no_content()
            .with_cors("*")
            .with_header("Access-Control-Max-Age", "86400");
    }

    // Handle actual request...
    Response::ok(data).with_cors("*")
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h1>
<p>The SDK provides a <code>HandlerError</code> enum for structured error handling with automatic HTTP status code mapping.</p>
<h2 id="quick-reference-2"><a class="header" href="#quick-reference-2">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Status</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>BadRequest(msg)</code></td><td>400</td><td>Invalid input, malformed JSON</td></tr>
<tr><td><code>ValidationError(msg)</code></td><td>400</td><td>Semantic validation failures</td></tr>
<tr><td><code>Unauthorized(msg)</code></td><td>401</td><td>Missing or invalid auth</td></tr>
<tr><td><code>Forbidden(msg)</code></td><td>403</td><td>Authenticated but not authorized</td></tr>
<tr><td><code>NotFound</code> / <code>NotFoundMessage(msg)</code></td><td>404</td><td>Resource not found</td></tr>
<tr><td><code>MethodNotAllowed(msg)</code></td><td>405</td><td>Wrong HTTP method</td></tr>
<tr><td><code>Conflict(msg)</code></td><td>409</td><td>Resource conflict (duplicate)</td></tr>
<tr><td><code>PayloadTooLarge(msg)</code></td><td>413</td><td>Request body too large</td></tr>
<tr><td><code>Internal(msg)</code> / <code>InternalError(msg)</code></td><td>500</td><td>Server error</td></tr>
<tr><td><code>DatabaseError(msg)</code></td><td>500</td><td>Database operation failed</td></tr>
<tr><td><code>StorageError(msg)</code></td><td>500</td><td>Storage operation failed</td></tr>
<tr><td><code>ServiceUnavailable(msg)</code></td><td>503</td><td>Backend service down</td></tr>
</tbody></table>
</div>
<h2 id="handlererror-definition"><a class="header" href="#handlererror-definition">HandlerError Definition</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum HandlerError {
    // 4xx Client Errors
    BadRequest(String),
    ValidationError(String),
    Unauthorized(String),
    Forbidden(String),
    NotFound,
    NotFoundMessage(String),
    MethodNotAllowed(String),
    Conflict(String),
    PayloadTooLarge(String),

    // 5xx Server Errors
    IpcError(String),
    SerializationError(serde_json::Error),
    DatabaseError(String),
    RedisError(String),
    StorageError(String),
    InternalError(String),
    Internal(String),
    ServiceUnavailable(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="automatic-response-conversion"><a class="header" href="#automatic-response-conversion">Automatic Response Conversion</a></h3>
<p><code>HandlerError</code> implements <code>From&lt;HandlerError&gt; for Response</code>, so you can use <code>.into()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    match process(&amp;req) {
        Ok(data) =&gt; Response::ok(data),
        Err(e) =&gt; e.into(),  // Automatically converts to Response
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="use-with-handler_loop_result"><a class="header" href="#use-with-handler_loop_result">Use with handler_loop_result!</a></h3>
<p>The <code>handler_loop_result!</code> macro automatically converts errors to responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let data: MyInput = req.json()?;  // BadRequest on parse failure
    let id: i64 = req.require_path_param("id")?;  // BadRequest if missing
    let auth = req.require_header("Authorization")?;  // BadRequest if missing

    Ok(Response::ok(json!({"id": id, "data": data})))
}

handler_loop_result!(handle);  // Errors auto-convert to HTTP responses
<span class="boring">}</span></code></pre></pre>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<h3 id="status_code---u16"><a class="header" href="#status_code---u16"><code>status_code() -&gt; u16</code></a></h3>
<p>Get the HTTP status code for this error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err = HandlerError::NotFound;
assert_eq!(err.status_code(), 404);

let err = HandlerError::BadRequest("Invalid input".into());
assert_eq!(err.status_code(), 400);
<span class="boring">}</span></code></pre></pre>
<h3 id="to_response---response"><a class="header" href="#to_response---response"><code>to_response() -&gt; Response</code></a></h3>
<p>Convert the error to an HTTP Response:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let err = HandlerError::ValidationError("Invalid email".to_string());
let response = err.to_response();
// Response { status: 400, body: {"error": "Validation error: Invalid email"} }
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<h3 id="clean-result-based-handlers"><a class="header" href="#clean-result-based-handlers">Clean Result-Based Handlers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[derive(Deserialize)]
struct CreateUser {
    email: String,
    name: String,
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // Parse body - returns BadRequest on failure
    let body: CreateUser = req.json()?;

    // Validate
    if body.email.is_empty() {
        return Err(HandlerError::ValidationError("Email is required".into()));
    }

    // Check authentication
    let token = req.require_header("Authorization")?;

    // Get typed path parameter
    let user_id: i64 = req.require_path_param("id")?;

    // Simulate database operation
    let user = find_user(user_id)
        .ok_or(HandlerError::NotFound)?;

    Ok(Response::ok(user))
}

handler_loop_result!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="converting-external-errors"><a class="header" href="#converting-external-errors">Converting External Errors</a></h3>
<p>Map external library errors to <code>HandlerError</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_to_database(data: &amp;MyData) -&gt; Result&lt;i64, HandlerError&gt; {
    let conn = get_connection()
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;

    let id = conn.insert(data)
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;

    Ok(id)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-error-types"><a class="header" href="#custom-error-types">Custom Error Types</a></h3>
<p>Define domain-specific errors and convert to <code>HandlerError</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum AppError {
    UserNotFound(String),
    DuplicateEmail,
    InvalidCredentials,
    RateLimited,
}

impl From&lt;AppError&gt; for HandlerError {
    fn from(e: AppError) -&gt; Self {
        match e {
            AppError::UserNotFound(id) =&gt;
                HandlerError::NotFoundMessage(format!("User {} not found", id)),
            AppError::DuplicateEmail =&gt;
                HandlerError::Conflict("Email already registered".into()),
            AppError::InvalidCredentials =&gt;
                HandlerError::Unauthorized("Invalid email or password".into()),
            AppError::RateLimited =&gt;
                HandlerError::ServiceUnavailable("Rate limit exceeded, try again later".into()),
        }
    }
}

fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let result = business_logic(&amp;req)
        .map_err(HandlerError::from)?;  // Convert AppError to HandlerError
    Ok(Response::ok(result))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="async-error-handling"><a class="header" href="#async-error-handling">Async Error Handling</a></h3>
<p>Works the same with async handlers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let data: CreateItem = req.json()?;

    let id = database.insert(&amp;data).await
        .map_err(|e| HandlerError::DatabaseError(e.to_string()))?;

    let uploaded = s3.put_object(&amp;data.file).await
        .map_err(|e| HandlerError::StorageError(e.to_string()))?;

    Ok(Response::created(json!({
        "id": id,
        "file_url": uploaded.url
    })))
}

handler_loop_async_result!(handle);
<span class="boring">}</span></code></pre></pre>
<h3 id="logging-errors"><a class="header" href="#logging-errors">Logging Errors</a></h3>
<p>Always log errors for debugging (logs go to stderr, captured by gateway):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    match process(&amp;req) {
        Ok(data) =&gt; Ok(Response::ok(data)),
        Err(e) =&gt; {
            eprintln!("[{}] Error: {} ({})",
                req.request_id,
                e,
                e.status_code()
            );
            Err(e)  // Will be converted to Response by handler_loop_result!
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Use <code>handler_loop_result!</code></strong> - Simplifies error handling with automatic conversion</li>
<li><strong>Use specific error variants</strong> - <code>BadRequest</code> vs <code>ValidationError</code> vs <code>Unauthorized</code></li>
<li><strong>Always log errors</strong> - Use <code>eprintln!</code> for debugging</li>
<li><strong>Convert early</strong> - Map external errors to <code>HandlerError</code> at the boundary</li>
<li><strong>Include context</strong> - Error messages should help debugging</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="services"><a class="header" href="#services">Services</a></h1>
<p>Rust Edge Gateway connects your handlers to backend services via Service Actors. Services are accessed through the Context API using an actor-based message-passing architecture.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Services are:</p>
<ol>
<li><strong>Configured</strong> in the Admin UI or via API</li>
<li><strong>Started as actors</strong> when the gateway launches</li>
<li><strong>Accessed via Context</strong> in your handler code</li>
<li><strong>Thread-safe</strong> through message-passing</li>
</ol>
<h2 id="available-service-types"><a class="header" href="#available-service-types">Available Service Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Service</th><th>Description</th><th>Use Cases</th></tr></thead><tbody>
<tr><td><strong>PostgreSQL</strong></td><td>Advanced relational database</td><td>Complex queries, transactions</td></tr>
<tr><td><strong>MySQL</strong></td><td>Popular relational database</td><td>Web applications, compatibility</td></tr>
<tr><td><strong>SQLite</strong></td><td>Embedded SQL database</td><td>Local data, caching, simple apps</td></tr>
<tr><td><strong>Redis</strong></td><td>In-memory data store</td><td>Caching, sessions, pub/sub</td></tr>
<tr><td><strong>MinIO/S3</strong></td><td>Object storage</td><td>File uploads, media storage</td></tr>
<tr><td><strong>FTP/SFTP</strong></td><td>File transfer protocols</td><td>File uploads, vendor integrations</td></tr>
<tr><td><strong>Email</strong></td><td>SMTP email sending</td><td>Notifications, alerts, reports</td></tr>
</tbody></table>
</div>
<h2 id="configuring-services"><a class="header" href="#configuring-services">Configuring Services</a></h2>
<h3 id="via-admin-ui"><a class="header" href="#via-admin-ui">Via Admin UI</a></h3>
<ol>
<li>Go to <strong>Services</strong> in the admin panel</li>
<li>Click <strong>Create Service</strong></li>
<li>Select service type and configure connection</li>
<li>Test the connection</li>
<li>Save the service</li>
</ol>
<h3 id="via-api"><a class="header" href="#via-api">Via API</a></h3>
<pre><code class="language-bash">curl -X POST http://localhost:9081/api/services \
  -H "Content-Type: application/json" \
  -d '{
    "name": "main-db",
    "service_type": "postgres",
    "config": {
      "host": "db.example.com",
      "port": 5432,
      "database": "myapp",
      "username": "app_user",
      "password": "secret",
      "pool_size": 10
    }
  }'
</code></pre>
<h2 id="using-services-in-handlers"><a class="header" href="#using-services-in-handlers">Using Services in Handlers</a></h2>
<p>Services are accessed through the Context:</p>
<h3 id="database-example"><a class="header" href="#database-example">Database Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let db = ctx.database("main-db").await?;

    // Query with parameters
    let users = db.query(
        "SELECT id, name FROM users WHERE active = $1",
        &amp;[&amp;true]
    ).await?;

    Ok(Response::ok(json!({"users": users})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cache-example"><a class="header" href="#cache-example">Cache Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let cache = ctx.cache("redis").await?;

    // Try cache first
    if let Some(cached) = cache.get("user:123").await? {
        return Ok(Response::ok(json!({"source": "cache", "data": cached})));
    }

    // Cache miss - fetch from database
    let db = ctx.database("main-db").await?;
    let user = db.query_one("SELECT * FROM users WHERE id = $1", &amp;[&amp;123]).await?;

    // Store in cache (TTL in seconds)
    cache.set("user:123", &amp;user, 300).await?;

    Ok(Response::ok(json!({"source": "db", "data": user})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="storage-example"><a class="header" href="#storage-example">Storage Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let storage = ctx.storage("s3").await?;

    // Upload file
    let data = req.body_bytes();
    storage.put("uploads/file.txt", data).await?;

    // Get presigned URL for client download
    let url = storage.presigned_url("uploads/file.txt", 3600).await?;

    Ok(Response::ok(json!({"download_url": url})))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="actor-based-architecture-1"><a class="header" href="#actor-based-architecture-1">Actor-Based Architecture</a></h2>
<p>Services use the actor pattern for thread-safety:</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler  â”‚â”€â”€â”€â”€â–¶â”‚   Channel   â”‚â”€â”€â”€â”€â–¶â”‚ Service Actorâ”‚
â”‚          â”‚     â”‚  (command)  â”‚     â”‚              â”‚
â”‚          â”‚â—€â”€â”€â”€â”€â”‚  (response) â”‚â—€â”€â”€â”€â”€â”‚  (owns pool) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>Benefits:</p>
<ul>
<li><strong>Thread-safe</strong> - No shared mutable state</li>
<li><strong>Isolated</strong> - Actor failures don't crash handlers</li>
<li><strong>Efficient</strong> - Connection pools are reused</li>
<li><strong>Backpressure</strong> - Channel buffers prevent overload</li>
</ul>
<h2 id="service-names"><a class="header" href="#service-names">Service Names</a></h2>
<p>Services are identified by name in your handler code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These names come from your service configuration
let main_db = ctx.database("main-db").await?;
let read_replica = ctx.database("read-replica").await?;
let session_cache = ctx.cache("sessions").await?;
let file_storage = ctx.storage("uploads").await?;
<span class="boring">}</span></code></pre></pre>
<p>This allows the same handler code to use different service instances in different environments.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="sdk/./context.html">Context API</a> - Full Context reference</li>
<li><a href="sdk/./services/database.html">Database Service Details</a></li>
<li><a href="sdk/./services/redis.html">Cache (Redis) Details</a></li>
<li><a href="sdk/./services/storage.html">Storage Details</a></li>
<li><a href="sdk/../architecture/service-actors.html">Architecture: Service Actors</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-abstraction"><a class="header" href="#storage-abstraction">Storage Abstraction</a></h1>
<p>A unified interface for storing data across different backends.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The <code>Storage</code> type provides a single API that works with:</p>
<ul>
<li><strong>Database backends</strong> - SQLite, PostgreSQL, MySQL</li>
<li><strong>Object storage</strong> - MinIO, S3-compatible storage</li>
<li><strong>File storage</strong> - FTP, FTPS, SFTP</li>
</ul>
<p>This allows you to write handler code once and deploy it with different backends.</p>
<h2 id="creating-a-storage-instance"><a class="header" href="#creating-a-storage-instance">Creating a Storage Instance</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

// Database storage (SQLite, PostgreSQL, MySQL)
let db_storage = Storage::database("my-db-pool", "my_table");

// Object storage (MinIO, S3)
let obj_storage = Storage::object_storage("my-minio-pool", "data/items");

// File storage (FTP, SFTP)
let file_storage = Storage::file_storage("my-ftp-pool", "/data/items");
<span class="boring">}</span></code></pre></pre>
<h2 id="storage-operations"><a class="header" href="#storage-operations">Storage Operations</a></h2>
<h3 id="get-by-id"><a class="header" href="#get-by-id">Get by ID</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let storage = Storage::database("pool", "users");

match storage.get("user-123") {
    Ok(Some(user)) =&gt; {
        // user is a JsonValue
        println!("Found: {}", user["name"]);
    }
    Ok(None) =&gt; {
        println!("Not found");
    }
    Err(e) =&gt; {
        eprintln!("Error: {}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="list-records"><a class="header" href="#list-records">List Records</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// List all
let all_items = storage.list(None)?;

// List with filter (interpreted based on backend)
// For databases: WHERE status = ?
// For files: filter by filename pattern
let filtered = storage.list(Some("active"))?;
<span class="boring">}</span></code></pre></pre>
<h3 id="create-record"><a class="header" href="#create-record">Create Record</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = json!({
    "name": "Widget",
    "price": 29.99,
    "in_stock": true
});

storage.create("item-001", &amp;item)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="update-record"><a class="header" href="#update-record">Update Record</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let updated = json!({
    "name": "Widget Pro",
    "price": 39.99,
    "in_stock": true
});

storage.update("item-001", &amp;updated)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="delete-record"><a class="header" href="#delete-record">Delete Record</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match storage.delete("item-001")? {
    true =&gt; println!("Deleted"),
    false =&gt; println!("Not found"),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="backend-behavior"><a class="header" href="#backend-behavior">Backend Behavior</a></h2>
<h3 id="database-sqlite-postgresql-mysql"><a class="header" href="#database-sqlite-postgresql-mysql">Database (SQLite, PostgreSQL, MySQL)</a></h3>
<ul>
<li>Records stored as table rows</li>
<li><code>table_name</code> specifies the table</li>
<li>Filter parameter used in <code>WHERE status = ?</code></li>
<li>Requires table to exist with proper schema</li>
</ul>
<h3 id="object-storage-minio-s3"><a class="header" href="#object-storage-minio-s3">Object Storage (MinIO, S3)</a></h3>
<ul>
<li>Records stored as JSON files</li>
<li>Path: <code>{base_path}/{id}.json</code></li>
<li>Filter parameter passed to listing API</li>
<li>Automatically creates bucket if needed</li>
</ul>
<h3 id="file-storage-ftp-sftp"><a class="header" href="#file-storage-ftp-sftp">File Storage (FTP, SFTP)</a></h3>
<ul>
<li>Records stored as JSON files</li>
<li>Path: <code>{base_path}/{id}.json</code></li>
<li>Filter parameter filters file listing</li>
<li>Directory must exist on server</li>
</ul>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn get_storage() -&gt; Storage {
    // Change this to switch backends:
    // Storage::database("pool", "items")
    // Storage::object_storage("minio", "items")
    Storage::file_storage("ftp", "/data/items")
}

fn handle(req: Request) -&gt; Response {
    let storage = get_storage();
    
    match req.method.as_str() {
        "GET" =&gt; {
            if let Some(id) = req.path_param("id") {
                // Get single item
                match storage.get(id) {
                    Ok(Some(item)) =&gt; Response::ok(item),
                    Ok(None) =&gt; Response::not_found(),
                    Err(e) =&gt; e.to_response(),
                }
            } else {
                // List all items
                match storage.list(req.query_param("status").map(|s| s.as_str())) {
                    Ok(items) =&gt; Response::ok(json!({"items": items})),
                    Err(e) =&gt; e.to_response(),
                }
            }
        }
        "POST" =&gt; {
            let data: JsonValue = req.json().unwrap();
            let id = format!("item-{}", generate_id());
            match storage.create(&amp;id, &amp;data) {
                Ok(()) =&gt; Response::created(json!({"id": id})),
                Err(e) =&gt; e.to_response(),
            }
        }
        _ =&gt; Response::json(405, json!({"error": "Method not allowed"}))
    }
}

handler_loop!(handle);
<span class="boring">}</span></code></pre></pre>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="sdk/services/../examples/petstore.html">Pet Store Demo</a> - Complete example using Storage</li>
<li><a href="sdk/services/./database.html">Database Services</a> - Direct database access</li>
<li><a href="sdk/services/./ftp.html">FTP Services</a> - FTP/SFTP configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-service"><a class="header" href="#database-service">Database Service</a></h1>
<p>Connect to SQL databases (PostgreSQL, MySQL, SQLite) from your handlers.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h3>
<pre><code class="language-json">{
  "service_type": "postgres",
  "config": {
    "host": "localhost",
    "port": 5432,
    "database": "myapp",
    "username": "app_user",
    "password": "secret",
    "ssl_mode": "prefer",
    "pool_size": 10
  }
}
</code></pre>
<h3 id="mysql"><a class="header" href="#mysql">MySQL</a></h3>
<pre><code class="language-json">{
  "service_type": "mysql",
  "config": {
    "host": "localhost",
    "port": 3306,
    "database": "myapp",
    "username": "app_user",
    "password": "secret",
    "use_ssl": false,
    "pool_size": 10
  }
}
</code></pre>
<h3 id="sqlite"><a class="header" href="#sqlite">SQLite</a></h3>
<pre><code class="language-json">{
  "service_type": "sqlite",
  "config": {
    "path": "/data/app.db",
    "create_if_missing": true
  }
}
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="basic-query"><a class="header" href="#basic-query">Basic Query</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let db = DbPool { pool_id: "main".to_string() };
    
    let result = db.query("SELECT * FROM users WHERE active = ?", &amp;["true"]);
    
    match result {
        Ok(data) =&gt; Response::ok(json!({"users": data.rows})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="query-with-parameters"><a class="header" href="#query-with-parameters">Query with Parameters</a></h3>
<p>Always use parameterized queries to prevent SQL injection:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD - parameterized
db.query("SELECT * FROM users WHERE id = ?", &amp;[&amp;user_id])

// BAD - string concatenation (SQL injection risk!)
// db.query(&amp;format!("SELECT * FROM users WHERE id = {}", user_id), &amp;[])
<span class="boring">}</span></code></pre></pre>
<h3 id="insert-update-delete"><a class="header" href="#insert-update-delete">Insert, Update, Delete</a></h3>
<p>Use <code>execute</code> for statements that modify data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_user(db: &amp;DbPool, name: &amp;str, email: &amp;str) -&gt; Result&lt;u64, HandlerError&gt; {
    db.execute(
        "INSERT INTO users (name, email) VALUES (?, ?)",
        &amp;[name, email]
    )
}

fn update_user(db: &amp;DbPool, id: &amp;str, name: &amp;str) -&gt; Result&lt;u64, HandlerError&gt; {
    db.execute(
        "UPDATE users SET name = ? WHERE id = ?",
        &amp;[name, id]
    )
}

fn delete_user(db: &amp;DbPool, id: &amp;str) -&gt; Result&lt;u64, HandlerError&gt; {
    db.execute("DELETE FROM users WHERE id = ?", &amp;[id])
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-results"><a class="header" href="#working-with-results">Working with Results</a></h3>
<p>The <code>DbResult</code> contains rows as JSON objects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = db.query("SELECT id, name, email FROM users", &amp;[])?;

// result.rows is Vec&lt;HashMap&lt;String, Value&gt;&gt;
for row in &amp;result.rows {
    let id = row.get("id");
    let name = row.get("name");
    println!("User: {:?} - {:?}", id, name);
}

// Or serialize the whole result
Response::ok(json!({
    "users": result.rows,
    "count": result.rows.len(),
}))
<span class="boring">}</span></code></pre></pre>
<h3 id="typed-results"><a class="header" href="#typed-results">Typed Results</a></h3>
<p>Parse rows into your own structs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct User {
    id: i64,
    name: String,
    email: String,
}

fn get_user(db: &amp;DbPool, id: &amp;str) -&gt; Result&lt;Option&lt;User&gt;, HandlerError&gt; {
    let result = db.query("SELECT * FROM users WHERE id = ?", &amp;[id])?;
    
    if let Some(row) = result.rows.first() {
        let user: User = serde_json::from_value(row.clone().into())
            .map_err(|e| HandlerError::Internal(e.to_string()))?;
        Ok(Some(user))
    } else {
        Ok(None)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let db = DbPool { pool_id: "main".to_string() };
    
    let result = db.query("SELECT * FROM users", &amp;[]);
    
    match result {
        Ok(data) =&gt; Response::ok(json!({"users": data.rows})),
        Err(HandlerError::DatabaseError(msg)) =&gt; {
            eprintln!("Database error: {}", msg);
            Response::internal_error("Database temporarily unavailable")
        }
        Err(HandlerError::ServiceUnavailable(msg)) =&gt; {
            Response::json(503, json!({"error": "Service unavailable", "retry_after": 5}))
        }
        Err(e) =&gt; e.to_response(),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Always use parameterized queries</strong> - Never concatenate user input into SQL</li>
<li><strong>Handle connection errors gracefully</strong> - Services may be temporarily unavailable</li>
<li><strong>Use appropriate pool sizes</strong> - Match your concurrency needs</li>
<li><strong>Keep queries simple</strong> - Complex logic is better in your handler code</li>
<li><strong>Log errors</strong> - Use <code>eprintln!</code> for debugging database issues</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis-service"><a class="header" href="#redis-service">Redis Service</a></h1>
<p>Use Redis for caching, sessions, and fast key-value storage.</p>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<pre><code class="language-json">{
  "service_type": "redis",
  "config": {
    "host": "localhost",
    "port": 6379,
    "password": null,
    "database": 0,
    "use_tls": false,
    "pool_size": 10
  }
}
</code></pre>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td>required</td><td>Redis server hostname</td></tr>
<tr><td><code>port</code></td><td>u16</td><td>6379</td><td>Redis server port</td></tr>
<tr><td><code>password</code></td><td>string</td><td>null</td><td>Redis password (optional)</td></tr>
<tr><td><code>database</code></td><td>u8</td><td>0</td><td>Redis database number (0-15)</td></tr>
<tr><td><code>use_tls</code></td><td>bool</td><td>false</td><td>Enable TLS encryption</td></tr>
<tr><td><code>pool_size</code></td><td>u32</td><td>10</td><td>Connection pool size</td></tr>
<tr><td><code>username</code></td><td>string</td><td>null</td><td>Username for Redis 6+ ACL</td></tr>
</tbody></table>
</div>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let redis = RedisPool { pool_id: "cache".to_string() };
    
    // Get a value
    match redis.get("my-key") {
        Ok(Some(value)) =&gt; Response::ok(json!({"value": value})),
        Ok(None) =&gt; Response::not_found(),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="set-values"><a class="header" href="#set-values">Set Values</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set without expiration
redis.set("key", "value")?;

// Set with expiration (seconds)
redis.setex("session:abc123", &amp;session_data, 3600)?; // 1 hour
redis.setex("rate:user:123", "1", 60)?; // 1 minute
<span class="boring">}</span></code></pre></pre>
<h3 id="caching-pattern"><a class="header" href="#caching-pattern">Caching Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let redis = RedisPool { pool_id: "cache".to_string() };
    let db = DbPool { pool_id: "main".to_string() };
    
    let user_id = req.path_param("id").unwrap();
    let cache_key = format!("user:{}", user_id);
    
    // Try cache first
    if let Ok(Some(cached)) = redis.get(&amp;cache_key) {
        return Response::ok(json!({
            "source": "cache",
            "user": serde_json::from_str::&lt;JsonValue&gt;(&amp;cached).unwrap()
        }));
    }
    
    // Cache miss - fetch from database
    let result = db.query("SELECT * FROM users WHERE id = ?", &amp;[user_id])?;
    
    if let Some(user) = result.rows.first() {
        // Cache for 5 minutes
        let user_json = serde_json::to_string(user).unwrap();
        let _ = redis.setex(&amp;cache_key, &amp;user_json, 300);
        
        return Response::ok(json!({
            "source": "database",
            "user": user
        }));
    }
    
    Response::not_found()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="session-management"><a class="header" href="#session-management">Session Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_session(redis: &amp;RedisPool, session_id: &amp;str) -&gt; Result&lt;Option&lt;Session&gt;, HandlerError&gt; {
    let key = format!("session:{}", session_id);
    
    match redis.get(&amp;key)? {
        Some(data) =&gt; {
            let session: Session = serde_json::from_str(&amp;data)
                .map_err(|e| HandlerError::Internal(e.to_string()))?;
            Ok(Some(session))
        }
        None =&gt; Ok(None),
    }
}

fn save_session(redis: &amp;RedisPool, session_id: &amp;str, session: &amp;Session) -&gt; Result&lt;(), HandlerError&gt; {
    let key = format!("session:{}", session_id);
    let data = serde_json::to_string(session)
        .map_err(|e| HandlerError::Internal(e.to_string()))?;
    
    // Sessions expire in 24 hours
    redis.setex(&amp;key, &amp;data, 86400)
}

#[derive(Serialize, Deserialize)]
struct Session {
    user_id: String,
    created_at: String,
    data: JsonValue,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check_rate_limit(redis: &amp;RedisPool, client_ip: &amp;str) -&gt; Result&lt;bool, HandlerError&gt; {
    let key = format!("rate:{}", client_ip);
    
    match redis.get(&amp;key)? {
        Some(count) =&gt; {
            let count: u32 = count.parse().unwrap_or(0);
            if count &gt;= 100 {
                return Ok(false); // Rate limited
            }
            // Note: This is a simplified example
            // Real implementation would use INCR command
            redis.setex(&amp;key, &amp;(count + 1).to_string(), 60)?;
            Ok(true)
        }
        None =&gt; {
            redis.setex(&amp;key, "1", 60)?;
            Ok(true)
        }
    }
}

fn handle(req: Request) -&gt; Response {
    let redis = RedisPool { pool_id: "cache".to_string() };
    
    let client_ip = req.client_ip.as_deref().unwrap_or("unknown");
    
    match check_rate_limit(&amp;redis, client_ip) {
        Ok(true) =&gt; {
            // Process request normally
            Response::ok(json!({"status": "ok"}))
        }
        Ok(false) =&gt; {
            Response::json(429, json!({"error": "Too many requests"}))
                .with_header("Retry-After", "60")
        }
        Err(e) =&gt; {
            // If Redis is down, allow the request (fail open)
            eprintln!("Rate limit check failed: {}", e);
            Response::ok(json!({"status": "ok"}))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match redis.get("key") {
    Ok(Some(value)) =&gt; { /* use value */ }
    Ok(None) =&gt; { /* key doesn't exist */ }
    Err(HandlerError::RedisError(msg)) =&gt; {
        eprintln!("Redis error: {}", msg);
        // Fallback behavior
    }
    Err(HandlerError::ServiceUnavailable(_)) =&gt; {
        // Redis is down - decide on fallback
    }
    Err(e) =&gt; { /* other error */ }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Use meaningful key prefixes</strong> - <code>user:123</code>, <code>session:abc</code>, <code>cache:posts:1</code></li>
<li><strong>Always set expiration for cache keys</strong> - Prevents unbounded memory growth</li>
<li><strong>Handle Redis unavailability</strong> - Decide on fail-open vs fail-closed</li>
<li><strong>Don't store large values</strong> - Redis works best with small, fast lookups</li>
<li><strong>Use JSON for structured data</strong> - Easy to serialize/deserialize</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ftpsftp-service"><a class="header" href="#ftpsftp-service">FTP/SFTP Service</a></h1>
<p>Transfer files to and from remote servers using FTP, FTPS, or SFTP.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<h3 id="ftp-unencrypted"><a class="header" href="#ftp-unencrypted">FTP (Unencrypted)</a></h3>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "ftp.example.com",
    "port": 21,
    "username": "user",
    "password": "secret",
    "protocol": "ftp",
    "base_path": "/uploads",
    "passive_mode": true,
    "timeout_seconds": 30
  }
}
</code></pre>
<h3 id="ftps-ftp-over-tls"><a class="header" href="#ftps-ftp-over-tls">FTPS (FTP over TLS)</a></h3>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "ftp.example.com",
    "port": 21,
    "username": "user",
    "password": "secret",
    "protocol": "ftps",
    "passive_mode": true
  }
}
</code></pre>
<h3 id="sftp-ssh-file-transfer"><a class="header" href="#sftp-ssh-file-transfer">SFTP (SSH File Transfer)</a></h3>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "sftp.example.com",
    "port": 22,
    "username": "user",
    "password": "secret",
    "protocol": "sftp",
    "base_path": "/home/user/uploads"
  }
}
</code></pre>
<p>Or with SSH key authentication:</p>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "sftp.example.com",
    "port": 22,
    "username": "user",
    "private_key_path": "/path/to/id_rsa",
    "protocol": "sftp"
  }
}
</code></pre>
<h2 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td>required</td><td>FTP server hostname</td></tr>
<tr><td><code>port</code></td><td>u16</td><td>21/22</td><td>Server port (21 for FTP/FTPS, 22 for SFTP)</td></tr>
<tr><td><code>username</code></td><td>string</td><td>required</td><td>Login username</td></tr>
<tr><td><code>password</code></td><td>string</td><td>null</td><td>Login password</td></tr>
<tr><td><code>private_key_path</code></td><td>string</td><td>null</td><td>Path to SSH private key (SFTP only)</td></tr>
<tr><td><code>protocol</code></td><td>string</td><td>"ftp"</td><td>Protocol: "ftp", "ftps", or "sftp"</td></tr>
<tr><td><code>base_path</code></td><td>string</td><td>null</td><td>Default directory on server</td></tr>
<tr><td><code>passive_mode</code></td><td>bool</td><td>true</td><td>Use passive mode (FTP/FTPS only)</td></tr>
<tr><td><code>timeout_seconds</code></td><td>u32</td><td>30</td><td>Connection timeout</td></tr>
</tbody></table>
</div>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<h3 id="upload-a-file"><a class="header" href="#upload-a-file">Upload a File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let ftp = FtpPool { pool_id: "uploads".to_string() };
    
    // Upload content
    let content = req.body.as_ref().unwrap();
    let result = ftp.put("/reports/daily.csv", content.as_bytes());
    
    match result {
        Ok(()) =&gt; Response::ok(json!({"uploaded": true})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="download-a-file"><a class="header" href="#download-a-file">Download a File</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let ftp = FtpPool { pool_id: "files".to_string() };
    
    let filename = req.path_param("filename").unwrap();
    let path = format!("/data/{}", filename);
    
    match ftp.get(&amp;path) {
        Ok(content) =&gt; Response::new(200)
            .with_header("Content-Type", "application/octet-stream")
            .with_body(content),
        Err(e) =&gt; Response::not_found(),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="list-directory"><a class="header" href="#list-directory">List Directory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let ftp = FtpPool { pool_id: "files".to_string() };
    
    match ftp.list("/reports") {
        Ok(files) =&gt; Response::ok(json!({"files": files})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<ul>
<li><strong>File uploads</strong> - Accept user uploads and store on FTP server</li>
<li><strong>Report distribution</strong> - Upload generated reports to partner SFTP servers</li>
<li><strong>Data import</strong> - Download files from vendor FTP for processing</li>
<li><strong>Backup</strong> - Archive data to remote storage</li>
<li><strong>Legacy integration</strong> - Connect to systems that only support FTP</li>
</ul>
<h2 id="security-notes"><a class="header" href="#security-notes">Security Notes</a></h2>
<ol>
<li><strong>Prefer SFTP</strong> - Uses SSH encryption, most secure option</li>
<li><strong>Use FTPS if SFTP unavailable</strong> - TLS encryption for FTP</li>
<li><strong>Avoid plain FTP</strong> - Credentials sent in cleartext</li>
<li><strong>Use SSH keys</strong> - More secure than passwords for SFTP</li>
<li><strong>Restrict base_path</strong> - Limit access to specific directories</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="email-smtp-service"><a class="header" href="#email-smtp-service">Email (SMTP) Service</a></h1>
<p>Send emails from your handlers using SMTP.</p>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<h3 id="basic-smtp-with-starttls"><a class="header" href="#basic-smtp-with-starttls">Basic SMTP with STARTTLS</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "smtp.example.com",
    "port": 587,
    "username": "sender@example.com",
    "password": "app-password",
    "encryption": "starttls",
    "from_address": "noreply@example.com",
    "from_name": "My App",
    "reply_to": "support@example.com"
  }
}
</code></pre>
<h3 id="gmail-smtp"><a class="header" href="#gmail-smtp">Gmail SMTP</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "smtp.gmail.com",
    "port": 587,
    "username": "your-email@gmail.com",
    "password": "your-app-password",
    "encryption": "starttls",
    "from_address": "your-email@gmail.com",
    "from_name": "Your Name"
  }
}
</code></pre>
<h3 id="implicit-tls-port-465"><a class="header" href="#implicit-tls-port-465">Implicit TLS (Port 465)</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "smtp.example.com",
    "port": 465,
    "username": "sender@example.com",
    "password": "secret",
    "encryption": "tls",
    "from_address": "noreply@example.com"
  }
}
</code></pre>
<h3 id="local-smtp-no-auth"><a class="header" href="#local-smtp-no-auth">Local SMTP (No Auth)</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "localhost",
    "port": 25,
    "encryption": "none",
    "from_address": "app@localhost"
  }
}
</code></pre>
<h2 id="configuration-options-2"><a class="header" href="#configuration-options-2">Configuration Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>host</code></td><td>string</td><td>required</td><td>SMTP server hostname</td></tr>
<tr><td><code>port</code></td><td>u16</td><td>587</td><td>SMTP port</td></tr>
<tr><td><code>username</code></td><td>string</td><td>null</td><td>Auth username (usually email address)</td></tr>
<tr><td><code>password</code></td><td>string</td><td>null</td><td>Auth password or app password</td></tr>
<tr><td><code>encryption</code></td><td>string</td><td>"starttls"</td><td>Encryption: "none", "starttls", or "tls"</td></tr>
<tr><td><code>from_address</code></td><td>string</td><td>required</td><td>Default sender email</td></tr>
<tr><td><code>from_name</code></td><td>string</td><td>null</td><td>Default sender display name</td></tr>
<tr><td><code>reply_to</code></td><td>string</td><td>null</td><td>Default reply-to address</td></tr>
<tr><td><code>timeout_seconds</code></td><td>u32</td><td>30</td><td>Connection timeout</td></tr>
<tr><td><code>max_retries</code></td><td>u32</td><td>3</td><td>Send retry attempts</td></tr>
</tbody></table>
</div>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<h3 id="send-a-simple-email"><a class="header" href="#send-a-simple-email">Send a Simple Email</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

fn handle(req: Request) -&gt; Response {
    let email = EmailPool { pool_id: "notifications".to_string() };
    
    let result = email.send(
        "user@example.com",
        "Welcome!",
        "Thanks for signing up.",
    );
    
    match result {
        Ok(()) =&gt; Response::ok(json!({"sent": true})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="send-html-email"><a class="header" href="#send-html-email">Send HTML Email</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle(req: Request) -&gt; Response {
    let email = EmailPool { pool_id: "notifications".to_string() };
    
    let html = r#"
        &lt;h1&gt;Welcome!&lt;/h1&gt;
        &lt;p&gt;Thanks for joining us.&lt;/p&gt;
        &lt;a href="https://example.com/verify"&gt;Verify your email&lt;/a&gt;
    "#;
    
    let result = email.send_html(
        "user@example.com",
        "Welcome to Our App",
        html,
    );
    
    match result {
        Ok(()) =&gt; Response::ok(json!({"sent": true})),
        Err(e) =&gt; Response::internal_error(e.to_string()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="send-with-custom-from"><a class="header" href="#send-with-custom-from">Send with Custom From</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = email.send_from(
    "support@example.com",  // From
    "Support Team",         // From name
    "user@example.com",     // To
    "Your Ticket #123",     // Subject
    "We've received your support request...",
);
<span class="boring">}</span></code></pre></pre>
<h2 id="common-providers"><a class="header" href="#common-providers">Common Providers</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Provider</th><th>Host</th><th>Port</th><th>Encryption</th></tr></thead><tbody>
<tr><td>Gmail</td><td>smtp.gmail.com</td><td>587</td><td>starttls</td></tr>
<tr><td>Outlook</td><td>smtp.office365.com</td><td>587</td><td>starttls</td></tr>
<tr><td>SendGrid</td><td>smtp.sendgrid.net</td><td>587</td><td>starttls</td></tr>
<tr><td>Mailgun</td><td>smtp.mailgun.org</td><td>587</td><td>starttls</td></tr>
<tr><td>Amazon SES</td><td>email-smtp.{region}.amazonaws.com</td><td>587</td><td>starttls</td></tr>
</tbody></table>
</div>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Use app passwords</strong> - Don't use your main account password</li>
<li><strong>Set up SPF/DKIM</strong> - Improve deliverability</li>
<li><strong>Handle failures</strong> - Emails can fail; log and retry</li>
<li><strong>Rate limit</strong> - Don't spam; respect provider limits</li>
<li><strong>Use templates</strong> - Consistent formatting</li>
<li><strong>Test with sandbox</strong> - Use test mode before production</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>Rust Edge Gateway uses a dynamic library loading architecture with actor-based services for high performance and zero-downtime deployments.</p>
<h2 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-Level Architecture</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Edge Gateway                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Router    â”‚  â”‚   Admin     â”‚  â”‚    Handler Registry     â”‚  â”‚
â”‚  â”‚  (Axum)     â”‚  â”‚   API       â”‚  â”‚  (Dynamic Libraries)    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                       â”‚                â”‚
â”‚         â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚         â”‚         â”‚                                              â”‚
â”‚         â–¼         â–¼                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                    Service Actors                            â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚â”‚
â”‚  â”‚  â”‚ Database â”‚  â”‚  Cache   â”‚  â”‚ Storage  â”‚  â”‚  Email   â”‚    â”‚â”‚
â”‚  â”‚  â”‚  Actor   â”‚  â”‚  Actor   â”‚  â”‚  Actor   â”‚  â”‚  Actor   â”‚    â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="router-axum"><a class="header" href="#router-axum">Router (Axum)</a></h3>
<p>The main HTTP server built on Axum:</p>
<ul>
<li>Receives incoming HTTP requests</li>
<li>Matches requests to endpoints by path, method, and domain</li>
<li>Dispatches to the appropriate handler</li>
<li>Returns responses to clients</li>
</ul>
<h3 id="handler-registry"><a class="header" href="#handler-registry">Handler Registry</a></h3>
<p>Manages loaded handler libraries:</p>
<ul>
<li>Loads dynamic libraries (<code>.so</code>, <code>.dll</code>, <code>.dylib</code>)</li>
<li>Maintains a map of endpoint ID to handler function</li>
<li>Supports hot-swapping with graceful draining</li>
<li>Tracks active requests per handler</li>
</ul>
<h3 id="service-actors"><a class="header" href="#service-actors">Service Actors</a></h3>
<p>Background tasks that manage backend connections:</p>
<ul>
<li><strong>Database Actor</strong> - Connection pooling for SQL databases</li>
<li><strong>Cache Actor</strong> - Redis/Memcached connections</li>
<li><strong>Storage Actor</strong> - S3/MinIO object storage</li>
<li><strong>Email Actor</strong> - SMTP connections</li>
</ul>
<p>Actors communicate via message-passing channels, providing isolation and thread-safety.</p>
<h3 id="admin-api"><a class="header" href="#admin-api">Admin API</a></h3>
<p>RESTful API for management:</p>
<ul>
<li>Create/update/delete endpoints</li>
<li>Compile handler code</li>
<li>Deploy/undeploy handlers</li>
<li>Configure services</li>
<li>View logs and metrics</li>
</ul>
<h2 id="request-flow-1"><a class="header" href="#request-flow-1">Request Flow</a></h2>
<ol>
<li><strong>Request arrives</strong> at the Axum router</li>
<li><strong>Router matches</strong> the request to an endpoint</li>
<li><strong>Handler Registry</strong> looks up the handler by endpoint ID</li>
<li><strong>Request guard</strong> is acquired (for draining support)</li>
<li><strong>Handler function</strong> is called with Context and Request</li>
<li><strong>Handler accesses services</strong> via Context (sends messages to actors)</li>
<li><strong>Response is returned</strong> to the router</li>
<li><strong>Request guard</strong> is dropped (decrements active count)</li>
<li><strong>Router sends</strong> response to client</li>
</ol>
<h2 id="handler-compilation"><a class="header" href="#handler-compilation">Handler Compilation</a></h2>
<p>When you compile a handler:</p>
<ol>
<li><strong>Code is written</strong> to <code>handlers/{id}/src/lib.rs</code></li>
<li><strong>Cargo.toml</strong> is generated with SDK dependency</li>
<li><strong><code>cargo build --release</code></strong> compiles to dynamic library</li>
<li><strong>Library is stored</strong> in <code>handlers/{id}/target/release/</code></li>
</ol>
<p>The generated library exports a <code>handler_entry</code> symbol that the registry loads.</p>
<h2 id="hot-swapping"><a class="header" href="#hot-swapping">Hot Swapping</a></h2>
<p>When you update a handler:</p>
<ol>
<li><strong>New library is compiled</strong></li>
<li><strong>New library is loaded</strong> into memory</li>
<li><strong>Registry atomically swaps</strong> the handler pointer</li>
<li><strong>Old handler starts draining</strong> (no new requests)</li>
<li><strong>Active requests complete</strong> on old handler</li>
<li><strong>Old library is unloaded</strong> when drained</li>
</ol>
<p>This provides zero-downtime deployments.</p>
<h2 id="service-actor-pattern"><a class="header" href="#service-actor-pattern">Service Actor Pattern</a></h2>
<p>Services use the actor pattern for safety and efficiency:</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Handler  â”‚â”€â”€â”€â”€â–¶â”‚   Channel   â”‚â”€â”€â”€â”€â–¶â”‚ Service Actorâ”‚
â”‚          â”‚     â”‚  (mpsc)     â”‚     â”‚              â”‚
â”‚          â”‚â—€â”€â”€â”€â”€â”‚             â”‚â—€â”€â”€â”€â”€â”‚  (owns pool) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p>Benefits:</p>
<ul>
<li><strong>Thread-safe</strong> - No shared mutable state</li>
<li><strong>Isolated</strong> - Actor failures don't crash handlers</li>
<li><strong>Efficient</strong> - Connection pools are reused</li>
<li><strong>Backpressure</strong> - Channel buffers prevent overload</li>
</ul>
<h2 id="comparison-with-v1"><a class="header" href="#comparison-with-v1">Comparison with v1</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>v1 (Subprocess)</th><th>v2 (Dynamic Library)</th></tr></thead><tbody>
<tr><td>Execution</td><td>Child process</td><td>Direct function call</td></tr>
<tr><td>IPC</td><td>stdin/stdout JSON</td><td>None (in-process)</td></tr>
<tr><td>Latency</td><td>~1-5ms overhead</td><td>~0.01ms overhead</td></tr>
<tr><td>Memory</td><td>Separate per handler</td><td>Shared with gateway</td></tr>
<tr><td>Hot Swap</td><td>Restart process</td><td>Atomic pointer swap</td></tr>
<tr><td>Draining</td><td>Kill process</td><td>Graceful completion</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="handler-registry-1"><a class="header" href="#handler-registry-1">Handler Registry</a></h1>
<p>The Handler Registry manages loaded handler libraries and provides hot-swapping with graceful draining.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HandlerRegistry {
    /// Map of endpoint ID to loaded handler
    handlers: RwLock&lt;HashMap&lt;String, Arc&lt;LoadedHandler&gt;&gt;&gt;,
    
    /// Handlers that are draining (previous versions)
    draining_handlers: RwLock&lt;Vec&lt;Arc&lt;LoadedHandler&gt;&gt;&gt;,
    
    /// Directory where handler libraries are stored
    handlers_dir: PathBuf,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="loading-handlers"><a class="header" href="#loading-handlers">Loading Handlers</a></h2>
<p>When a handler is deployed, the registry:</p>
<ol>
<li><strong>Locates the library</strong> in the handlers directory</li>
<li><strong>Loads it with <code>libloading</code></strong> (cross-platform dynamic loading)</li>
<li><strong>Finds the <code>handler_entry</code> symbol</strong> (function pointer)</li>
<li><strong>Stores in the handlers map</strong> by endpoint ID</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load a handler
registry.load("my-endpoint").await?;

// Load from specific path
registry.load_from("my-endpoint", Path::new("/path/to/lib.so")).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="executing-handlers"><a class="header" href="#executing-handlers">Executing Handlers</a></h2>
<p>The registry provides execution methods with request tracking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Execute a handler
let response = registry.execute("my-endpoint", &amp;ctx, request).await?;

// Execute with timeout
let response = registry.execute_with_timeout(
    "my-endpoint",
    &amp;ctx,
    request,
    Duration::from_secs(30)
).await?;
<span class="boring">}</span></code></pre></pre>
<p>Request tracking ensures graceful draining works correctly.</p>
<h2 id="hot-swapping-1"><a class="header" href="#hot-swapping-1">Hot Swapping</a></h2>
<h3 id="immediate-swap"><a class="header" href="#immediate-swap">Immediate Swap</a></h3>
<p>For quick updates where in-flight requests can be dropped:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>registry.swap("my-endpoint", Path::new("/path/to/new-lib.so")).await?;
<span class="boring">}</span></code></pre></pre>
<p>The old handler is dropped immediately.</p>
<h3 id="graceful-swap"><a class="header" href="#graceful-swap">Graceful Swap</a></h3>
<p>For zero-downtime updates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = registry.swap_graceful(
    "my-endpoint",
    Path::new("/path/to/new-lib.so"),
    Duration::from_secs(30)  // drain timeout
).await?;

println!("Swapped: {}", result.swapped);
println!("Pending requests: {}", result.old_requests_pending);
println!("Draining: {}", result.draining);
<span class="boring">}</span></code></pre></pre>
<p>The graceful swap:</p>
<ol>
<li>Loads the new handler</li>
<li>Atomically swaps the active handler</li>
<li>Marks the old handler as draining</li>
<li>Waits for in-flight requests to complete</li>
<li>Unloads the old handler when drained</li>
</ol>
<h2 id="request-tracking-1"><a class="header" href="#request-tracking-1">Request Tracking</a></h2>
<p>Each <code>LoadedHandler</code> tracks active requests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LoadedHandler {
    // ... library and entry point ...
    
    /// Active request count
    active_requests: AtomicU64,
    
    /// Whether this handler is draining
    draining: AtomicBool,
}
<span class="boring">}</span></code></pre></pre>
<p>When executing a handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Acquire request guard (increments counter)
let guard = handler.acquire_request()?;

// Execute handler
let response = handler.execute(&amp;ctx, request).await;

// Guard is dropped (decrements counter)
drop(guard);
<span class="boring">}</span></code></pre></pre>
<p>If the handler is draining, <code>acquire_request()</code> returns <code>None</code>.</p>
<h2 id="draining-states"><a class="header" href="#draining-states">Draining States</a></h2>
<p>A handler can be in one of these states:</p>
<div class="table-wrapper"><table><thead><tr><th>State</th><th><code>draining</code></th><th><code>active_requests</code></th><th>Description</th></tr></thead><tbody>
<tr><td>Active</td><td><code>false</code></td><td>Any</td><td>Accepting new requests</td></tr>
<tr><td>Draining</td><td><code>true</code></td><td>&gt; 0</td><td>Finishing in-flight requests</td></tr>
<tr><td>Drained</td><td><code>true</code></td><td>0</td><td>Ready to unload</td></tr>
</tbody></table>
</div>
<h2 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h2>
<p>Get statistics about loaded handlers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stats = registry.stats().await;

println!("Loaded handlers: {}", stats.loaded_count);
println!("Draining handlers: {}", stats.draining_count);
println!("Active requests: {}", stats.active_requests);
println!("Draining requests: {}", stats.draining_requests);
<span class="boring">}</span></code></pre></pre>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<p>Periodically clean up fully drained handlers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let removed = registry.cleanup_drained().await;
println!("Cleaned up {} drained handlers", removed);
<span class="boring">}</span></code></pre></pre>
<p>This is typically called by a background task.</p>
<h2 id="library-naming"><a class="header" href="#library-naming">Library Naming</a></h2>
<p>Libraries are named by platform:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Library Name</th></tr></thead><tbody>
<tr><td>Linux</td><td><code>libhandler_{id}.so</code></td></tr>
<tr><td>Windows</td><td><code>handler_{id}.dll</code></td></tr>
<tr><td>macOS</td><td><code>libhandler_{id}.dylib</code></td></tr>
</tbody></table>
</div>
<p>The registry handles this automatically based on the target platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-actors-1"><a class="header" href="#service-actors-1">Service Actors</a></h1>
<p>Service Actors provide thread-safe access to backend services using the actor pattern.</p>
<h2 id="actor-pattern"><a class="header" href="#actor-pattern">Actor Pattern</a></h2>
<p>Each service runs as an independent actor:</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Service Actor                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   Inbox     â”‚â”€â”€â”€â”€â–¶â”‚   Actor     â”‚â”€â”€â”€â”€â–¶â”‚  Backend    â”‚    â”‚
â”‚  â”‚  (Channel)  â”‚     â”‚   Loop      â”‚     â”‚  (Pool)     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â–²                   â”‚                                â”‚
â”‚         â”‚                   â–¼                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚  Handlers   â”‚â—€â”€â”€â”€â”€â”‚  Response   â”‚                        â”‚
â”‚  â”‚  (Callers)  â”‚     â”‚  Channel    â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h2>
<ol>
<li><strong>Handler sends a command</strong> to the actor's inbox channel</li>
<li><strong>Actor receives the command</strong> in its event loop</li>
<li><strong>Actor executes the operation</strong> using its connection pool</li>
<li><strong>Actor sends the result</strong> back via a oneshot channel</li>
<li><strong>Handler receives the result</strong> and continues</li>
</ol>
<h2 id="actor-types"><a class="header" href="#actor-types">Actor Types</a></h2>
<h3 id="database-actor"><a class="header" href="#database-actor">Database Actor</a></h3>
<p>Manages SQL database connections:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DatabaseCommand {
    Query {
        sql: String,
        params: Vec&lt;Value&gt;,
        reply: oneshot::Sender&lt;Result&lt;Vec&lt;Row&gt;&gt;&gt;,
    },
    Execute {
        sql: String,
        params: Vec&lt;Value&gt;,
        reply: oneshot::Sender&lt;Result&lt;u64&gt;&gt;,
    },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cache-actor"><a class="header" href="#cache-actor">Cache Actor</a></h3>
<p>Manages Redis/Memcached connections:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CacheCommand {
    Get {
        key: String,
        reply: oneshot::Sender&lt;Result&lt;Option&lt;String&gt;&gt;&gt;,
    },
    Set {
        key: String,
        value: String,
        ttl: Option&lt;u64&gt;,
        reply: oneshot::Sender&lt;Result&lt;()&gt;&gt;,
    },
    Delete {
        key: String,
        reply: oneshot::Sender&lt;Result&lt;bool&gt;&gt;,
    },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="miniostorage-actor"><a class="header" href="#miniostorage-actor">MinIO/Storage Actor</a></h3>
<p>Manages object storage (S3/MinIO). This is a fully implemented service actor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum MinioCommand {
    GetObject {
        key: String,
        reply: oneshot::Sender&lt;Result&lt;Vec&lt;u8&gt;, String&gt;&gt;,
    },
    PutObject {
        key: String,
        data: Vec&lt;u8&gt;,
        content_type: Option&lt;String&gt;,
        reply: oneshot::Sender&lt;Result&lt;(), String&gt;&gt;,
    },
    DeleteObject {
        key: String,
        reply: oneshot::Sender&lt;Result&lt;(), String&gt;&gt;,
    },
    ListObjects {
        prefix: Option&lt;String&gt;,
        reply: oneshot::Sender&lt;Result&lt;Vec&lt;ObjectInfo&gt;, String&gt;&gt;,
    },
}
<span class="boring">}</span></code></pre></pre>
<h4 id="minio-actor-implementation"><a class="header" href="#minio-actor-implementation">MinIO Actor Implementation</a></h4>
<p>The actor runs as an async task with an S3 bucket connection:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MinioHandle {
    sender: mpsc::Sender&lt;MinioCommand&gt;,
    bucket_name: String,
}

impl MinioHandle {
    pub async fn spawn(config: &amp;MinioConfig) -&gt; Result&lt;Self&gt; {
        let (tx, mut rx) = mpsc::channel(100);
        let bucket = create_s3_bucket(config)?;

        tokio::spawn(async move {
            while let Some(cmd) = rx.recv().await {
                match cmd {
                    MinioCommand::GetObject { key, reply } =&gt; {
                        let result = bucket.get_object(&amp;key).await;
                        let _ = reply.send(result.map(|r| r.to_vec()));
                    }
                    MinioCommand::PutObject { key, data, content_type, reply } =&gt; {
                        let ct = content_type.as_deref().unwrap_or("application/octet-stream");
                        let result = bucket.put_object_with_content_type(&amp;key, &amp;data, ct).await;
                        let _ = reply.send(result.map(|_| ()));
                    }
                    // ... other commands
                }
            }
        });

        Ok(MinioHandle { sender: tx, bucket_name: config.bucket.clone() })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="using-the-minio-actor"><a class="header" href="#using-the-minio-actor">Using the MinIO Actor</a></h4>
<p>Handlers communicate with the actor via async message passing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get an object
let (tx, rx) = oneshot::channel();
minio_handle.sender.send(MinioCommand::GetObject {
    key: "uploads/file.txt".to_string(),
    reply: tx,
}).await?;
let data = rx.await??;

// List objects
let (tx, rx) = oneshot::channel();
minio_handle.sender.send(MinioCommand::ListObjects {
    prefix: Some("uploads/".to_string()),
    reply: tx,
}).await?;
let objects = rx.await??;
<span class="boring">}</span></code></pre></pre>
<h2 id="actor-handle"><a class="header" href="#actor-handle">Actor Handle</a></h2>
<p>Handlers interact with actors through handles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ActorHandle&lt;C&gt; {
    sender: mpsc::Sender&lt;C&gt;,
}

impl&lt;C&gt; ActorHandle&lt;C&gt; {
    pub async fn send(&amp;self, command: C) -&gt; Result&lt;()&gt; {
        self.sender.send(command).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="benefits"><a class="header" href="#benefits">Benefits</a></h2>
<h3 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h3>
<p>Actors own their resources exclusively:</p>
<ul>
<li>No shared mutable state</li>
<li>No locks needed</li>
<li>No data races possible</li>
</ul>
<h3 id="isolation"><a class="header" href="#isolation">Isolation</a></h3>
<p>Actor failures are contained:</p>
<ul>
<li>A crashed actor doesn't crash handlers</li>
<li>Actors can be restarted independently</li>
<li>Errors are returned as <code>Result</code> values</li>
</ul>
<h3 id="backpressure"><a class="header" href="#backpressure">Backpressure</a></h3>
<p>Channel buffers provide natural backpressure:</p>
<ul>
<li>If an actor is overloaded, senders wait</li>
<li>Prevents resource exhaustion</li>
<li>Configurable buffer sizes</li>
</ul>
<h3 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h3>
<p>Actors manage connection pools:</p>
<ul>
<li>Connections are reused across requests</li>
<li>Pool size is configurable</li>
<li>Automatic reconnection on failure</li>
</ul>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<p>Actors are configured via the Admin UI or API. First create the service configuration:</p>
<pre><code class="language-json">{
  "name": "my-storage",
  "service_type": "minio",
  "config": {
    "endpoint": "minio:9000",
    "access_key": "minioadmin",
    "secret_key": "minioadmin",
    "bucket": "my-bucket",
    "use_ssl": false,
    "region": "us-east-1"
  }
}
</code></pre>
<p>Then activate the service actor:</p>
<pre><code class="language-bash">POST /api/services/{id}/activate
</code></pre>
<h2 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h2>
<ol>
<li><strong>Service created</strong> - Configuration stored in database</li>
<li><strong>Service activated</strong> - Actor task spawns, connects to backend</li>
<li><strong>Requests arrive</strong> - Handlers send commands to actor via channel</li>
<li><strong>Actor processes</strong> - Executes operations, returns results via oneshot</li>
<li><strong>Service deactivated</strong> - Actor completes in-flight ops, shuts down</li>
<li><strong>Gateway stops</strong> - All actors gracefully shut down</li>
</ol>
<p>Actors can be activated/deactivated at runtime without restarting the gateway.</p>
<h2 id="rest-endpoints-for-minio"><a class="header" href="#rest-endpoints-for-minio">REST Endpoints for MinIO</a></h2>
<p>Once a MinIO service is activated, built-in handlers expose REST endpoints:</p>
<div class="table-wrapper"><table><thead><tr><th>Endpoint</th><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>/api/minio/objects</code></td><td>GET</td><td>List objects (with optional <code>?prefix=</code>)</td></tr>
<tr><td><code>/api/minio/objects</code></td><td>POST</td><td>Upload file (multipart form)</td></tr>
<tr><td><code>/api/minio/objects/{key}</code></td><td>GET</td><td>Download file</td></tr>
<tr><td><code>/api/minio/objects/{key}</code></td><td>DELETE</td><td>Delete file</td></tr>
</tbody></table>
</div>
<p>These handlers communicate with the MinIO actor via message passing, ensuring thread-safe access to the S3 bucket.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graceful-draining"><a class="header" href="#graceful-draining">Graceful Draining</a></h1>
<p>Graceful draining enables zero-downtime deployments by allowing old handlers to complete in-flight requests while new handlers receive new requests.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Without graceful draining, updating a handler can cause:</p>
<ul>
<li><strong>Dropped requests</strong> - In-flight requests are terminated</li>
<li><strong>Connection resets</strong> - Clients see connection errors</li>
<li><strong>Data corruption</strong> - Partial operations may leave inconsistent state</li>
</ul>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>Graceful draining solves this by:</p>
<ol>
<li><strong>Loading the new handler</strong> before removing the old one</li>
<li><strong>Routing new requests</strong> to the new handler immediately</li>
<li><strong>Allowing old requests</strong> to complete on the old handler</li>
<li><strong>Unloading the old handler</strong> only when fully drained</li>
</ol>
<h2 id="timeline"><a class="header" href="#timeline">Timeline</a></h2>
<pre><code>Time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶

Old Handler:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
              (handling)  (draining)  (unloaded)

New Handler:  â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
                          (handling new requests)

                    â–²
                    â”‚ Swap point
</code></pre>
<h2 id="how-it-works-3"><a class="header" href="#how-it-works-3">How It Works</a></h2>
<h3 id="1-request-tracking"><a class="header" href="#1-request-tracking">1. Request Tracking</a></h3>
<p>Each handler tracks active requests using atomic counters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LoadedHandler {
    active_requests: AtomicU64,
    draining: AtomicBool,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-request-guards"><a class="header" href="#2-request-guards">2. Request Guards</a></h3>
<p>When a request starts, a guard is acquired:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guard = handler.acquire_request()?;
// Request is processed...
// Guard is dropped when request completes
<span class="boring">}</span></code></pre></pre>
<p>The guard:</p>
<ul>
<li>Increments <code>active_requests</code> on creation</li>
<li>Decrements <code>active_requests</code> on drop</li>
<li>Returns <code>None</code> if handler is draining</li>
</ul>
<h3 id="3-graceful-swap"><a class="header" href="#3-graceful-swap">3. Graceful Swap</a></h3>
<p>When swapping handlers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = registry.swap_graceful(
    "my-endpoint",
    new_library_path,
    Duration::from_secs(30)  // drain timeout
).await?;
<span class="boring">}</span></code></pre></pre>
<p>This:</p>
<ol>
<li>Loads the new handler</li>
<li>Atomically swaps the active handler</li>
<li>Marks the old handler as draining</li>
<li>Spawns a background task to monitor draining</li>
<li>Returns immediately (non-blocking)</li>
</ol>
<h3 id="4-drain-monitoring"><a class="header" href="#4-drain-monitoring">4. Drain Monitoring</a></h3>
<p>A background task monitors the old handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while !old_handler.is_drained() {
    if elapsed &gt; drain_timeout {
        // Force unload after timeout
        break;
    }
    tokio::time::sleep(Duration::from_millis(100)).await;
}
// Old handler is now safe to unload
<span class="boring">}</span></code></pre></pre>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<h3 id="swap-with-draining"><a class="header" href="#swap-with-draining">Swap with Draining</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = registry.swap_graceful(
    endpoint_id,
    new_path,
    drain_timeout
).await?;

// Result contains:
// - swapped: bool - Whether swap succeeded
// - old_requests_pending: u64 - Requests still in flight
// - draining: bool - Whether old handler is draining
<span class="boring">}</span></code></pre></pre>
<h3 id="check-draining-status"><a class="header" href="#check-draining-status">Check Draining Status</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Is handler accepting new requests?
let accepting = !handler.is_draining();

// Is handler fully drained?
let drained = handler.is_drained();

// How many requests are in flight?
let active = handler.active_request_count();
<span class="boring">}</span></code></pre></pre>
<h3 id="get-statistics"><a class="header" href="#get-statistics">Get Statistics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stats = registry.stats().await;

println!("Active handlers: {}", stats.loaded_count);
println!("Draining handlers: {}", stats.draining_count);
println!("Active requests: {}", stats.active_requests);
println!("Draining requests: {}", stats.draining_requests);
<span class="boring">}</span></code></pre></pre>
<h2 id="drain-timeout-1"><a class="header" href="#drain-timeout-1">Drain Timeout</a></h2>
<p>The drain timeout determines how long to wait for requests to complete:</p>
<div class="table-wrapper"><table><thead><tr><th>Timeout</th><th>Use Case</th></tr></thead><tbody>
<tr><td>5s</td><td>Fast APIs with quick responses</td></tr>
<tr><td>30s</td><td>Standard web applications</td></tr>
<tr><td>60s</td><td>Long-running operations</td></tr>
<tr><td>300s</td><td>File uploads, batch processing</td></tr>
</tbody></table>
</div>
<p>If the timeout expires, the old handler is forcefully unloaded. Any remaining requests will fail.</p>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="1-set-appropriate-timeouts"><a class="header" href="#1-set-appropriate-timeouts">1. Set Appropriate Timeouts</a></h3>
<p>Match your drain timeout to your longest expected request:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For a file upload endpoint
registry.swap_graceful(
    "upload-endpoint",
    new_path,
    Duration::from_secs(300)  // 5 minutes for large uploads
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-monitor-draining"><a class="header" href="#2-monitor-draining">2. Monitor Draining</a></h3>
<p>Log draining status for observability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if result.draining {
    tracing::info!(
        endpoint = endpoint_id,
        pending = result.old_requests_pending,
        "Handler draining"
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-handle-drain-rejection"><a class="header" href="#3-handle-drain-rejection">3. Handle Drain Rejection</a></h3>
<p>When a handler is draining, new requests are rejected:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match handler.acquire_request() {
    Some(guard) =&gt; {
        // Process request
    }
    None =&gt; {
        // Handler is draining, return 503
        return Response::service_unavailable("Handler updating, retry shortly");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-cleanup-drained-handlers"><a class="header" href="#4-cleanup-drained-handlers">4. Cleanup Drained Handlers</a></h3>
<p>Periodically clean up fully drained handlers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In a background task
loop {
    registry.cleanup_drained().await;
    tokio::time::sleep(Duration::from_secs(60)).await;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>The simplest possible handler.</p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(_ctx: &amp;Context, _req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello, World!"
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="endpoint-configuration"><a class="header" href="#endpoint-configuration">Endpoint Configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Value</th></tr></thead><tbody>
<tr><td>Path</td><td><code>/hello</code></td></tr>
<tr><td>Method</td><td><code>GET</code></td></tr>
<tr><td>Domain</td><td><code>*</code></td></tr>
</tbody></table>
</div>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<pre><code class="language-bash">curl http://localhost:9080/hello
</code></pre>
<h2 id="response-1"><a class="header" href="#response-1">Response</a></h2>
<pre><code class="language-json">{
  "message": "Hello, World!"
}
</code></pre>
<h2 id="variations"><a class="header" href="#variations">Variations</a></h2>
<h3 id="with-request-info"><a class="header" href="#with-request-info">With Request Info</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    Response::ok(json!({
        "message": "Hello, World!",
        "method": req.method,
        "path": req.path,
        "request_id": req.request_id,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="plain-text"><a class="header" href="#plain-text">Plain Text</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, _req: Request) -&gt; Response {
    Response::text(200, "Hello, World!")
}
<span class="boring">}</span></code></pre></pre>
<h3 id="html"><a class="header" href="#html">HTML</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, _req: Request) -&gt; Response {
    Response::new(200)
        .with_header("Content-Type", "text/html")
        .with_body("&lt;h1&gt;Hello, World!&lt;/h1&gt;")
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-api"><a class="header" href="#json-api">JSON API</a></h1>
<p>Build a RESTful JSON API endpoint.</p>
<h2 id="code-1"><a class="header" href="#code-1">Code</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[derive(Deserialize)]
struct CreateItem {
    name: String,
    description: Option&lt;String&gt;,
    price: f64,
}

#[derive(Serialize)]
struct Item {
    id: String,
    name: String,
    description: Option&lt;String&gt;,
    price: f64,
}

#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    // Parse request body
    let input: CreateItem = match req.json() {
        Ok(data) =&gt; data,
        Err(e) =&gt; return Response::bad_request(format!("Invalid JSON: {}", e)),
    };

    // Validate
    if input.name.is_empty() {
        return Response::bad_request("Name is required");
    }

    if input.price &lt; 0.0 {
        return Response::bad_request("Price must be non-negative");
    }

    // Create item (in real app, save to database via ctx)
    let item = Item {
        id: uuid::Uuid::new_v4().to_string(),
        name: input.name,
        description: input.description,
        price: input.price,
    };

    // Return 201 Created
    Response::created(item)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="endpoint-configuration-1"><a class="header" href="#endpoint-configuration-1">Endpoint Configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Setting</th><th>Value</th></tr></thead><tbody>
<tr><td>Path</td><td><code>/items</code></td></tr>
<tr><td>Method</td><td><code>POST</code></td></tr>
<tr><td>Domain</td><td><code>*</code></td></tr>
</tbody></table>
</div>
<h2 id="test-1"><a class="header" href="#test-1">Test</a></h2>
<pre><code class="language-bash">curl -X POST http://localhost:9080/items \
  -H "Content-Type: application/json" \
  -d '{"name": "Widget", "description": "A useful widget", "price": 19.99}'
</code></pre>
<h2 id="response-2"><a class="header" href="#response-2">Response</a></h2>
<pre><code class="language-json">{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Widget",
  "description": "A useful widget",
  "price": 19.99,
  "created_at": "2024-01-15T10:30:00.000Z"
}
</code></pre>
<h2 id="full-crud-example"><a class="header" href="#full-crud-example">Full CRUD Example</a></h2>
<p>For a complete CRUD API with database access:</p>
<h3 id="get-items---list-items"><a class="header" href="#get-items---list-items">GET /items - List Items</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, _req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let db = ctx.database("main-db").await?;
    let items = db.query("SELECT id, name FROM items", &amp;[]).await?;

    Ok(Response::ok(json!({
        "items": items,
        "count": items.len(),
    })))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get-itemsid---get-item"><a class="header" href="#get-itemsid---get-item">GET /items/{id} - Get Item</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let id = req.path_param("id")
        .ok_or_else(|| HandlerError::ValidationError("Missing ID".into()))?;

    let db = ctx.database("main-db").await?;
    let item = db.query_one("SELECT * FROM items WHERE id = $1", &amp;[&amp;id]).await?;

    Ok(Response::ok(item))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="put-itemsid---update-item"><a class="header" href="#put-itemsid---update-item">PUT /items/{id} - Update Item</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct UpdateItem {
    name: Option&lt;String&gt;,
    price: Option&lt;f64&gt;,
}

#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let id = req.path_param("id")
        .ok_or_else(|| HandlerError::ValidationError("Missing ID".into()))?;

    let update: UpdateItem = req.json()?;

    let db = ctx.database("main-db").await?;
    db.execute(
        "UPDATE items SET name = COALESCE($1, name), price = COALESCE($2, price) WHERE id = $3",
        &amp;[&amp;update.name, &amp;update.price, &amp;id]
    ).await?;

    Ok(Response::ok(json!({"id": id, "updated": true})))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="delete-itemsid---delete-item"><a class="header" href="#delete-itemsid---delete-item">DELETE /items/{id} - Delete Item</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let id = req.path_param("id")
        .ok_or_else(|| HandlerError::ValidationError("Missing ID".into()))?;

    let db = ctx.database("main-db").await?;
    db.execute("DELETE FROM items WHERE id = $1", &amp;[&amp;id]).await?;

    Ok(Response::no_content())
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-parameters-2"><a class="header" href="#path-parameters-2">Path Parameters</a></h1>
<p>Extract dynamic values from URL paths.</p>
<h2 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h2>
<p><strong>Endpoint Path:</strong> <code>/users/{id}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    // Extract the {id} parameter
    let user_id = match req.path_param("id") {
        Some(id) =&gt; id,
        None =&gt; return Response::bad_request("Missing user ID"),
    };

    Response::ok(json!({
        "user_id": user_id,
        "message": format!("Fetching user {}", user_id),
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-2"><a class="header" href="#test-2">Test</a></h2>
<pre><code class="language-bash">curl http://localhost:9080/users/123
</code></pre>
<h2 id="response-3"><a class="header" href="#response-3">Response</a></h2>
<pre><code class="language-json">{
  "user_id": "123",
  "message": "Fetching user 123"
}
</code></pre>
<h2 id="multiple-parameters"><a class="header" href="#multiple-parameters">Multiple Parameters</a></h2>
<p><strong>Endpoint Path:</strong> <code>/users/{user_id}/posts/{post_id}</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    let user_id = req.path_param("user_id");
    let post_id = req.path_param("post_id");

    match (user_id, post_id) {
        (Some(uid), Some(pid)) =&gt; {
            Response::ok(json!({
                "user_id": uid,
                "post_id": pid,
            }))
        }
        _ =&gt; Response::bad_request("Missing parameters"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-3"><a class="header" href="#test-3">Test</a></h3>
<pre><code class="language-bash">curl http://localhost:9080/users/42/posts/7
</code></pre>
<h3 id="response-4"><a class="header" href="#response-4">Response</a></h3>
<pre><code class="language-json">{
  "user_id": "42",
  "post_id": "7"
}
</code></pre>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h2>
<p>Path parameters are always strings. Convert them to other types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    let id_str = match req.path_param("id") {
        Some(id) =&gt; id,
        None =&gt; return Response::bad_request("Missing ID"),
    };

    // Parse to integer
    let id: i64 = match id_str.parse() {
        Ok(n) =&gt; n,
        Err(_) =&gt; return Response::bad_request("ID must be a number"),
    };

    // Parse to UUID
    let uuid_str = match req.path_param("uuid") {
        Some(u) =&gt; u,
        None =&gt; return Response::bad_request("Missing UUID"),
    };

    let uuid = match uuid::Uuid::parse_str(uuid_str) {
        Ok(u) =&gt; u,
        Err(_) =&gt; return Response::bad_request("Invalid UUID format"),
    };

    Response::ok(json!({
        "id": id,
        "uuid": uuid.to_string(),
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="optional-parameters-with-defaults"><a class="header" href="#optional-parameters-with-defaults">Optional Parameters with Defaults</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    // Get page number, default to 1
    let page: u32 = req.path_param("page")
        .and_then(|p| p.parse().ok())
        .unwrap_or(1);

    Response::ok(json!({"page": page}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="route-patterns"><a class="header" href="#route-patterns">Route Patterns</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Matches</th><th>Parameters</th></tr></thead><tbody>
<tr><td><code>/users/{id}</code></td><td><code>/users/123</code></td><td><code>id: "123"</code></td></tr>
<tr><td><code>/api/{version}/items</code></td><td><code>/api/v2/items</code></td><td><code>version: "v2"</code></td></tr>
<tr><td><code>/files/{path}</code></td><td><code>/files/docs</code></td><td><code>path: "docs"</code></td></tr>
<tr><td><code>/{org}/{repo}/issues/{num}</code></td><td><code>/acme/proj/issues/42</code></td><td><code>org: "acme"</code>, <code>repo: "proj"</code>, <code>num: "42"</code></td></tr>
</tbody></table>
</div>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="resource-by-id"><a class="header" href="#resource-by-id">Resource by ID</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET /users/{id}
#[handler]
pub async fn get_user(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let id = req.path_param("id").unwrap();
    let db = ctx.database("main-db").await?;
    let user = db.query_one("SELECT * FROM users WHERE id = $1", &amp;[&amp;id]).await?;
    Ok(Response::ok(user))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="nested-resources"><a class="header" href="#nested-resources">Nested Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET /organizations/{org_id}/teams/{team_id}/members
#[handler]
pub async fn get_team_members(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let org_id = req.path_param("org_id").unwrap();
    let team_id = req.path_param("team_id").unwrap();

    let db = ctx.database("main-db").await?;
    let members = db.query(
        "SELECT * FROM members WHERE org_id = $1 AND team_id = $2",
        &amp;[&amp;org_id, &amp;team_id]
    ).await?;

    Ok(Response::ok(json!({
        "organization": org_id,
        "team": team_id,
        "members": members,
    })))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="slug-based-routes"><a class="header" href="#slug-based-routes">Slug-based Routes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GET /blog/{slug}
#[handler]
pub async fn get_blog_post(ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let slug = req.path_param("slug").unwrap();

    let db = ctx.database("main-db").await?;
    let post = db.query_one("SELECT * FROM posts WHERE slug = $1", &amp;[&amp;slug]).await?;

    Ok(Response::ok(post))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-parameters-2"><a class="header" href="#query-parameters-2">Query Parameters</a></h1>
<p>Access URL query string values.</p>
<h2 id="basic-example-1"><a class="header" href="#basic-example-1">Basic Example</a></h2>
<p><strong>Endpoint Path:</strong> <code>/search</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    // Get query parameter
    let query = req.query_param("q")
        .map(|s| s.to_string())
        .unwrap_or_default();

    if query.is_empty() {
        return Response::bad_request("Missing search query");
    }

    Response::ok(json!({
        "query": query,
        "results": [],
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-4"><a class="header" href="#test-4">Test</a></h2>
<pre><code class="language-bash">curl "http://localhost:9080/search?q=rust"
</code></pre>
<h2 id="response-5"><a class="header" href="#response-5">Response</a></h2>
<pre><code class="language-json">{
  "query": "rust",
  "results": []
}
</code></pre>
<h2 id="pagination-example"><a class="header" href="#pagination-example">Pagination Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    // Parse pagination parameters with defaults
    let page: u32 = req.query_param("page")
        .and_then(|p| p.parse().ok())
        .unwrap_or(1);

    let limit: u32 = req.query_param("limit")
        .and_then(|l| l.parse().ok())
        .unwrap_or(10)
        .min(100);  // Cap at 100

    let offset = (page - 1) * limit;

    Response::ok(json!({
        "page": page,
        "limit": limit,
        "offset": offset,
        "items": [],
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-5"><a class="header" href="#test-5">Test</a></h3>
<pre><code class="language-bash">curl "http://localhost:9080/items?page=2&amp;limit=20"
</code></pre>
<h3 id="response-6"><a class="header" href="#response-6">Response</a></h3>
<pre><code class="language-json">{
  "page": 2,
  "limit": 20,
  "offset": 20,
  "items": []
}
</code></pre>
<h2 id="filtering-example"><a class="header" href="#filtering-example">Filtering Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    // Get filter parameters
    let status = req.query_param("status");
    let category = req.query_param("category");
    let min_price: Option&lt;f64&gt; = req.query_param("min_price")
        .and_then(|p| p.parse().ok());
    let max_price: Option&lt;f64&gt; = req.query_param("max_price")
        .and_then(|p| p.parse().ok());

    Response::ok(json!({
        "filters": {
            "status": status,
            "category": category,
            "price_range": {
                "min": min_price,
                "max": max_price,
            },
        },
        "items": [],
    }))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="test-6"><a class="header" href="#test-6">Test</a></h3>
<pre><code class="language-bash">curl "http://localhost:9080/products?status=active&amp;category=electronics&amp;min_price=100"
</code></pre>
<h2 id="sorting-example"><a class="header" href="#sorting-example">Sorting Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    let sort_by = req.query_param("sort")
        .map(|s| s.to_string())
        .unwrap_or_else(|| "created_at".to_string());

    let order = req.query_param("order")
        .map(|s| s.to_string())
        .unwrap_or_else(|| "desc".to_string());

    // Validate sort field
    let valid_fields = ["name", "created_at", "price", "popularity"];
    if !valid_fields.contains(&amp;sort_by.as_str()) {
        return Response::bad_request(format!(
            "Invalid sort field. Valid options: {:?}", valid_fields
        ));
    }

    Response::ok(json!({
        "sort": {
            "field": sort_by,
            "order": order,
        },
        "items": [],
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="boolean-parameters"><a class="header" href="#boolean-parameters">Boolean Parameters</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    // Parse boolean parameters
    let include_deleted = req.query_param("include_deleted")
        .map(|v| v == "true" || v == "1")
        .unwrap_or(false);

    let verbose = req.query_param("verbose")
        .map(|v| v == "true" || v == "1")
        .unwrap_or(false);

    Response::ok(json!({
        "include_deleted": include_deleted,
        "verbose": verbose,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="all-query-parameters"><a class="header" href="#all-query-parameters">All Query Parameters</a></h2>
<p>Access all query parameters at once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    // Log all query parameters
    for (key, value) in &amp;req.query {
        eprintln!("Query param: {} = {}", key, value);
    }

    Response::ok(json!({
        "query_params": req.query,
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="validation-helper"><a class="header" href="#validation-helper">Validation Helper</a></h2>
<p>Create a reusable validation function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_pagination(req: &amp;Request) -&gt; Result&lt;(u32, u32), Response&gt; {
    let page: u32 = req.query_param("page")
        .and_then(|p| p.parse().ok())
        .unwrap_or(1);

    if page == 0 {
        return Err(Response::bad_request("Page must be &gt;= 1"));
    }

    let limit: u32 = req.query_param("limit")
        .and_then(|l| l.parse().ok())
        .unwrap_or(10);

    if limit &gt; 100 {
        return Err(Response::bad_request("Limit must be &lt;= 100"));
    }

    Ok((page, limit))
}

#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Response {
    let (page, limit) = match parse_pagination(&amp;req) {
        Ok(p) =&gt; p,
        Err(response) =&gt; return response,
    };

    Response::ok(json!({"page": page, "limit": limit}))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h1>
<p>Robust error handling patterns for handlers.</p>
<h2 id="basic-pattern"><a class="header" href="#basic-pattern">Basic Pattern</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let data = process_request(&amp;req)?;
    Ok(Response::ok(data))
}

fn process_request(req: &amp;Request) -&gt; Result&lt;JsonValue, HandlerError&gt; {
    let input: CreateUser = req.json()
        .map_err(|e| HandlerError::ValidationError(e.to_string()))?;

    // Process and return result
    Ok(json!({"id": "123", "name": input.name}))
}

#[derive(Deserialize)]
struct CreateUser {
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-types-and-status-codes"><a class="header" href="#error-types-and-status-codes">Error Types and Status Codes</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(req: &amp;Request) -&gt; Result&lt;JsonValue, HandlerError&gt; {
    // 400 Bad Request - Invalid input
    if req.body.is_none() {
        return Err(HandlerError::ValidationError("Body required".into()));
    }
    
    // 401 Unauthorized - Missing/invalid auth
    if req.header("Authorization").is_none() {
        return Err(HandlerError::Unauthorized("Token required".into()));
    }
    
    // 404 Not Found - Resource doesn't exist
    let user = find_user("123");
    if user.is_none() {
        return Err(HandlerError::NotFound("User not found".into()));
    }
    
    // 503 Service Unavailable - Backend down
    if !database_available() {
        return Err(HandlerError::ServiceUnavailable("Database down".into()));
    }
    
    // 500 Internal Error - Unexpected error
    if something_broke() {
        return Err(HandlerError::Internal("Unexpected error".into()));
    }
    
    Ok(json!({"status": "ok"}))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct RegisterUser {
    email: String,
    password: String,
    name: String,
}

fn validate_input(input: &amp;RegisterUser) -&gt; Result&lt;(), HandlerError&gt; {
    // Email validation
    if !input.email.contains('@') {
        return Err(HandlerError::ValidationError(
            "Invalid email format".into()
        ));
    }

    // Password validation
    if input.password.len() &lt; 8 {
        return Err(HandlerError::ValidationError(
            "Password must be at least 8 characters".into()
        ));
    }

    // Name validation
    if input.name.trim().is_empty() {
        return Err(HandlerError::ValidationError(
            "Name is required".into()
        ));
    }

    Ok(())
}

#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let input: RegisterUser = req.json()?;
    validate_input(&amp;input)?;
    Ok(Response::created(json!({"email": input.email})))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-error-type"><a class="header" href="#custom-error-type">Custom Error Type</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum AppError {
    UserNotFound(String),
    EmailTaken(String),
    InvalidCredentials,
    RateLimited,
    DatabaseError(String),
}

impl From&lt;AppError&gt; for HandlerError {
    fn from(e: AppError) -&gt; Self {
        match e {
            AppError::UserNotFound(id) =&gt; 
                HandlerError::NotFound(format!("User {} not found", id)),
            AppError::EmailTaken(email) =&gt; 
                HandlerError::ValidationError(format!("Email {} already registered", email)),
            AppError::InvalidCredentials =&gt; 
                HandlerError::Unauthorized("Invalid email or password".into()),
            AppError::RateLimited =&gt; 
                HandlerError::Internal("Rate limit exceeded".into()),
            AppError::DatabaseError(msg) =&gt; 
                HandlerError::DatabaseError(msg),
        }
    }
}

fn process(req: &amp;Request) -&gt; Result&lt;JsonValue, AppError&gt; {
    // Business logic with custom errors
    Err(AppError::InvalidCredentials)
}

#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let data = process(&amp;req)?;
    Ok(Response::ok(data))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="logging-errors-1"><a class="header" href="#logging-errors-1">Logging Errors</a></h2>
<p>Always log errors for debugging:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(_ctx: &amp;Context, req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    match process(&amp;req) {
        Ok(data) =&gt; Ok(Response::ok(data)),
        Err(e) =&gt; {
            // Log with request ID for tracing
            eprintln!("[{}] Error: {}", req.request_id, e);

            // Log stack trace for internal errors
            if matches!(e, HandlerError::Internal(_) | HandlerError::DatabaseError(_)) {
                eprintln!("[{}] Request path: {}", req.request_id, req.path);
                eprintln!("[{}] Request body: {:?}", req.request_id, req.body);
            }

            Err(e)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h2>
<p>Handle service failures gracefully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[handler]
pub async fn handle(ctx: &amp;Context, _req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    let cache = ctx.cache("redis").await;
    let db = ctx.database("main").await?;

    // Try cache first (non-fatal if unavailable)
    if let Ok(cache) = cache {
        match cache.get("data:key").await {
            Ok(Some(data)) =&gt; {
                return Ok(Response::ok(json!({"source": "cache", "data": data})));
            }
            Ok(None) =&gt; { /* Cache miss, continue */ }
            Err(e) =&gt; {
                // Log but don't fail - Redis being down shouldn't break the app
                eprintln!("Redis error (non-fatal): {}", e);
            }
        }
    }

    // Fallback to database
    match db.query("SELECT * FROM data", &amp;[]).await {
        Ok(result) =&gt; Ok(Response::ok(json!({"source": "db", "data": result}))),
        Err(e) =&gt; {
            eprintln!("Database error: {}", e);
            Ok(Response::json(503, json!({
                "error": "Service temporarily unavailable",
                "retry_after": 5,
            })))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pet-store-demo"><a class="header" href="#pet-store-demo">Pet Store Demo</a></h1>
<p>A complete REST API example demonstrating the same Pet Store API working with multiple storage backends.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The Pet Store demo shows how Rust Edge Gateway's <code>Storage</code> abstraction allows the <strong>same handler code</strong> to work with:</p>
<ul>
<li><strong>SQLite</strong> - Embedded database (no external dependencies)</li>
<li><strong>PostgreSQL</strong> - Full-featured relational database</li>
<li><strong>MySQL</strong> - Popular relational database</li>
<li><strong>MinIO</strong> - Object storage (pets stored as JSON files)</li>
<li><strong>FTP/SFTP</strong> - File transfer (pets stored as JSON files)</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><code class="language-bash">cd examples/petstore

# SQLite (default - no external dependencies)
./setup.sh sqlite

# PostgreSQL
./setup.sh postgres

# MySQL
./setup.sh mysql

# MinIO (object storage)
./setup.sh minio

# FTP/SFTP (file storage)
./setup.sh ftp
</code></pre>
<h2 id="api-endpoints"><a class="header" href="#api-endpoints">API Endpoints</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/pets</code></td><td>List all pets (optional <code>?status=</code> filter)</td></tr>
<tr><td>POST</td><td><code>/pets</code></td><td>Create a new pet</td></tr>
<tr><td>GET</td><td><code>/pets/{petId}</code></td><td>Get a pet by ID</td></tr>
<tr><td>PUT</td><td><code>/pets/{petId}</code></td><td>Update a pet</td></tr>
<tr><td>DELETE</td><td><code>/pets/{petId}</code></td><td>Delete a pet</td></tr>
</tbody></table>
</div>
<h2 id="storage-abstraction-1"><a class="header" href="#storage-abstraction-1">Storage Abstraction</a></h2>
<p>The key to multi-backend support is the Context API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_edge_gateway_sdk::prelude::*;

#[handler]
pub async fn handle(ctx: &amp;Context, _req: Request) -&gt; Result&lt;Response, HandlerError&gt; {
    // Access storage via Context - backend is configured in Admin UI
    let storage = ctx.storage("petstore").await?;

    let pets = storage.list("pets/").await?;
    Ok(Response::ok(json!({"pets": pets})))
}
<span class="boring">}</span></code></pre></pre>
<p>The storage backend (database, S3, FTP) is configured in the Admin UI, not in code.</p>
<h2 id="storage-api"><a class="header" href="#storage-api">Storage API</a></h2>
<p>All storage backends implement the same interface:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get a record by ID
storage.get("pet-123") -&gt; Result&lt;Option&lt;JsonValue&gt;, HandlerError&gt;

// List all records (with optional filter)
storage.list(Some("available")) -&gt; Result&lt;Vec&lt;JsonValue&gt;, HandlerError&gt;

// Create a new record
storage.create("pet-123", &amp;pet_json) -&gt; Result&lt;(), HandlerError&gt;

// Update an existing record
storage.update("pet-123", &amp;pet_json) -&gt; Result&lt;(), HandlerError&gt;

// Delete a record
storage.delete("pet-123") -&gt; Result&lt;bool, HandlerError&gt;
<span class="boring">}</span></code></pre></pre>
<h2 id="database-schema"><a class="header" href="#database-schema">Database Schema</a></h2>
<p>For SQL backends, use the provided schema:</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS pets (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    category TEXT,
    tags TEXT,  -- JSON array as string
    status TEXT NOT NULL DEFAULT 'available',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_pets_status ON pets(status);
</code></pre>
<h2 id="file-storage-format"><a class="header" href="#file-storage-format">File Storage Format</a></h2>
<p>For MinIO and FTP backends, pets are stored as individual JSON files:</p>
<pre><code>/pets/
  pet-001.json
  pet-002.json
  pet-003.json
</code></pre>
<p>Each file contains:</p>
<pre><code class="language-json">{
  "id": "pet-001",
  "name": "Buddy",
  "category": "dog",
  "tags": ["friendly", "trained"],
  "status": "available",
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:30:00Z"
}
</code></pre>
<h2 id="handler-code"><a class="header" href="#handler-code">Handler Code</a></h2>
<p>See the handler implementations in <code>examples/petstore/handlers/</code>:</p>
<ul>
<li><code>list_pets.rs</code> - List with optional status filter</li>
<li><code>get_pet.rs</code> - Get by ID</li>
<li><code>create_pet.rs</code> - Create with validation</li>
<li><code>update_pet.rs</code> - Partial update support</li>
<li><code>delete_pet.rs</code> - Delete by ID</li>
</ul>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre><code class="language-bash"># Create a pet
curl -X POST http://petstore.example.com/pets \
  -H "Content-Type: application/json" \
  -d '{"name": "Buddy", "category": "dog", "status": "available"}'

# List all pets
curl http://petstore.example.com/pets

# Filter by status
curl http://petstore.example.com/pets?status=available

# Get a specific pet
curl http://petstore.example.com/pets/pet-001

# Update a pet
curl -X PUT http://petstore.example.com/pets/pet-001 \
  -H "Content-Type: application/json" \
  -d '{"status": "sold"}'

# Delete a pet
curl -X DELETE http://petstore.example.com/pets/pet-001
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="management-api"><a class="header" href="#management-api">Management API</a></h1>
<p>The Rust Edge Gateway provides a REST API for managing endpoints, domains, collections, and services.</p>
<h2 id="base-url"><a class="header" href="#base-url">Base URL</a></h2>
<pre><code>http://localhost:9081/api
</code></pre>
<p>In production, access via your admin domain:</p>
<pre><code>https://rust-edge-gateway.yourdomain.com/api
</code></pre>
<h2 id="response-format"><a class="header" href="#response-format">Response Format</a></h2>
<p>All API responses follow this format:</p>
<pre><code class="language-json">{
  "ok": true,
  "data": { ... }
}
</code></pre>
<p>Or for errors:</p>
<pre><code class="language-json">{
  "ok": false,
  "error": "Error message"
}
</code></pre>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>Currently, the API is open. Future versions will support authentication.</p>
<h2 id="rate-limiting-1"><a class="header" href="#rate-limiting-1">Rate Limiting</a></h2>
<p>No rate limiting is currently applied to the management API.</p>
<h2 id="endpoints-overview"><a class="header" href="#endpoints-overview">Endpoints Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Endpoints</th></tr></thead><tbody>
<tr><td><a href="api/./domains.html">Domains</a></td><td><code>/api/domains/*</code></td></tr>
<tr><td><a href="api/./collections.html">Collections</a></td><td><code>/api/collections/*</code></td></tr>
<tr><td><a href="api/./services.html">Services</a></td><td><code>/api/services/*</code></td></tr>
<tr><td><a href="api/./endpoints.html">Endpoints</a></td><td><code>/api/endpoints/*</code></td></tr>
<tr><td>Import</td><td><code>/api/import/*</code></td></tr>
<tr><td>System</td><td><code>/api/health</code>, <code>/api/stats</code></td></tr>
</tbody></table>
</div>
<h2 id="system-endpoints"><a class="header" href="#system-endpoints">System Endpoints</a></h2>
<h3 id="health-check"><a class="header" href="#health-check">Health Check</a></h3>
<p>Check if the gateway is running.</p>
<pre><code class="language-bash">GET /api/health
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "status": "healthy",
    "version": "0.1.0"
  }
}
</code></pre>
<h3 id="statistics"><a class="header" href="#statistics">Statistics</a></h3>
<p>Get gateway statistics.</p>
<pre><code class="language-bash">GET /api/stats
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "endpoints_total": 10,
    "endpoints_running": 8,
    "requests_handled": 1234,
    "uptime_seconds": 3600
  }
}
</code></pre>
<h2 id="import-endpoints"><a class="header" href="#import-endpoints">Import Endpoints</a></h2>
<h3 id="import-openapi-spec"><a class="header" href="#import-openapi-spec">Import OpenAPI Spec</a></h3>
<p>Create endpoints from an OpenAPI 3.x specification.</p>
<pre><code class="language-bash">POST /api/import/openapi
Content-Type: application/json

{
  "spec": "openapi: 3.0.0\ninfo:\n  title: Pet Store\n...",
  "domain": "api.example.com",
  "domain_id": "uuid-of-domain",
  "create_collection": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spec</code></td><td>string</td><td>Yes</td><td>OpenAPI YAML or JSON content</td></tr>
<tr><td><code>domain</code></td><td>string</td><td>Yes</td><td>Domain to associate endpoints with</td></tr>
<tr><td><code>domain_id</code></td><td>string</td><td>No*</td><td>Domain UUID (*required if create_collection is true)</td></tr>
<tr><td><code>collection_id</code></td><td>string</td><td>No</td><td>Existing collection to add endpoints to</td></tr>
<tr><td><code>create_collection</code></td><td>bool</td><td>No</td><td>Create new collection from spec info</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "collection": {
      "id": "uuid",
      "name": "Pet Store",
      "base_path": "/v1"
    },
    "endpoints_created": 5,
    "endpoints": [
      {"id": "uuid", "name": "getPets", "path": "/pets", "method": "GET"},
      {"id": "uuid", "name": "createPet", "path": "/pets", "method": "POST"}
    ]
  }
}
</code></pre>
<h3 id="import-bundle-zip"><a class="header" href="#import-bundle-zip">Import Bundle (ZIP)</a></h3>
<p>Upload a ZIP file containing an OpenAPI spec and handler code files.</p>
<pre><code class="language-bash">POST /api/import/bundle?domain=api.example.com&amp;create_collection=true&amp;domain_id=uuid&amp;compile=true&amp;start=true
Content-Type: multipart/form-data

# Form field: bundle (or file, zip) = your-bundle.zip
</code></pre>
<p><strong>Query Parameters:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>domain</code></td><td>string</td><td>Yes</td><td>Domain to associate endpoints with</td></tr>
<tr><td><code>domain_id</code></td><td>string</td><td>No*</td><td>Domain UUID (*required if create_collection is true)</td></tr>
<tr><td><code>collection_id</code></td><td>string</td><td>No</td><td>Existing collection to add endpoints to</td></tr>
<tr><td><code>create_collection</code></td><td>bool</td><td>No</td><td>Create new collection from spec info</td></tr>
<tr><td><code>compile</code></td><td>bool</td><td>No</td><td>Compile handlers after import</td></tr>
<tr><td><code>start</code></td><td>bool</td><td>No</td><td>Start handlers after compilation (requires compile=true)</td></tr>
</tbody></table>
</div>
<p><strong>Bundle Structure:</strong></p>
<pre><code>bundle.zip
â”œâ”€â”€ openapi.yaml          # OpenAPI spec (or openapi.json, api.yaml, spec.yaml)
â”œâ”€â”€ bundle.yaml           # Optional manifest with dependencies
â””â”€â”€ handlers/             # Handler files (can also be at root or in src/)
    â”œâ”€â”€ get_pets.rs       # Matches operationId "getPets" or "get_pets"
    â”œâ”€â”€ create_pet.rs     # Matches operationId "createPet" or "create_pet"
    â””â”€â”€ get_pet_by_id.rs  # Matches operationId "getPetById" or "get_pet_by_id"
</code></pre>
<p><strong>Bundle Manifest (bundle.yaml):</strong></p>
<p>The optional <code>bundle.yaml</code> file can specify dependencies shared by all handlers:</p>
<pre><code class="language-yaml">bundle:
  name: my-api
  version: 1.0.0

dependencies:
  regex: "1.10"
  chrono:
    version: "0.4"
    features:
      - serde
  uuid:
    version: "1.0"
    features:
      - v4
      - serde

routes:
  - method: GET
    path: /pets
    handler: get_pets
  - method: POST
    path: /pets
    handler: create_pet
</code></pre>
<p>Handler files are matched to OpenAPI operations by normalizing names:</p>
<ul>
<li><code>getPet.rs</code> â†’ matches operationId <code>getPet</code> or <code>get_pet</code></li>
<li><code>list_all_pets.rs</code> â†’ matches operationId <code>listAllPets</code> or <code>list_all_pets</code></li>
</ul>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "collection": {"id": "uuid", "name": "Pet Store"},
    "endpoints_created": 5,
    "endpoints_updated": 0,
    "handlers_matched": 5,
    "compiled": 5,
    "started": 5,
    "endpoints": [...],
    "errors": []
  }
}
</code></pre>
<p><strong>Example with curl:</strong></p>
<pre><code class="language-bash">curl -X POST "http://localhost:8081/api/import/bundle?domain=api.example.com&amp;create_collection=true&amp;domain_id=abc123&amp;compile=true&amp;start=true" \
  -F "bundle=@my-api.zip"
</code></pre>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="list-with-filters"><a class="header" href="#list-with-filters">List with Filters</a></h3>
<p>Most list endpoints support query parameters:</p>
<pre><code class="language-bash">GET /api/endpoints?domain=api.example.com&amp;enabled=true
</code></pre>
<h3 id="pagination"><a class="header" href="#pagination">Pagination</a></h3>
<p>List endpoints will support pagination in future versions:</p>
<pre><code class="language-bash">GET /api/endpoints?page=1&amp;limit=20
</code></pre>
<h3 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h3>
<p>Always check the <code>ok</code> field in responses:</p>
<pre><code class="language-javascript">const response = await fetch('/api/endpoints');
const data = await response.json();

if (data.ok) {
  console.log('Endpoints:', data.data);
} else {
  console.error('Error:', data.error);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domains-api"><a class="header" href="#domains-api">Domains API</a></h1>
<p>Domains represent the top-level organization for your endpoints (e.g., <code>api.example.com</code>).</p>
<h2 id="list-domains"><a class="header" href="#list-domains">List Domains</a></h2>
<pre><code class="language-bash">GET /api/domains
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Production API",
      "host": "api.example.com",
      "description": "Main production API",
      "enabled": true,
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<h2 id="create-domain"><a class="header" href="#create-domain">Create Domain</a></h2>
<pre><code class="language-bash">POST /api/domains
Content-Type: application/json

{
  "name": "Production API",
  "host": "api.example.com",
  "description": "Main production API",
  "enabled": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Display name for the domain</td></tr>
<tr><td><code>host</code></td><td>string</td><td>Yes</td><td>Hostname (e.g., <code>api.example.com</code>)</td></tr>
<tr><td><code>description</code></td><td>string</td><td>No</td><td>Optional description</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>No</td><td>Whether domain is active (default: true)</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Production API",
    "host": "api.example.com",
    "description": "Main production API",
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="get-domain"><a class="header" href="#get-domain">Get Domain</a></h2>
<pre><code class="language-bash">GET /api/domains/{id}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Production API",
    "host": "api.example.com",
    "description": "Main production API",
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="update-domain"><a class="header" href="#update-domain">Update Domain</a></h2>
<pre><code class="language-bash">PUT /api/domains/{id}
Content-Type: application/json

{
  "name": "Updated API Name",
  "description": "Updated description",
  "enabled": false
}
</code></pre>
<p><strong>Request Body:</strong></p>
<p>All fields are optional. Only provided fields will be updated.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Display name</td></tr>
<tr><td><code>host</code></td><td>string</td><td>Hostname</td></tr>
<tr><td><code>description</code></td><td>string</td><td>Description</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>Active status</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Updated API Name",
    "host": "api.example.com",
    "description": "Updated description",
    "enabled": false,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T11:00:00Z"
  }
}
</code></pre>
<h2 id="delete-domain"><a class="header" href="#delete-domain">Delete Domain</a></h2>
<pre><code class="language-bash">DELETE /api/domains/{id}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": null
}
</code></pre>
<p><strong>Note:</strong> Deleting a domain will also delete all associated collections and endpoints.</p>
<h2 id="get-domain-collections"><a class="header" href="#get-domain-collections">Get Domain Collections</a></h2>
<p>List all collections belonging to a domain.</p>
<pre><code class="language-bash">GET /api/domains/{id}/collections
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "collection-uuid",
      "domain_id": "domain-uuid",
      "name": "Pet Store",
      "description": "Pet management endpoints",
      "base_path": "/pets",
      "enabled": true,
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections-api"><a class="header" href="#collections-api">Collections API</a></h1>
<p>Collections group related endpoints within a domain (e.g., "Pet Store", "User Management").</p>
<h2 id="list-collections"><a class="header" href="#list-collections">List Collections</a></h2>
<pre><code class="language-bash">GET /api/collections
</code></pre>
<p><strong>Query Parameters:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>domain_id</code></td><td>string</td><td>Filter by domain UUID</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "domain_id": "domain-uuid",
      "name": "Pet Store",
      "description": "Pet management endpoints",
      "base_path": "/pets",
      "enabled": true,
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<h2 id="create-collection"><a class="header" href="#create-collection">Create Collection</a></h2>
<pre><code class="language-bash">POST /api/collections
Content-Type: application/json

{
  "domain_id": "domain-uuid",
  "name": "Pet Store",
  "description": "Pet management endpoints",
  "base_path": "/pets",
  "enabled": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>domain_id</code></td><td>string</td><td>Yes</td><td>Parent domain UUID</td></tr>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Display name</td></tr>
<tr><td><code>description</code></td><td>string</td><td>No</td><td>Optional description</td></tr>
<tr><td><code>base_path</code></td><td>string</td><td>No</td><td>Common path prefix for endpoints</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>No</td><td>Whether collection is active (default: true)</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "domain_id": "domain-uuid",
    "name": "Pet Store",
    "description": "Pet management endpoints",
    "base_path": "/pets",
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="get-collection"><a class="header" href="#get-collection">Get Collection</a></h2>
<pre><code class="language-bash">GET /api/collections/{id}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "domain_id": "domain-uuid",
    "name": "Pet Store",
    "description": "Pet management endpoints",
    "base_path": "/pets",
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="update-collection"><a class="header" href="#update-collection">Update Collection</a></h2>
<pre><code class="language-bash">PUT /api/collections/{id}
Content-Type: application/json

{
  "name": "Updated Name",
  "description": "Updated description",
  "base_path": "/v2/pets",
  "enabled": false
}
</code></pre>
<p><strong>Request Body:</strong></p>
<p>All fields are optional. Only provided fields will be updated.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Display name</td></tr>
<tr><td><code>description</code></td><td>string</td><td>Description</td></tr>
<tr><td><code>base_path</code></td><td>string</td><td>Path prefix</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>Active status</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "domain_id": "domain-uuid",
    "name": "Updated Name",
    "description": "Updated description",
    "base_path": "/v2/pets",
    "enabled": false,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T11:00:00Z"
  }
}
</code></pre>
<h2 id="delete-collection"><a class="header" href="#delete-collection">Delete Collection</a></h2>
<pre><code class="language-bash">DELETE /api/collections/{id}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": null
}
</code></pre>
<p><strong>Note:</strong> Deleting a collection will also delete all associated endpoints.</p>
<h2 id="get-collection-endpoints"><a class="header" href="#get-collection-endpoints">Get Collection Endpoints</a></h2>
<p>List all endpoints in a collection.</p>
<pre><code class="language-bash">GET /api/collections/{id}/endpoints
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "endpoint-uuid",
      "name": "getPets",
      "path": "/pets",
      "method": "GET",
      "domain": "api.example.com",
      "collection_id": "collection-uuid",
      "description": "List all pets",
      "enabled": true
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="services-api"><a class="header" href="#services-api">Services API</a></h1>
<p>Services represent backend connections (databases, caches, storage) that handlers can use.</p>
<h2 id="list-services"><a class="header" href="#list-services">List Services</a></h2>
<pre><code class="language-bash">GET /api/services
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Main Database",
      "service_type": "postgres",
      "config": {
        "host": "db.example.com",
        "port": 5432,
        "database": "myapp"
      },
      "enabled": true,
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<h2 id="create-service"><a class="header" href="#create-service">Create Service</a></h2>
<pre><code class="language-bash">POST /api/services
Content-Type: application/json

{
  "name": "Main Database",
  "service_type": "postgres",
  "config": {
    "host": "db.example.com",
    "port": 5432,
    "database": "myapp",
    "username": "app_user",
    "password": "secret"
  },
  "enabled": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Display name</td></tr>
<tr><td><code>service_type</code></td><td>string</td><td>Yes</td><td>Type of service (see below)</td></tr>
<tr><td><code>config</code></td><td>object</td><td>Yes</td><td>Service-specific configuration</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>No</td><td>Whether service is active (default: true)</td></tr>
</tbody></table>
</div>
<p><strong>Service Types:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sqlite</code></td><td>SQLite embedded database</td></tr>
<tr><td><code>postgres</code></td><td>PostgreSQL database</td></tr>
<tr><td><code>mysql</code></td><td>MySQL database</td></tr>
<tr><td><code>redis</code></td><td>Redis cache/store</td></tr>
<tr><td><code>mongodb</code></td><td>MongoDB document database</td></tr>
<tr><td><code>minio</code></td><td>MinIO/S3 object storage</td></tr>
<tr><td><code>memcached</code></td><td>Memcached cache</td></tr>
<tr><td><code>ftp</code></td><td>FTP/FTPS/SFTP file transfer</td></tr>
<tr><td><code>email</code></td><td>SMTP email sending</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Main Database",
    "service_type": "postgres",
    "config": { ... },
    "enabled": true,
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="get-service"><a class="header" href="#get-service">Get Service</a></h2>
<pre><code class="language-bash">GET /api/services/{id}
</code></pre>
<h2 id="update-service"><a class="header" href="#update-service">Update Service</a></h2>
<pre><code class="language-bash">PUT /api/services/{id}
Content-Type: application/json

{
  "name": "Updated Name",
  "config": {
    "host": "new-db.example.com"
  },
  "enabled": false
}
</code></pre>
<h2 id="delete-service"><a class="header" href="#delete-service">Delete Service</a></h2>
<pre><code class="language-bash">DELETE /api/services/{id}
</code></pre>
<h2 id="activate-service"><a class="header" href="#activate-service">Activate Service</a></h2>
<p>Start the service actor. This spawns an async task that manages connections to the backend service.</p>
<pre><code class="language-bash">POST /api/services/{id}/activate
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "success": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "my-storage",
    "service_type": "minio",
    "active": true,
    "message": "MinIO service actor started successfully"
  }
}
</code></pre>
<h2 id="deactivate-service"><a class="header" href="#deactivate-service">Deactivate Service</a></h2>
<p>Stop the service actor. In-flight operations complete before shutdown.</p>
<pre><code class="language-bash">POST /api/services/{id}/deactivate
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "success": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "my-storage",
    "service_type": "minio",
    "active": false,
    "message": "Service deactivated"
  }
}
</code></pre>
<h2 id="test-service-connection"><a class="header" href="#test-service-connection">Test Service Connection</a></h2>
<p>Test if the service is reachable and properly configured.</p>
<pre><code class="language-bash">POST /api/services/{id}/test
</code></pre>
<p><strong>Response (Success):</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "connected": true,
    "latency_ms": 5,
    "message": "Connection successful"
  }
}
</code></pre>
<p><strong>Response (Failure):</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "connected": false,
    "error": "Connection refused"
  }
}
</code></pre>
<h2 id="minio-file-operations"><a class="header" href="#minio-file-operations">MinIO File Operations</a></h2>
<p>When a MinIO service is activated, the following endpoints become available for file operations:</p>
<h3 id="list-objects"><a class="header" href="#list-objects">List Objects</a></h3>
<pre><code class="language-bash">GET /api/minio/objects
GET /api/minio/objects?prefix=uploads/
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "bucket": "my-bucket",
  "prefix": "",
  "objects": [
    {
      "key": "uploads/file.txt",
      "size": 1234,
      "last_modified": "2025-12-17T00:29:55.205Z"
    }
  ]
}
</code></pre>
<h3 id="upload-object"><a class="header" href="#upload-object">Upload Object</a></h3>
<p>Upload a file using multipart form data.</p>
<pre><code class="language-bash">POST /api/minio/objects
Content-Type: multipart/form-data

file: (binary data)
key: uploads/myfile.txt
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "key": "uploads/myfile.txt",
  "bucket": "my-bucket",
  "size": 1234,
  "message": "Upload successful"
}
</code></pre>
<h3 id="download-object"><a class="header" href="#download-object">Download Object</a></h3>
<pre><code class="language-bash">GET /api/minio/objects/{key}
GET /api/minio/objects/uploads/myfile.txt
</code></pre>
<p>Returns the file content with appropriate Content-Type header based on file extension.</p>
<h3 id="delete-object"><a class="header" href="#delete-object">Delete Object</a></h3>
<pre><code class="language-bash">DELETE /api/minio/objects/{key}
DELETE /api/minio/objects/uploads/myfile.txt
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "key": "uploads/myfile.txt",
  "bucket": "my-bucket",
  "deleted": true
}
</code></pre>
<h2 id="service-configuration-examples"><a class="header" href="#service-configuration-examples">Service Configuration Examples</a></h2>
<h3 id="postgresql-1"><a class="header" href="#postgresql-1">PostgreSQL</a></h3>
<pre><code class="language-json">{
  "service_type": "postgres",
  "config": {
    "host": "localhost",
    "port": 5432,
    "database": "myapp",
    "username": "app_user",
    "password": "secret",
    "ssl_mode": "prefer",
    "pool_size": 10
  }
}
</code></pre>
<h3 id="mysql-1"><a class="header" href="#mysql-1">MySQL</a></h3>
<pre><code class="language-json">{
  "service_type": "mysql",
  "config": {
    "host": "localhost",
    "port": 3306,
    "database": "myapp",
    "username": "app_user",
    "password": "secret",
    "use_ssl": false,
    "pool_size": 10
  }
}
</code></pre>
<h3 id="redis"><a class="header" href="#redis">Redis</a></h3>
<pre><code class="language-json">{
  "service_type": "redis",
  "config": {
    "host": "localhost",
    "port": 6379,
    "password": null,
    "database": 0,
    "use_tls": false,
    "pool_size": 10
  }
}
</code></pre>
<h3 id="sqlite-1"><a class="header" href="#sqlite-1">SQLite</a></h3>
<pre><code class="language-json">{
  "service_type": "sqlite",
  "config": {
    "path": "/data/app.db",
    "create_if_missing": true
  }
}
</code></pre>
<h3 id="minio"><a class="header" href="#minio">MinIO</a></h3>
<pre><code class="language-json">{
  "service_type": "minio",
  "config": {
    "endpoint": "minio.example.com:9000",
    "access_key": "minioadmin",
    "secret_key": "minioadmin",
    "use_ssl": true,
    "bucket": "uploads"
  }
}
</code></pre>
<h3 id="ftpsftp"><a class="header" href="#ftpsftp">FTP/SFTP</a></h3>
<pre><code class="language-json">{
  "service_type": "ftp",
  "config": {
    "host": "sftp.example.com",
    "port": 22,
    "username": "user",
    "password": "secret",
    "protocol": "sftp",
    "base_path": "/uploads",
    "timeout_seconds": 30
  }
}
</code></pre>
<h3 id="email-smtp"><a class="header" href="#email-smtp">Email (SMTP)</a></h3>
<pre><code class="language-json">{
  "service_type": "email",
  "config": {
    "host": "smtp.example.com",
    "port": 587,
    "username": "sender@example.com",
    "password": "app-password",
    "encryption": "starttls",
    "from_address": "noreply@example.com",
    "from_name": "My App"
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="endpoints-api"><a class="header" href="#endpoints-api">Endpoints API</a></h1>
<p>Endpoints are the core resource - each represents a route with handler code.</p>
<h2 id="list-endpoints"><a class="header" href="#list-endpoints">List Endpoints</a></h2>
<pre><code class="language-bash">GET /api/endpoints
</code></pre>
<p><strong>Query Parameters:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>domain</code></td><td>string</td><td>Filter by domain hostname</td></tr>
<tr><td><code>collection_id</code></td><td>string</td><td>Filter by collection UUID</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>Filter by enabled status</td></tr>
</tbody></table>
</div>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "getPets",
      "path": "/pets",
      "method": "GET",
      "domain": "api.example.com",
      "collection_id": "collection-uuid",
      "description": "List all pets",
      "code": "use rust_edge_gateway_sdk::prelude::*;\n...",
      "enabled": true,
      "status": "running",
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
  ]
}
</code></pre>
<h2 id="create-endpoint"><a class="header" href="#create-endpoint">Create Endpoint</a></h2>
<pre><code class="language-bash">POST /api/endpoints
Content-Type: application/json

{
  "name": "getPets",
  "path": "/pets",
  "method": "GET",
  "domain": "api.example.com",
  "collection_id": "collection-uuid",
  "description": "List all pets",
  "code": "use rust_edge_gateway_sdk::prelude::*;\n\nfn handle(req: Request) -&gt; Response {\n    Response::ok(json!({\"pets\": []}))\n}\n\nhandler_loop!(handle);",
  "dependencies": {
    "regex": "1.10",
    "chrono": { "version": "0.4", "features": ["serde"] }
  },
  "enabled": true
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>string</td><td>Yes</td><td>Endpoint name (for display)</td></tr>
<tr><td><code>path</code></td><td>string</td><td>Yes</td><td>URL path pattern (e.g., <code>/pets/{id}</code>)</td></tr>
<tr><td><code>method</code></td><td>string</td><td>Yes</td><td>HTTP method (GET, POST, PUT, DELETE, PATCH)</td></tr>
<tr><td><code>domain</code></td><td>string</td><td>Yes</td><td>Domain hostname or <code>*</code> for all</td></tr>
<tr><td><code>collection_id</code></td><td>string</td><td>No</td><td>Parent collection UUID</td></tr>
<tr><td><code>description</code></td><td>string</td><td>No</td><td>Description of the endpoint</td></tr>
<tr><td><code>code</code></td><td>string</td><td>No</td><td>Rust handler code</td></tr>
<tr><td><code>dependencies</code></td><td>object</td><td>No</td><td>Custom Cargo dependencies (mirrors Cargo.toml format)</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td>No</td><td>Whether endpoint is active (default: true)</td></tr>
</tbody></table>
</div>
<h3 id="dependencies-format"><a class="header" href="#dependencies-format">Dependencies Format</a></h3>
<p>The <code>dependencies</code> field accepts an object where keys are crate names and values can be:</p>
<ul>
<li><strong>Simple version</strong>: <code>"regex": "1.10"</code></li>
<li><strong>With features</strong>: <code>"chrono": { "version": "0.4", "features": ["serde"] }</code></li>
<li><strong>Optional</strong>: <code>"tokio": { "version": "1", "optional": true }</code></li>
</ul>
<p>Example with multiple dependencies:</p>
<pre><code class="language-json">{
  "dependencies": {
    "regex": "1.10",
    "chrono": { "version": "0.4", "features": ["serde"] },
    "uuid": { "version": "1.0", "features": ["v4", "serde"] }
  }
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "name": "getPets",
    "path": "/pets",
    "method": "GET",
    "domain": "api.example.com",
    "collection_id": "collection-uuid",
    "description": "List all pets",
    "code": "...",
    "enabled": true,
    "status": "created",
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  }
}
</code></pre>
<h2 id="get-endpoint"><a class="header" href="#get-endpoint">Get Endpoint</a></h2>
<pre><code class="language-bash">GET /api/endpoints/{id}
</code></pre>
<h2 id="update-endpoint"><a class="header" href="#update-endpoint">Update Endpoint</a></h2>
<pre><code class="language-bash">PUT /api/endpoints/{id}
Content-Type: application/json

{
  "name": "Updated Name",
  "code": "// new code...",
  "dependencies": {
    "regex": "1.10"
  },
  "enabled": false
}
</code></pre>
<p>All fields are optional. Only provided fields are updated.</p>
<h2 id="delete-endpoint"><a class="header" href="#delete-endpoint">Delete Endpoint</a></h2>
<pre><code class="language-bash">DELETE /api/endpoints/{id}
</code></pre>
<h2 id="compile-endpoint"><a class="header" href="#compile-endpoint">Compile Endpoint</a></h2>
<p>Compile the handler code into an executable.</p>
<pre><code class="language-bash">POST /api/endpoints/{id}/compile
</code></pre>
<p><strong>Response (Success):</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "status": "compiled",
    "message": "Compilation successful"
  }
}
</code></pre>
<p><strong>Response (Failure):</strong></p>
<pre><code class="language-json">{
  "ok": false,
  "error": "error[E0308]: mismatched types\n  --&gt; src/main.rs:5:5\n..."
}
</code></pre>
<h2 id="start-endpoint"><a class="header" href="#start-endpoint">Start Endpoint</a></h2>
<p>Start the worker process for this endpoint.</p>
<pre><code class="language-bash">POST /api/endpoints/{id}/start
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "status": "running",
    "pid": 12345
  }
}
</code></pre>
<h2 id="stop-endpoint"><a class="header" href="#stop-endpoint">Stop Endpoint</a></h2>
<p>Stop the worker process.</p>
<pre><code class="language-bash">POST /api/endpoints/{id}/stop
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  "ok": true,
  "data": {
    "status": "stopped"
  }
}
</code></pre>
<h2 id="endpoint-status-values"><a class="header" href="#endpoint-status-values">Endpoint Status Values</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td><code>created</code></td><td>Endpoint defined, not yet compiled</td></tr>
<tr><td><code>compiled</code></td><td>Code compiled successfully</td></tr>
<tr><td><code>running</code></td><td>Worker process is active</td></tr>
<tr><td><code>stopped</code></td><td>Worker stopped, can be restarted</td></tr>
<tr><td><code>error</code></td><td>Compilation or runtime error</td></tr>
</tbody></table>
</div>
<h2 id="bind-service-to-endpoint"><a class="header" href="#bind-service-to-endpoint">Bind Service to Endpoint</a></h2>
<p>Associate a service with an endpoint.</p>
<pre><code class="language-bash">POST /api/endpoints/{id}/services
Content-Type: application/json

{
  "service_id": "service-uuid",
  "pool_id": "main-db"
}
</code></pre>
<p><strong>Request Body:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>service_id</code></td><td>string</td><td>Yes</td><td>Service UUID to bind</td></tr>
<tr><td><code>pool_id</code></td><td>string</td><td>Yes</td><td>Identifier used in handler code</td></tr>
</tbody></table>
</div>
<h2 id="unbind-service"><a class="header" href="#unbind-service">Unbind Service</a></h2>
<pre><code class="language-bash">DELETE /api/endpoints/{endpoint_id}/services/{service_id}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
